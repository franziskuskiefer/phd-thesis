%*******************************************************************************
%****************************** Preliminaries *********************************
%*******************************************************************************

\chapter{Prerequisites and Building Blocks}\label{ch:prelims}

\mynote{give all the functions like password hashing unique symbols to use}
\mynote{make all \PSetup etc unique and uniform}

In this chapter we recall known facts and assumptions as well as notations used throughout this thesis.
We start with some general mathematical fundamentals before giving generally useful definition in our setting.
While these definitions are all well known and do not need reference, most of them can be found (in maybe slightly different version) in \citet{katz2008introduction} or \citet{Goldreich2001}.

%********************************** %Math  **************************************
\section{Mathematical Background}
This is not a complete mathematical introduction but recalls the most important definitions needed in our context.
One very central definition when modelling computational security is the notion of computational indistinguishability.

\begin{definition}[Computational Indistinguishability]
Polynomial-time indistinguishability between two ensembles $X=\{X_n\}_{n\in\NN}$ and $Y=\{Y_n\}_{n\in\NN}$ is given if for every \ac{PPT} algorithm $D$, there exists a negligible function $\varepsilon(\cdot)$ such that
\[
  \left| \Pr[D(X) = 1] - \Pr[D(Y) = 1] \right| < \varepsilon(n).
\]
We use computational or polynomial-time indistinguishable interchangeably and write $X\stackrel{\varepsilon}{=}Y$.
\eod
\end{definition}

\subsection{Groups}
Groups are an important mathematical structure in cryptography.
In the following we give some useful definitions in the context of cyclic and composite order groups.

\begin{definition}[Groups]\label{def:groups}
Let \GG denote a set and $\circ$ a binary operation on two elements from \GG.
\GG is a group if it has \emph{closure}, a \emph{neutral} element, every element has an \emph{inverse} element, and it is \emph{associative}, \ie :
\begin{itemize}
	\item For all $g,h\in\GG$, $g\circ h \in\GG$
	\item There exists an element $e\in\GG$, called \emph{identity}, such that for all $g\in\GG$, $e\circ g=g=g\circ e$.
	\item For all $g\in\GG$ there exists an \emph{inverse} element $h\in\GG$ such that $g\circ h=e=h\circ g$.
	\item For all $g,h,k\in\GG$, $(g\circ h)\circ k=g\circ (h \circ k)$.
\end{itemize}
\eod
\end{definition}

\noindent
The \emph{order} of a finite group \GG is denoted by $|\GG|$ and is defined as the number of elements in \GG.
An \emph{abelian} group additionally is commutative, \ie for all $g,h\in\GG$, $g\circ h=h\circ g$.
In this work, and cryptography in general, we mainly use cyclic groups.

\subsubsection{Cyclic Groups}
Since many computational assumptions on groups used in cryptography rely on the cyclic property of groups we have to ensure that all groups used in this context are cyclic.

\begin{definition}[Cyclic Groups]\label{def:cyclicgroups}
Let \GG denote a finite group of order $p$.
\GG is \emph{cyclic} if there exists a \emph{generator} $g\in\GG$ such that $\{g^0,g^1,\dots,g^{p-1}\}=\GG$.
\eod
\end{definition}

\noindent
Therefore, we usually use groups of prime order $p$ since groups of prime order are cyclic.
Another useful feature of prime order groups is that all elements of group \GG, except the identity, are generators of \GG.
We write $\GG=\genG$ to denote a group \GG is generate by $g$.
Working in subgroups of $\ZZ_p$ it is further useful to know that $\ZZ^\ast_p=\{x\in{1,\dots,p-1}~|~\gcd(x,p)=1\}$ is a cyclic group as well.
In the case of cyclic groups where $p$ is prime all elements in $\ZZ^\ast_p$ are relatively prime to $p$ (and thus invertible modulo $p$) such that $\phi(p)=p-1$, where $\phi(p)=|\ZZ^\ast_p|$ denotes the cardinality of $\ZZ^\ast_p$.

\subsubsection{Composite Order Groups}
Composite order groups $\ZZ^\ast_N$ for integer $N=pq$ that is a product of two distinct primes $p$ and $q$ are another useful group for cryptography.
Note that $\ZZ^\ast_N=\{x\in{1,\dots,N-1}~|~\gcd(x,N)=1\}$ is always an abelian group under multiplication modulo integer $N>1$.
The cardinality of $\ZZ^\ast_N$ is given by $\phi(p)=(p-1)(q-1)$.

\subsection{Elliptic Curves}
This work is only marginally concerned with elliptic curve cryptography.
We therefore keep this section short and refer to \citet{HankersonMS03} for further introduction into elliptic curves in cryptography and more general definitions.

An \emph{elliptic curve} $E$ over prime-field $\ZZ_p$ is given by 
\[
  y^2 = x^3 + ax + b \mod p,
\]
with $a,b\in\ZZ_p$, $p>5$, and $4a^3 + 27b^2 \not= 0 \mod p$.
Points on curve $E$ are given by pairs $(x,y)\in\ZZ^2_p$ that fulfil those equations.
The set containing all these points, plus the point at infinity $\infty$, are denoted $E(\ZZ_p)$.
$E(\ZZ_p)$ with $\infty$ as identity and common arithmetic operations such as addition, subtraction, multiplication, and inversion forms an abelian group.
Note that we use the multiplicative notation for elliptic curves (even though it is an additive group).

\subsection{Pairings}
Let $\GG_1=\genG[1], \GG_2=\genG[2]$, and $\GG_T=\genG[T]$ denote cyclic groups of prime-order $p$.
A pairing is defined by an efficient bilinear map $e: \GG_1 \times \GG_2 \mapsto \GG_T$ with $e(g_1^x, g_2^y) = g_T^{xy}$ for $x,y\in\ZZ_p$.
In cryptography we usually distinguish between three different types of pairings \cite{GalbraithPS08}:

\begin{itemize}
  \item Type I: $\GG_1 = \GG_2$;
  \item Type II: $\GG_1 \not= \GG_2$ and there exists an efficiently computable homomorphism $\phi: \GG_2 \mapsto \GG_1$ (bot not for $\GG_1 \mapsto \GG_2$);
  \item Type III: $\GG_1 \not= \GG_2$, without any efficiently computable homomorphism between $\GG_1$ and $\GG_2$.
\end{itemize}

\subsection{Computational Assumptions}
In this section we recall computational assumptions used in the remainder of this thesis.
We distinguish between assumptions on cyclic groups and assumptions on composite order groups.
When saying something is hard with respect to the security parameter \secpar, this means that there exists no algorithm that can solve the problem in polynomial time in \secpar.

Asymptotic notation allows us to describe the behaviour of a function when its arguments converging towards some limit.
As mentioned earlier, security models used in this work are from the computational world.
In particular, running time and success or advantage probabilities of algorithms, \ie adversaries, are modelled as functions on security parameter \secpar.
Security is therefore only given for \emph{reasonable} security parameters.
To express this asymptotic notation is used.

\begin{definition}[Negligible Functions]\label{def:negligible}
A function $f$ is \emph{negligible} if for every polynomial $p(\cdot)$ there exists an $N\in\NN$ such that for all $n\in\NN$ with $n>N$ it holds that $f(n)<1/p(n)$.
\eod
\end{definition}

% \begin{definition}[Asymptotic Notation]\label{def:asymptotic}
% Let $f(n)$ and $g(n)$ denote functions from $\NN_0$ to $\RR_{\geq 0}$.
% \begin{itemize}
% 	\item $f(n)=\cO(g(n)):$ There exist $c,N\in\NN_0$ such that for all $n>N$ it holds that $f(n)\leq c\cdot g(n)$.
% 	\item $f(n)=\Omega(g(n)):$ There exist $c,N\in\NN_0$ such that for all $n>N$ it holds that $f(n)\geq c\cdot g(n)$.
% 	\item $f(n)=\Theta(g(n)):$ Both $f(n)=\cO(g(n))$ and $f(n)=\Omega(g(n))$ hold.
% 	\item $f(n)=o(g(n)):$ $\lim_{m\rightarrow\infty}\frac{f(n)}{g(n)}=0$
% 	\item $f(n)=\omega(g(n)):$ $\lim_{m\rightarrow\infty}\frac{f(n)}{g(n)}=\infty$ 
% 	\eod
% \end{itemize}
% \end{definition}

\paragraph{Probabilistic Polynomial-Time}
We often use the phrase \ac{PPT} to describe an efficient algorithm.
The actual definition of \ac{PPT}, first defined by \citet{gill1977}, is given for \ac{PP}, how \ac{PPT} is usually called in complexity theory, as follows:

\begin{definition}[\acl{PP}]\label{def:ppt}
\ac{PP} denotes the class of decision problems solvable by a \ac{PTM} \cA such that
\begin{itemize}
	\item \cA runs in polynomial-time,
	\item at least $1/2$ of the computation paths accept when the answer is `yes', and
	\item less than $1/2$ of the computation paths accept when the answer is `no'. \eod
\end{itemize}
\end{definition}

\noindent
The informal description for \aclp{PTM} is given in Definition \ref{def:ptm}.
We refer the interested reader to works concerned with complexity theory, \eg \cite{santos1969,WaterlooComplexity} for more on \ac{PTM} and a formal definition.

\begin{definition}[\acl{PTM} \cite{gill1977}]\label{def:ptm}
A \ac{PTM} is a Turing machine with distinguished states called coin-tossing states.
For each coin-tossing state, the finite control unit specifies two possible next states.
The computation of a \ac{PTM} is deterministic except that in coin-tossing states the machine tosses an unbiased coin to decide between the two possible next states.
\eod
\end{definition}

\noindent
Note that the running time is always parametrised with security parameter \secpar.
One may think of \ac{PPT} as a notion for ``feasible strategies'' or ``efficient algorithms'' running in time polynomial in \secpar.
In other words, this means that for some constants $a$ and $c$ the algorithm runs in time $a\cdot \secpar^c$ with security parameter \secpar.

\subsubsection{Cyclic Groups}
In this section we recall some computational assumptions in the group context that are believed to be hard.
The \ac{DLP} is the basis of all assumptions in those groups.

\begin{definition}[\acl{DLP}]\label{def:dlp}
Let \GG denote a group of prime order $p$ with generator $g$.
The \ac{DLP} in \GG states that given a random element $h\rin\GG$ it is hard to compute $x$ such that $h=g^x$, i.e. 

\[
  \Pr[\DLog_{\cA,\GG}(\secpar)=1] \leq \varepsilon(\secpar)
\]

\noindent
$\Exp_{\cA,\GG}^{\DLog}(\secpar):$\\
\hspace*{2em} obtain cyclic group $\GG$ of prime order $p$ with length $\secpar$ and generator $g$\\
\hspace*{2em} choose $h\rin\GG$\\
\hspace*{2em} $x \gets \cA(\GG, p, g, h)$\\
\hspace*{2em} output $1$ iff $g^x=h$, otherwise $0$\\
\eod
\end{definition}

\noindent
Several \ac{DLP}-based assumptions have been proposed.
The two most important ones are the \ac{DDH} and \ac{CDH} assumptions.

\begin{definition}[\acl{DDH}]\label{def:ddh}
Let \GG denote a group of order $p$ of length $\secpar$ with generator $g$.
The \ac{DDH} assumption in \GG states that given $(g,g^a,g^b,g^c)\in\GG^4$ it is hard relative to $\secpar$ to determine whether $c=ab$ for random scalars $a,b,c\rin\ZZ_p$, i.e. 

\[
  \left| \Pr[\cA(\GG, p, g, g^a, g^b, g^c)=1] - \Pr[\cA(\GG, p, g, g^a, g^b, g^{ab})=1] \right| \leq \varepsilon(\secpar).
\]
% for $a,b,c\rin\ZZ_p$.
\eod
\end{definition}

\begin{definition}[\acl{CDH}]\label{def:cdh}
Let \GG denote a group of order $p$ of length $\secpar$ with generator $g$.
The \ac{CDH} assumption in \GG states that given $(g,g^a,g^b)\in\GG^3$ it is hard relative to $\secpar$ to compute $g^{ab}$ for random scalars $a,b\rin\ZZ_p$.
\eod
\end{definition}

\noindent
When using \ac{DLP}-based assumptions in pairing groups we have to be more careful as the \ac{DDH} assumption might not hold and additional treatment of the pairing setting is necessary.

\begin{definition}[\acl{SXDH} \cite{BallardGMM05,AtenieseCHM05}]\label{def:sxdh}
Let $\GG_1=\genG[1]$, $\GG_2=\genG[2]$, and $\GG_T=\genG[T]$ denote groups of prime-order $p$ of length $\secpar$ with associated bilinear map $e$.
The \ac{SXDH} assumption states that the DDH assumption in $\GG_1$ and $\GG_2$ is hard relative to $\secpar$, i.e. given $(w_1,x_1,y_1,z_1)\in\GG^4_1$ and $(w_2,x_2,y_2,z_2)\in\GG^4_2$ it is hard to decide whether there exists values $a_1,a_2$ such that $x_1=w_1^{a_1}$, $z_1=y_1^{a_1}$, $x_2=w_2^{a_2}$, and $z_2=y_2^{a_2}$.
\eod
\end{definition}

\subsubsection{Composite Order Groups}
The basic problem underlying all hardness assumptions in composite order groups is the factoring problem.

\begin{definition}[Factoring Problem]\label{def:factoring}
Let $N=pq$ denote an integer with prime factors $p$ and $q$ of length \secpar each.
The factoring problem in $\ZZ^\ast_N$ states that given modulus $N$ it is hard relative to \secpar to compute $p',q'$ such that $N=p'q'$.
\eod
\end{definition}

\noindent
To define RSA-based assumptions we have to define the RSA key generation algorithm first.
Let $(N, e, d)\ralgout\KGen(\secpar)$ denote the RSA key-generation algorithm that generates $(N, e, d)$ such that $N=pq$ for two distinct primes $p$ and $q$ of size $\secpar$ each, $\gcd(e, \phi(N))=1$, and $ed=1\mod \phi(N)$.

\begin{definition}[RSA Assumption]\label{def:rsa}
Let $N=pq$ denote an integer with prime factors $p$ and $q$ of length \secpar each and $y\rin\ZZ^\ast_N$ a random element from $\ZZ^\ast_N$.
The RSA problem over $\ZZ^\ast_N$ states that given $(N,e,d,y)$ defined as above it is hard with respect to \secpar to compute $x$ such that $x^e = y \mod N$.
\eod
\end{definition}

\noindent
Informally, the one-more RSA assumption indicates that the RSA problem is hard relative to $\secpar$ even if the adversary is given access to an RSA oracle.

\begin{definition}[One-more RSA]\label{def:onemoreRSA}
Let $(N, e, d)\ralgout\KGen(\lambda)$ denote the RSA key-generation algorithm, and $r_j\rin\ZZ^\ast_N$ be uniformly random integers in $\ZZ^\ast_N$ for $j\in[1,t+1]$.
We say the one-more RSA problem is $(\lambda, t)$-hard if for every \ac{PPT} adversary \cA we have
\[ \Pr[\{x_i\}_{i\in[1,t+1]} \gets \cA^{(\cdot)^d \bmod N}(N, e, \lambda, r_1, \dots, r_{t+1})] \leq \varepsilon(\secpar), \]
where $x_i^e=r_i\mod N$, \cA made at most $t$ queries to the RSA oracle $(\cdot)^{^d \mod N}$ and $\varepsilon(\cdot)$ is a negligible function.
\eod
\end{definition}


% In addition to common notations (we do not recall here), we give here all notations used throughout this work.
% \mynote{see if anything of this is useful ...}
% \begin{itemize}
% 	\item If $A$ is an algorithm, then $x\algout A(y)$ denotes running $A$ with input $y$ and storing the result in $x$.
% 	\item If $A$ is a randomised algorithm, then $x\ralgout A(y;r)$ denotes running $A$ with input $y$ and randomness $r$, and storing the result in $x$.
% 	\item If $U$ is a set, then $x\rin U$ denotes that $x$ is chosen uniformly at random form $U$.
% 	\item A variable $y$ is assigned to $x$ by $x:=y$.
% 	\item The boolean operations \emph{and} and \emph{or} are denoted by $\wedge$ and $\vee$.
% 	\item Exclusive or (xor) is denoted by $\oplus$.
% 	\item Set of binary strings of length $n$ $\bits^n$.
% 	\item The length of a binary string $x$ is denoted by $|x|$, the bit-length of an integer $y$ is denoted by $\|y\|$.
% 	\item $\bigo,\Theta,\Omega,\omega$
% 	\item Since $\log_2$ is the most used logarithm we denote it by $\log$.
% 	\item The security parameter is denoted $\secpar$.
% 	\item Oracle access to $O(\cdot)$ for algorithm $A$ is denoted by $A^{O(\cdot)}$.
% 	\item Public/private key-pairs are denoted by $(\pk,\sk)$
% 	\item Negligible functions are denoted by $\varepsilon(\cdot)$.
% 	\item \aclp{PRF} are denoted by \PRF.
% 	\item \ZZ, \NN, \RR, $\NN_0$, $\NN_{\geq 0}$
% \end{itemize}

%********************************** SECURITY MODELS **********************************
\section{Security Models}
% \mynote{* PAKE\\ * VPAKE\\ * 2PAKE}

The two most popular models are the \ac{ROM} and the standard model.
In the \ac{ROM} a public randomly chosen black-box function $H$ is available to all parties, whereas no such function exists in the \emph{standard model}.
While this function \RO can not be instantiated in the real world it is useful (sometimes necessary) in many proofs.
Implementations of protocols requiring a random oracle usually instantiate it with a cryptographic hash function.
The function \RO is queried on an input $x$ and returns the ``hash value'' of $x$.
It is consistent, such that $y=\RO(x)$ for all $y\gets \RO(x)$, and the output $y$ of \RO is uniformly at random such that one can think of \RO as drawing a random element $y$ each time it is queried on a new $x$.
If \RO has seen $x$ before, it returns the previously chosen element $y$.
While not including random oracles, the standard model often includes a \ac{CRS} that is made available to all parties and can be seen as common set-up parameters.
% \subsection{Common Reference String}
The \acl{CRS} model, proposed by \citet{CanettiF01}, is a generalisation of the common random string model.
In the \ac{CRS} model all parties have access to a common reference string that was chosen according to some predefined distribution.
This model is usually referred to as the standard model with \ac{CRS} as the assumption of the additional \ac{CRS} being available is rather weak.

\subsection{Simulation-based Security}\label{app:simulation}
We recall the basic setting of the malicious model from \cite{Goldreich2004}.
Let $f:\bits^\ast \times \bits^\ast \rightarrow \bits^\ast \times \bits^\ast$ be a functionality such that $f(x,y)=(f_1(x, y), f_2(x,y))$ and $\Pi$ a two-party protocol to compute $f$.
% $\Lambda$ denotes the empty string and
In the ideal model every party gets an input and access to a trusted party.
Honest participants send their input to the trusted party while malicious parties, with additional input $z$ and random tape $r$, either abort or send some value with the length of their non-additional input to the trusted party.
The trusted party answers to the first party with $f_1(x, y)$ after obtaining input $(x,y)$.
If only one input is received, the trusted party replies with $\bot$ to both parties.
The trusted party further answers the second party with $f_2(x,y)$ if it didn't stop before, $\bot$ otherwise.
It may stop depending on its input and output if the first party is malicious.
While an honest party always outputs the value received from the trusted party, malicious parties can output any polynomially computable function of all its inputs.
The ideal and real model are formalised as follows.

%\texorpdfstring{\cite[Definition 7.2.4]{Goldreich2004}}{}
\begin{definition}[Ideal Model]
Let $B=(B_1, B_2)$ be a pair of \ac{PPT} algorithms representing strategies in the ideal model.
Such a pair is \emph{admissible} in the ideal malicious model if for at least one \emph{honest} $i\in\{1,2\}$, we have $B_i(u, z, r)=u$ and $B_i(u, z, r, v)=v$ for all possible $u,z,r$ and $v$.
Furthermore, $|B_i(u, z, r)| = |u|$ must hold for both $i$'s.
The joint execution of $f$ under $B$ in the ideal model on input pair $(x, y)$ and auxiliary input $z$, denoted $\IDEAL_{f, B(z)} (x, y)$, is defined by uniformly selecting a random tape $r$ for the adversary and letting 
\[ \IDEAL_{f, B(z)} (x, y) := \Xi(x,y,z,r),\]
with $\Xi(x,y,z,r)$ defined as follows.
If party 1 is honest:
\[ \Xi(x,y,z,r) := (f_1(x,B_2(y,z,r)), B_2(y,z,r,f_2(x,y'))); \]
If party 2 is honest:
\[
 \Xi(x,y,z,r) := \left\{
 \begin{array}{lllr}
    (B_1(x, z, r, f_1(x',y), \bot)&, \bot&) &\text{if } B_1(x, z, r, f_1(x',y)) = \bot ;\\
    (B_1(x,z,r,f_1(x',y))&, f_2(x',y)&) &\text{otherwise,}
  \end{array}\right.
\]
% $(B_1(x, z, r, v), B_2(y, z, r, \Lambda))$
with $x'=B_2(x,z,r)$.
\eod
\end{definition}

%\texorpdfstring{\cite[Definition 7.2.5]{Goldreich2004}}{}
\begin{definition}[Real Model]
Let $A=(A_1, A_2)$ be a pair of \ac{PPT} algorithms representing strategies in the real model.
Such a pair is \emph{admissible} with respect to $\Pi$ if at least one $A_i$ coincides with the strategy specified in $\Pi$.
The joint execution of $\Pi$ under $A$ in the real model, on input pair $(x, y)$ and auxiliary input $z$, denoted $\REAL_{\Pi, A(z)}(x, y)$, is defined as the output pair resulting from the interaction between $A_1(x, z)$ and $A_2(y, z)$.
\eod
\end{definition}

\noindent
A protocol $\Pi$ is said to be secure if its execution in the real model emulates execution of the ideal model with a trusted party for the according functionality.

\begin{definition}[Security \texorpdfstring{\cite[Definition 7.2.6]{Goldreich2004}}{}]
Protocol $\Pi$ is said to securely compute $f$ in the malicious model if for every \ac{PPT} pair of algorithms $A=(A_1, A_2)$ that is admissible for the real model, there exists a \ac{PPT} pair of algorithms $B=(B_1, B_2)$ that is admissible for the ideal model such that 
\[ \{\IDEAL_{f, B(z)}(x, y)\}_{x, y, z} \stackrel{c}{\equiv} \{\REAL_{\Pi, A(z)}(x, y)\}_{x, y, z} \]
where $x,y,z\in\bits^\ast$ such that $|x|=|y|$ and $|z|=\poly(|x|)$.
\eod
\end{definition}

\paragraph{The Hybrid Model}
When proving security of a protocol that is combined of other primitives and protocols we view those protocols as black boxes and prove security in the \HYBRID model instead of the \REAL model.
Security then follows from the composition theorem from \citet{Canetti00}.
In the $g$-\HYBRID world protocol $f$ is executed between two parties like in the \REAL world, but every invocation of sub-protocol $g$ is replaced with the according ideal functionality, \ie a call to the trusted party that computes $g$.
The output of the $g$-\HYBRID world for functionality $f$ and protocol $\Pi$ is denoted by $\HYBRID_{\Pi, A(z)}^{g} (x, y)$.
Let $\Pi^\Gamma$ denote the real world protocol $\Pi$ that uses $\Gamma$ as a sub-protocol, \ie instead of querying the trusted party to compute $g$, the real protocol $\Gamma$ is executed.
To prove security it is sufficient to show 
$\{\IDEAL_{f, B(z)}(x, y)\}_{x, y, z} \stackrel{c}{\equiv} \{\HYBRID_{\Pi, A(z)}^{g} (x, y)\}_{x, y, z}$,
which implies
$\{\IDEAL_{f, B(z)}(x, y)\}_{x, y, z} \stackrel{c}{\equiv} \{\REAL_{\Pi^{\Gamma}, A(z)} (x, y)\}_{x, y, z}$
as shown by \citet{Canetti00}.

\subsection{Universal Composability} \label{sec:uc-prelims}
We refrain from recalling the \ac{UC}-framework and refer to Chapter \ref{ch:intro} Section \ref{sec:uc-intro} for a brief overview and \citet{Canetti2001a} for a complete formal description.
In the following we give definitions of common \ac{UC} functionalities used in this thesis.

The \ac{CRS} functionality from \citet{CanettiF01} describes generation and distribution of the \ac{CRS}.
It is recalled in Figure \ref{fig:crsfunctionality}.

\begin{figure}[h!]
\begin{mdframed}[innertopmargin=10pt]
\begin{center}
{\bf Functionality \Fcrs}
\end{center}
\Fcrs is parametrised by a distribution $\cD$ and proceeds as follows:

\begin{description}
	
	\item[NewValue:] Upon input $(\NV, \sid)$ choose a value $d\rin\cD$, send $d$ back to the activating party and store the value if this is the first invocation.
	  In any other case return the value $d$ to the activating party.
	
\end{description}
\end{mdframed}
\caption{Ideal Functionality \Fcrs}
\label{fig:crsfunctionality}
\end{figure}

\noindent
Working with \acp{PKI} we require the functionality of a \ac{CA}.
The ideal \ac{CA} functionality \Fca was introduced by \citet{Canetti04}, recalled in Figure \ref{fig:cafunctionality}.

\begin{figure}[h!]
\begin{mdframed}[innertopmargin=10pt]
\begin{center}
{\bf Functionality \Fca}
\end{center}

\begin{description}
	
	\item[Registration:] Upon receiving the first message $(\Register, \sid, v)$ from party \cP, send $(\Registered, \sid, v)$ to the adversary; upon receiving \ok from the adversary, and if $\sid=\cP$ and this is the first request from \cP, then record the pair $(\cP,v)$.
	
	\item[Retrieve:] Upon receiving a message $(\Retrieve, \sid)$ from party $\cP'$, send $(\Retrieve, \sid, \cP')$ to the adversary, and wait for an \ok from the adversary.
	            Then, if there is a recorded pair $(\sid, v)$ output $(\Retrieve, \sid, v)$ to $\cP'$.
	            Otherwise output $(\Retrieve, \sid, \bot)$ to $\cP'$.
	
\end{description}
\end{mdframed}
\caption{Ideal Functionality \Fca}
\label{fig:cafunctionality}
\end{figure}

\noindent
To establish unique query identifiers between protocol participants we use the \Finit functionality from \citet{BarakLR04}, recalled in Figure \ref{fig:initfunctionality}.

\begin{figure}[h!]
\begin{mdframed}[innertopmargin=10pt]
\begin{center}
{\bf Functionality \Finit}
\end{center}
\Finit, with fixed session identifier $0$, runs in the universe with parties $\cU$ and adversary $\cS$.
When called the first time, it sets $\Hist=\emptyset$.

\begin{description}
	
	\item[Init:] Upon receiving $(\init, 0, \langle P_i, \cP, \cF \rangle)$ from $P_i$, where $\cP\subseteq\cU$, execute the following:
	  \begin{enumerate}
	    \item Send $(\init, 0, \langle P_i, \cP, \cF \rangle)$ to $\cS$.
	    \item Upon receiving back $(\setId, 0, \langle \sid', P_i, \cP, \cF \rangle)$ from $\cS$, do the following:
	      \begin{enumerate}
	        \item If $\sid'\in \Hist$, choose an arbitrary $\sid\not\in \Hist$.
	        \item If $\sid'\not\in \Hist$, set $\sid\gets\sid'$.
	        \item Update $\Hist \gets \Hist \cup \{\sid\}$.
	        \item Send $(\invoke, 0, \langle \sid, P_i, \cP, \cF \rangle)$ to $\cS$.
	      \end{enumerate}
	    \item Upon receiving a message $(\sendoutput, 0, \langle \sid, P_i, \cP, \cF \rangle)$ from $\cS$:
	      \begin{enumerate}
	        \item If $P_j\in\cP$ and it has not yet been sent to the \invoke message with $\langle \sid, P_i, \cP, \cF \rangle)$, send it $(\invoke, 0, \langle \sid, P_i, \cP, \cF \rangle)$.
	      \end{enumerate}
	  \end{enumerate}
	
\end{description}
\end{mdframed}
\caption{Ideal Functionality \Finit}
\label{fig:initfunctionality}
\end{figure}

\noindent
For reference we also recall the \ac{UC} functionality $\cF_{\mathrm{PAKE}}$ for \ac{PAKE} protocols in Figure \ref{fig:pakef}.

\begin{figure}[htb]
\begin{mdframed}[innertopmargin=10pt]
\begin{center}
{\bf Functionality $\cF_{\mathrm{PAKE}}$}
\end{center}
The functionality $\cF_{\mathrm{PAKE}}$ is parametrised by a security parameter $\secpar$. It interacts with an adversary \SIM and a set of parties via the following queries:
\begin{description}
	\item[NewSession:] Upon input $(\NS, \sid, P_i, P_j, \pwd, \role)$ from $P_i$, check that $P_j$ is legit and send $(\NS, \sid, P_i, P_j, \role)$ to \SIM.
	If this is the first NewSession query, or if this is the second NewSession query and there is a record $(\sid, P_j,P_i,\pwd')$, then record $(\sid, P_i, P_j, \pwd)$ and mark this record fresh.
	
	\item[TestPwd:] Upon input $(\TP, \sid, P_i, \pwd')$ from \SIM, check that a fresh record $(\sid, P_i, P_j, \pwd)$ exists, then do:
	If $\pwd=\pwd'$, mark the record as \compromised and reply to \SIM with ``correct guess''. If $\pwd\not=\pwd'$, mark the record \interrupted and reply with ``wrong guess''.
	
	\item[NewKey:] Upon input $(\NK, \sid, P_i, \sk)$ from \SIM, check that a record $(\sid, P_i, P_j, \pwd)$ exists, $|\sk|=\secpar$ and this is the first NewKey query for $P_i$, then:
	\begin{itemize}
		\item If the record is \compromised, or either $P_i$ or $P_j$ is corrupted, then output $(\sid,\sk)$ to $P_i$.
		\item If the record is fresh, and there is a record $(\sid, P_j, P_i, \pwd')$ with $\pwd'=\pwd$, and a key $\sk'$ was sent to $P_j$ and $(\sid, P_j,P_i,\pwd)$ was fresh at the time, then output $(\sid,\sk')$ to $P_i$.
		\item In any other case, pick a new random key $\sk'$ of length $\secpar$ and send $(\sid,\sk')$ to $P_i$.
	\end{itemize}
	Either way, mark the record $(\sid,P_i,P_j,\pwd)$ as completed.
	
\end{description}
\end{mdframed}
\caption{Ideal Functionality \FPAKE}
\label{fig:pakef}
\end{figure}


\subsection{Verifier-based PAKE Security}

We recall the related password model for \ac{VPAKE} protocols proposed by \citet{BenhamoudaP13}.
We consider client \Client, holding password $\pwd_\Client$, and servers \Server, holding password verifier $\ver=(H,s_H)$ with $H\gets\PHash(\paramP, s_H, \pwd_\Server)$ and random salt $s_H\gets\PHSalt(\paramP)$.
Passwords $\pwd_\Client$ and $\pwd_\Server$ are drawn from dictionary \cD with min-entropy $\beta$.
Adversary \cA has access to the following oracles to interact with protocol participants:

\begin{itemize}
	\item $\Execute(\Client_i,\Server_j)$ returns the transcript of the protocol execution between two honest instances $\Client_i$ and $\Server_j$.
		This models passive eavesdropping attacks.
	
	\item $\Send(P_i, P'_j, m)$ returns the result of $P'_j$ on input of message $m$ from alleged sender $P_i$.
		Invoking $\Send$ with a specific message initiates a session between $P_i$ and $P'_j$.
		This models active attacks.
		
	\item $\Corrupt(\Server)$ returns the server's secret $\ver=(H,s_H)$.
		Clients with $\pwd_\Server$ are marked as corrupted.
\end{itemize}

\noindent
Let $b$ denote a bit chosen prior to every execution of the experiment.
Security is modelled with a real-or-random style $\Test(P_i)$ oracle that, on input of participant instance $P_i$, returns a session key \key chosen as follows:
\begin{itemize}
	\item If $P_i$ has not computed a session key or $P_i$ is a partnered and corrupted client instance, return $\bot$.
	
	\item If $P_i$ is partnered with compatible $P'_j$ and a $\Test$ query has been asked for $P'_j$ previously, then return the same session key as for $P'_j$.
	
	\item If $P_i$ has been queried before, output the same as for the previous query.
	
	\item Otherwise return the real session key of $P_i$ if $b=1$, and a random session key if $b=0$.
\end{itemize}

%\begin{wrapfigure}[5]{r}{0.5\textwidth}
%	\vspace*{-2em}
%	\centering
%	\fbox{
%	\begin{minipage}[t]{0.45\textwidth}
%		$\Exp_{\Pi}(\secpar):$\\
%		\hspace*{2em}$b\rin\bits$\\
%		\hspace*{2em}$b'\gets \cA^{\Execute, \Send, \Corrupt, \Test}(\secpar)$\\
%		\hspace*{2em}return $b=b'$
%	\end{minipage}
%	}
%\end{wrapfigure}

\noindent
Two protocol participants are \emph{partnered} if they have matching transcripts, \ie the recorded transcript of one participant is a subset of the one recorded by the other party.
% Two protocol participants $P,P'$ are compatible if w.l.o.g. $P\in\cC$ and $P'\in\cS$, and $\PHash(\paramP, \PPreHash(\paramP, \pwd_P, s_P), s_H) = H_{P'}$.
% To define security we specify a real experiment $\Exp_\REAL$ and ideal experiment $\Exp_\IDEAL$.
% The real world adversary in $\Exp_\REAL$ has access to the aforementioned oracles and interacts with real participants using passwords chosen according to the dictionary \cD.
% The ideal world adversary in $\Exp_\IDEAL$ interacts with the aforementioned oracles that are modified as follows:
% $\Execute$ and $\Send$ oracles operate with an invalid dummy passwords;
% Non-trivial $\Test$ queries are always answered with a random session key.
% Additionally, after the adversary returned his guess for bit $b$, an $\Extract$ function is queried for all participants $P_i$ that have been target of an active attack and have been queried in a non-trivial $\Test$ query.
% The $\Extract$ function on input of a transcript $t$ returns salts $s_P$ and $s_H$ along with a hash value $H$ if $P_i$ is a client and a password \pwd if $P_i$ is a server.
A \ac{VPAKE} protocol $\Pi$ is secure if for all \ac{PPT} adversaries \cA running in time $t$ there exists a negligible function $\varepsilon(\cdot)$ such that the advantage of \cA is upper-bounded by
$2^{-\beta}q_s + \Adv_{\text{OW}}(\cB, \secpar) + \varepsilon(\secpar)$
for some attacker \cB on the one-wayness of the used password hashing scheme running in time $r$, $q_s$ active sessions, and independently chosen passwords from \cD of min-entropy $\beta$.
Password hashing and its security if defined in Chapter \ref{sec:vpake} Section \ref{sec:strucphash}.

\subsection{Two-server PAKE Security}
We briefly recall the \ac{2PAKE} security from \citet{Katz2012a}.
This model assumes that a client negotiates a distinct session key with each server.
It is assumed that adversary \cA corrupted servers before the execution of the experiment such that not more than one server in a protocol execution is corrupted.
Server to server communication is assumed to be secured with common mechanisms while client to server communication can be fully controlled by the attacker.
We consider clients \Client and servers \Server chosen from some fixed set of participants.
Clients hold a uniformly at random chosen password $\pwd\rin\cD$ and each server $\Server_0$ and $\Server_1$ that the is registered with holds an according password share $\share_0$, respectively $\share_1$.
Each participant instance $P_i$ holds a state with $\sid_P^i, \pid_P^i$, and $\sk_P^i$ to keep track of the sessions, partners, and the negotiated session key.
Further $\term_P^i$ and $\acc_P^i$ keep track whether $P_i$ terminated, respectively accepted.
The adversary is given access to the following oracles in order to communicate with protocol participants:

\begin{itemize}
  \item $\Send(\Client_i, \Server, m)$ for $\Client_i$ registered with \Server sends message $m$, supposedly from \Server, to $\Client_i$ and returns message $m'$ output by $\Client_i$, if any.
    An empty message $m$ initiates the protocol.
  
  \item $\Send(\Server_i, \Client, m)$ for $\Client$ registered with $\Server_i$ sends message $m$, supposedly from \Client, to $\Server_i$ and returns message $m'$ output by $\Server_i$, if any.
    If \Server is corrupted, the adversary receives the internal state of \Server; if the other associated server is corrupted as well, the attacker is given the internal state of that server as well.
    
  \item $\Execute(\Client_i, \Server_{0,j}, \Server_{1,j})$ for $\Client_i$ registered with $(\Server_{0,j},\Server_{1,j})$ executes the protocol and returns the transcript.
    In addition, the adversary is given the internal state of any corrupted server.
  
  \item $\Reveal(P_i, P'_i)$ for partnered instances $P_i$ and $P'_i$ returns session key $\sk_{P_i,P'_i}$ of $P_i$.
  
  \item $\Test(P_i, P'_i)$ for partnered instances $P_i$ and $P'_i$ returns $\bot$ if $\sk_{P_i, P'_i}=\NULL$, and either $\sk_{P_i,P'_i}$ of $P_i$ if a randomly chosen bit $b=1$, or a random value if $b=0$.
    
\end{itemize}

\noindent
Partnering is defined based on matching transcripts as usual.
The attacker, after interacting the oracles, outputs a bit $b'$.
$\Succ$ for \cA is then defined as $b=b'$.
A \ac{2PAKE} protocol $\Pi$ is called secure if the advantage of any \ac{PPT} adversary \cA there exists a negligible function $\varepsilon(\cdot)$ such that 
\[
  \Adv_{\cA,\Pi}(\secpar) = \left| \Pr[\Succ] - \frac12 \right| \leq \frac{q_s}{|\cD|} + \varepsilon(\secpar)
\]
for $q_s$ active sessions and dictionary \cD.

%********************************** %Building Blocks  **************************************
\section{Building Blocks}
This section describes building blocks used throughout this work to build the proposed protocols.
% But before starting with that we want to give a short description of some general models used to specify security in.
% the random oracle, which is an important though disputed, and standard model.


\subsection{Hash Functions}
Hash functions, usually denoted $H$, take arbitrary long strings as input and output a compressed string of shorter length than the input.
While originally used in data structures to store and retrieve data in constant time, they are an important cryptographic building block.
A main goal of (cryptographic) hash functions is to yield as few collisions as possible.
Informally speaking, a collision is a pair of distinct input elements $x$ and $x'$ to hash function $H$ such that $H(x)=H(x')$.

In cryptography families of functions are used, indexed by a key $s$, such that a hash function is given by $H_s(x)=H(s, x)$.
Note that the key is usually chosen in advance and omitted.
A successful \ac{PPT} attacker on the collision resistance of a hash function family $H_s$ is able to produce two distinct elements $(x,x')$ (which may be subject to a certain length if $H_s$ requires so) such that $H_s(x)=H_s(x')$.
$H$ is a \emph{collision resistant hash function} if any such attacker has negligible probability in succeeding.

% \mynote{* Collision resistant\\ * any other?}

\subsection{Commitments} \label{sec:commitments}
Let $\Commitment=(\SetupC,\Com)$ denote a commitment scheme and $C\gets\Com(x;r)$ a commitment on $x$ using randomness $r$, with \SetupC generating parameters for \Commitment.
A commitment scheme $\Commitment=(\SetupC,\Com)$ is \emph{efficient} if $\SetupC(\secpar)$ and $(C,d)\gets\Com(x;r)$ are computable in polynomial time ($d$ denotes the decommitment to $C$ and is usually omitted), \emph{complete} if $\Com(d)=(C,d)$ for $(C,d)\gets\Com(x;r)$, and secure if it is
\begin{itemize}
  \item Binding: For all \ac{PPT} adversaries \cA there exists a negligible function $\varepsilon_{\mathrm{bi}}(\cdot)$ such that for all $(x,x',r,r',C)\gets \cA(\secpar)$:
    $\Pr[x\not=x'\wedge (C,d)=\Com(x;r)\wedge (C,d')=\Com(x';r')] \leq \varepsilon_{\mathrm{bi}}(\secpar)$,
  \item Hiding: For all \ac{PPT} adversaries $\cA$ there exists a negligible function $\varepsilon_{\mathrm{hi}}(\cdot)$ such that for all $x_0,x_1$ with $|x_0|=|x_1|$, $b\rin\bits, (C,d)\gets\Com(x_b;r)$, and $b'\gets \cA(C,x_1,x_2)$:
    $\Pr[b=b'] \leq 1/2+\varepsilon_{\mathrm{hi}}(\secpar)$.
\end{itemize}

\noindent
A commitment scheme is further homomorph if there exist functions $\circ$ and $\star$ such that for all commitments $(C_i,d_i)\gets\Com(x_i;r_i)$  for $i\in[1,n]$ that $C_1 \circ \cdots \circ C_n = \Com(x_1\star \cdots \star x_n, r_i\star \cdots \star r_n)$.

\subsubsection{Pedersen commitments}
\citet{Pedersen91} commitments are perfectly hiding, computationally binding, homomorphic commitments, defined as follows.
Let $\Pedersen=(\SetupC$, $\Com)$ with $(g,h,p,\secpar)\gets\SetupC(\secpar)$ and $C\gets\Com=(x;r)=g^x h^r$ denote the Pedersen commitment scheme where $g$ and $h$ are generators of a cyclic group \GG of prime order $p$ with bit-length in the security parameter $\secpar$ and the discrete logarithm of $h$ with respect to base $g$ is not known.
Pedersen commitments are \emph{additively homomorph}, i.e. for all $(C_i,d_i) \gets \Com(x_i;r_i)$ for $i\in 1,\dots,n$ it holds that $\prod_{i=1}^{n}C_i=\Com(\sum_{i=1}^{n}x_i$; $\sum_{i=1}^{n}r_i)$.

\paragraph{Trapdoor commitments}
In some scenarios such as zero-knowledge proofs of knowledge with malicious verifiers we require trapdoor commitments, which allow a party knowing the correct trapdoor to open a commitment to any value (equivocable commitment).
Pedersen commitments are trapdoor commitments as they can be opened to any element using the discrete logarithm $\log_g h$ as trapdoor.

%----------------------------------- Zero Knowledge Proofs-----------------------
\subsection{Zero Knowledge Proofs}
A zero-knowledge proof is executed between a prover and a verifier, proving that a word $x$ is in a language $L$, using a witness $w$ proving so.
An interactive protocol $\Pi$ for a language $L$ between prover $P$ and verifier $V$ is a zero knowledge proof if the following holds:
\begin{itemize}
	\item Completeness: If $x\in L$, $V$ accepts if $P$ holds a witness proving so.
	\item Soundness: For every malicious prover $P^\ast(x)$ with $x\not\in L$ the probability of making $V$ accept is negligible.
	\item Zero-Knowledge: If $x\in L$, then there exists an efficient simulator \Sim that on input of $x$ is able to generate a view, indistinguishable from the view of a (malicious) verifier $V^\ast$.
\end{itemize}

\paragraph{Zero-Knowledge Proof of Knowledge}
A \ac{ZKPoK} is a zero-knowledge proof with the following special soundness definition:
\begin{itemize}
	\item Special Soundness: For any $x$ and any pair of accepting conversations on input $x$, $(m_1, c, m_2)$, $(m_1, c', m'_2)$ with $c\not= c'$ there exists an efficient knowledge extractor \Ext that can extract a witness $w$ such that $(x,w)\in R$.
\end{itemize}

\paragraph{$\bm{\Sigma}$ Protocols}\hfill\\
$\Sigma$-protocols describe a common structure of \ac{ZKPoK} protocols.
\citet{Damgard10} gives a detailed description of $\Sigma$-protocols and their properties.
The basic definition is given as follows.
A \ac{ZKPoK} protocol $\Pi$ is said to be a $\Sigma$ protocol for relation $R$ if it has the following message structure:
\begin{enumerate}
  \item $P$ sends the first message (commitment) $m_1\gets P_1(x,w,r)$ for element $(x,w)\in R$ and randomness $r$.
  \item $V$ sends random challenge $c\rin\bits^\secpar$ and returns it to prover $P$.
  \item $P$ sends the seconds message (response) $m_2\gets P_2(x,w,r,c)$ back to verifier $V$.
  \item $V$ accepts iff $(x,m_1,c,m_2)$ can be verified.
\end{enumerate}


\subsubsection{Committed Zero-knowledge Proofs} \label{sec:commited-sigma}
\citet{Damgard00} and \citet{JareckiL00} proposed the following committed $\Sigma$-protocol to ensure extractability (\ac{ZKPoK}) and simulatability when interacting with a malicious verifier and preserve zero-knowledge under parallel execution.
Let $P_1(x,w,r)$ and $P_2(x,w,r,c)$ denote the two prover steps of a $\Sigma$-protocol and $H:\bits^\ast\mapsto\ZZ_p$ a collision-resistant hash function.
A committed $\Sigma$-protocol based on Pedersen commitments is then given by the following four steps:
\begin{itemize}
  \item The prover computes the first message $m_1\gets P_1(x,w,r)$, computes 
  \[M_1\gets\Com(H(x,m_1); r_1)=g^{H(x,m_1)}h^{r_1},\]
  and sends $M_1$ to the verifier.
  \item The verifier chooses challenge $c\rin\bits^\secpar$ and returns it to the prover.
  \item The prover computes the second message $m_2\gets P_2(x,w,r,c)$, computes 
  \[M_2\gets\Com(H(m_2); r_2)=g^{H(m_2)}h^{r_2},\]
   and sends $M_2$ to the verifier.
  \item Further, the prover opens the commitments $M_1$ and $M_2$ by sending $(x,m_1,m_2,r_1,r_2)$ to the verifier.
  \item The verifier accepts iff both commitments are valid and if the verification of the $\Sigma$-protocol $(x,m_1,c,m_2)$ is successful.
\end{itemize}

% \noindent
% Despite being zero-knowledge in the malicious verifier setting, this type of protocol has the advantage of concurrent zero-knowledge (since no rewinding is necessary \cite{Damgard00,JareckiL00}).


%----------------------- PK Encryption schemes---------------------------
\subsection{Public Key Encryption}

Public key encryption allows party $A$ holding a \emph{public key \pk} of some party $B$ to encrypt a message $m$ in ciphertext $c$ such that only the party holding the according \emph{secret key \sk} ($B$ usually) to decrypt the ciphertext $c$ to $m$.
It is formally defined as follows.

\begin{definition}[Public Key Encryption]\label{def:pkencryption}
A public key encryption scheme $\PKE=(\PKEGen$, $\Enc$, $\Dec)$ consists of the following three algorithms:
\begin{itemize}
  \item $\PKEGen(\secpar)$ generates a secret/public key-pair $(\sk,\pk)$ on input of the security parameter \secpar
  \item $\Enc_\pk(m; r)$ encrypts message $m$ with public key \pk and randomness $r$, and outputs ciphertext $c$
  \item $\Dec_\sk(c)$ decrypts ciphertext $c$ with secret key \sk and outputs message $m$ \eod
\end{itemize}
\end{definition}


\subsubsection{Public Key Encryption secure against Chosen-Plaintext Attacks}
\acp{CPA} define security for \ac{PKE} schemes where the attacker is allowed to query an encryption oracle.

\begin{definition}[IND-CPA Security]\label{def:indcpa}
A \ac{PKE} scheme $\Pi=(\PKEGen,\Enc,\Dec)$ is \emph{IND-CPA} secure if for all \ac{PPT} adversaries $\cA$ there exists a negligible function $\varepsilon(\cdot)$ such that:
\[\Adv_{\Pi,\cA}^{\cpa}(\secpar)=\left|\Pr[\Exp^{\cpa}_{\Pi,\cA}(\secpar)=1]-\frac12\right|\leq\varepsilon(\secpar)\]

\noindent
$\Exp^{\cpa}_{\Pi,\cA}(\secpar):$\\
\hspace*{2em}$(\pk,\sk)\ralgout\KGen(\secpar),~b\rin\bits$\\
\hspace*{2em}$(m_0,m_1)\gets\cA^{\Enc_\pk(\cdot)}(\secpar,\pk)$\\
\hspace*{2em}$c\gets\Enc_\pk(m_b)$\\
\hspace*{2em}$b'\gets\cA^{\Enc_\pk(\cdot)}(\secpar,\pk,m_0,m_1,c)$\\
\eod
\end{definition}


\paragraph{ElGamal Encryption}\label{sec:elgamalencryption}
\citet{Gamal84} encryption operates on a multiplicative group \GG of prime order $p$ with generator $g$.
Note that we assume $m\in\GG$, which can be achieved by $m=g^{m'}$ for a message $m'\in\ZZ_p$.
\begin{itemize}
  \item $\PKEGen^\EG(\secpar)$ outputs $(\pk, \sk)$ with public key $\pk=h=g^z$ and secret key $\sk=z\rin\ZZ_p$.
  \item $\Enc^{\EG}_\pk(m;r)$ outputs $C=(u,e)$ with $u=g^r$ and $e=h^rg^m$.
  \item $\Dec_\sk^\EG(C)$ outputs $m=e/u^z$.
\end{itemize}
% Key generation $\PKEGen(\secpar)$ outputs a public key $\pk=h=g^z$ for random $\sk=z\rin\ZZ_p$ and $x$ as secret key.
% Let $C=(u,e)\algout\Enc^{\EG}_\pk(m;r)$ with $u=g^r$ and $e=h^rg^m$ denote an El-Gamal ciphertext.
% Decryption is given by $m=\Dec_\sk^\EG(C)=e/u^z$.


\subsubsection{Public Key Encryption secure against Chosen-Ciphertext Attacks}
\acp{CCA} define security for \ac{PKE} schemes where the attacker is allowed to query encryption \emph{and} decryption oracles.
It is therefore a stronger security notion than \ac{CPA}.
Note that we always refer to adaptive \ac{CCA}-security, i.e. \ac{CCA}2, when talking about \ac{CCA}-security.

\begin{definition}[IND-CCA Security]\label{def:indcca2}
A \ac{PKE} scheme $\Pi=(\PKEGen,\Enc,\Dec)$ is \emph{IND-CCA2} secure if for all \ac{PPT} adversaries $\cA$ there exists a negligible function $\varepsilon(\cdot)$ such that:
\[\Adv_{\Pi,\cA}^{\cca}(\secpar)=\left|\Pr[\Exp^{\cca}_{\Pi,\cA}(\secpar)=1]-\frac12\right|\leq\varepsilon(\secpar)\]

\noindent
$\Exp^{\cca}_{\Pi,\cA}(\secpar):$\\
\hspace*{2em}$(\pk,\sk)\ralgout\PKEGen(\secpar),~b\rin\bits$\\
\hspace*{2em}$(m_0,m_1)\gets\cA^{\Enc_\pk(\cdot),\Dec_\sk(\cdot)}(\secpar,\pk)$\\
\hspace*{2em}$c\gets\Enc_\pk(m_b)$\\
\hspace*{2em}$b'\gets\cA^{\Enc_\pk(\cdot),\Dec_\sk(\cdot)}(\secpar,\pk,m_0,m_1,c)$\\
\hspace*{2em}return $b=b'$ if \cA did not query $\Dec_\sk(c)$; $0$ otherwise
\eod
\end{definition}

\paragraph{Labelled Public Key Encryption}
Labelled \ac{PKE} \cite{Shoup01,Canetti2005} is a variant of \ac{PKE} that takes a public \emph{label $\ell$} as additional input to the encryption ($\Enc_\pk(m,\ell; r)$) and decryption algorithm ($\Dec_\sk(c,\ell)$).
The attacker in the \ac{CCA}-security experiment is now also allowed to query the decryption oracle on $c$ as long as the label $\ell'$ handed to the oracle is different from $\ell\not=\ell'$.


\paragraph{Cramer-Shoup Encryption}\label{sec:csencryption}
Labelled \ac{CS} encryption here operates on a multiplicative group $\GG$ of prime order $p$ with generators $g_1$ and $g_2$.
Note that we assume $m\in\GG$, which can be achieved by $m=g^{m'}$ for a message $m'\in\ZZ_p$.
Common \ac{CS} encryption simply omits label $\ell$.
% Key generation $\PKEGen(\secpar)$ returns public key $\pk=(c,d,H_k)$ with $c=g_{1}^{x_1}g_{2}^{x_2}, d=g_{1}^{y_1}g_{2}^{y_2}, h=g_{1}^z$ and hash function $H_k$ such that $\sk=(x_1,x_2,y_1,y_2,z)$ denotes the decryption key.
% Let $C=(\ell,\bm{u},e,v)\algout\Enc^{\CS}_\pk(\ell,m;r)$ (on label $\ell$, message $m$, and randomness $r$) with $\bm{u}=(u_1,u_2)=(g_{1}^r,g_{2}^r),~ e=h^rg_1^m$ and $v=(cd^{\xi})^r$ with $\xi=H_k(\ell,\bm{u},e)$ denote a labelled Cramer-Shoup ciphertext.
% Decryption is defined as $g_1^m=\Dec_\sk^\CS(C)=e/u_1^z$ if $u_1^{x_1+y_1\cdot \xi'}u_2^{x_2+y_2\cdot \xi'}=v$ with $\xi'=H_k(\ell,\bm{u},e)$.

\begin{itemize}
  \item $\PKEGen^\CS(\secpar)$ outputs $(\pk, \sk)$ with public key $\pk=(c,d,H_k)$ for $c=g_{1}^{x_1}g_{2}^{x_2}, d=g_{1}^{y_1}g_{2}^{y_2}, h=g_{1}^z$ and hash function $H_k$ such that $\sk=(x_1,x_2,y_1,y_2,z)$ denotes the decryption key.
  \item $\Enc^{\CS}_\pk(\ell,m;r)$ on input label $\ell$, message $m$, and randomness $r$ outputs $C=(\ell,\bm{u},e,v)$ with $\bm{u}=(u_1,u_2)=(g_{1}^r,g_{2}^r),~ e=h^rg_1^m$ and $v=(cd^{\xi})^r$ with $\xi=H_k(\ell,\bm{u},e)$
  \item $\Dec_\sk^\CS(\ell,C)$ outputs $m=e/u_1^z$ if $u_1^{x_1+y_1\cdot \xi'}u_2^{x_2+y_2\cdot \xi'}=v$ with $\xi'=H_k(\ell,\bm{u},e)$.
\end{itemize}

%----------------------- OBI ---------------------------
\subsection{Oblivious Bloom Intersection}\label{sec:obi}
Originally, the \ac{OBI} protocol was designed for \ac{PSI} such that at the end of the protocol, the client learns the intersection $\cC\cap \cS$ and the server learns nothing. 
The \ac{OBI} protocol by \citet{DongCW13} is executed between a client and a server on the respective sets \cC and \cS. 
As observed by \citet{WenD14}, \ac{OBI} can be extended to a Private Set Intersection with Data Transfer protocol. In this case, the server can associate each element $s_i\in\cS$ with a data item $d_i$. 
At the end of the protocol, for each element in the intersection the client also receives the corresponding data item from the server. 
The protocol can be described at a high level as follows: let the server hold a set $\cS=\{s_i\}$ and a data set $\cS_d=\{d_{i}\}$. The two sets are of equal cardinality and each $(s_i,d_i)$ can be viewed as a key-value pair. 
The server generates a garbled Bloom filter $G_\cS$ on \cS and $\cS_d$ using \citet[Algorithm 1]{WenD14} (recalled in Algorithm \ref{alg:gbf}). 
The garbled Bloom filter encodes both $\cS$ and $\cS_d$ in a way such that querying the key $s_i\in\cS$ against $G_\cS$ returns the data item $d_i$ and querying $s_j\not \in \cS$ returns a random string. Let the client hold a set $\cC$. The client encodes the set into a conventional Bloom filter~\cite{blo70} $B_\cC$. 
The client and the server run an oblivious transfer protocol using the Bloom filter and the garbled Bloom filter as inputs. 
As the result, the client receives a garbled Bloom filter $G_{\cC\cap\cS}$ that encodes the intersection $\cC\cap \cS$ and the data items associated with the elements in $\cC\cap \cS$. Then the client can query $G_{\cC\cap\cS}$ with each element $c_i\in\cC$. If $c_i$ is in the intersection then there must be  some $s_j\in \cS$ such that $c_i=s_j$ and the query result is $d_j$, the data item associated with $s_j$, otherwise the client gets a random string. 

\begin{algorithm}[htb]
\caption{GBFIntesection $(G, B, m, \lambda)$}
\label{alg:gbfintersection}
\begin{algorithmic}[1]
\REQUIRE Garbled bloom filter $G$, Bloom filter $B$, integer $m, \lambda$
\ENSURE An $(m, n, k, H, \lambda)$-garbled Bloom filter GBF$_X$
\STATE GBF$_X = [m]$ \COMMENT{create empty array of size $m$}
\FOR{$i=0$ \TO $m-1$}
  \IF{$B[i] == 1$}
    \STATE GBF$_X[i] = G[i]$
  \ELSE
    \STATE GBF$_X[i] \ralgout \{0,1\}^\lambda$
  \ENDIF
\ENDFOR
\end{algorithmic}
\end{algorithm}

\begin{figure}[htb]
\centering
\scalebox{0.58}{
\begin{tikzpicture}[framed] %[scale=0.7, every node/.style={scale=0.7}, ]
\matrix (m)[matrix of nodes, column  sep=.1cm,row  sep=1mm, ampersand replacement=\&,
		nodes={draw=none, anchor=center,text depth=1pt},
		column 1/.style={nodes={minimum width=23em, align=left}}, %,text width=15em
		column 2/.style={nodes={minimum width=14em}},
		column 3/.style={nodes={minimum width=18em, align=right, text width=18em}}]{
	\node[align=center](client){$C~ (B_\cC)$}; \draw[]($(client.south west)+(.5,0)$)--($(client.south east)-(.5,0)$); \& \& \node[align=center](server){$S$ $(G_\cS)$}; \draw[]($(server.south west)+(.5,0)$)--($(server.south east)-(.5,0)$);\\ [1mm]
	
	\parbox{23em}{} \& %generate Bloom filter $B$ for $\cC$, generate GBF $G$ with Algorithm \ref{alg:gbf}
	  neg. params $(n, m, k, H, E)$ \& \\
	  
	\parbox{23em}{} \& \&  \\ %	  on $(\cS, S_d, n, m, k, H, \lambda)$
	
	\parbox{23em}{generates  $r_i\ralgout\{0,1\}^\lambda$ for $i\in[0,m-1]$} \&
	   $\{r_i\}_{i\in[0,m-1]}$ \&
	   $\sk$ $\ralgout$ $\KGen_E(\lambda)$\\ 
	   
	\& \& $\forall i$ $\in$ $[0,m-1]$ $: c_i$ $\gets$ $\Enc_\sk(r_i||G[i])$ \\
	
	\& \& share \sk into $(t_0, \dots, t_{m-1})$ using XOR\\
	
  \parbox{23em}{$\forall i\in[0,m-1]:$ if $B[i]=1$ get $c_i;$ else $t_i$} \& 
  $B \rightarrow$ {\bf OT} $\leftarrow \{(c_i, t_i)\}_{i\in[0,m-1]}$ \& \\
  
  \parbox{23em}{Recover \sk from recovered $t_i$ XOR} \& \& \\
  
  \parbox{23em}{$\forall $ recovered $c_i: d_i\gets\Dec_\sk(c_i)$} \& \&  \\
  
  \parbox{23em}{$\forall $ recovered $d_i: d_i[0,\lambda-1] \stackrel{?}{=} r_i$; else return with $\bot$} \& \&  \\
  
  \parbox{23em}{Build $G'$ with Algorithm \ref{alg:gbfintersection} on $(\{d_i\}, B, m, \lambda)$} \& \&  \\
  
  \parbox{23em}{Return recovered $\{d_i\}$ from $G'$} \& \& \\
};

\draw[<->] (m-2-2.south west) -- (m-2-2.south east);
\draw[->] (m-4-2.south west) -- (m-4-2.south east);
\draw[<->] (m-7-2.south west) -- (m-7-2.south east);
\end{tikzpicture}}
\caption{Oblivious Bloom Intersection} % on $(n, m, k, H, E, \lambda)$
\label{fig:obi}
\end{figure}

\begin{algorithm}[htb]
\caption{GBF $(S, S_d , n, m, k, H, \lambda)$}
\label{alg:gbf}
\begin{algorithmic}[1]
\REQUIRE A set $S$, a set of data $S_d$ with $|S|=|S_d|$, integers $n, m, k, \lambda$, set of hash functions $H=\{h_0, \dots, h_{k-1}\}$
\ENSURE An $(m, n, k, H, \lambda)$-garbled Bloom filter GBF$_S$ of \key
\STATE GBF$_S = [m]$ \COMMENT{create empty array of size $m$}
\FOR{$i=0$ \TO $|S|-1$}
  \STATE emptySlot $= -1$; share $=S_d[i]$
  \FOR{$j=0$ \TO $k-1$}
    \STATE $\alpha=h_i(S[i])$
    \IF{GBF$_S[\alpha] == \NULL$}
      \IF{emptySlot $== -1$}
        \STATE emptySlot $= \alpha$
        \ELSE
          \STATE GBF$_S[j] \gets_{\$} \{0,1\}^\lambda$
          \STATE share $= share \oplus$GBF$_S[\alpha]$
      \ENDIF
      \ELSE
        \STATE share $= share \oplus$GBF$_S[\alpha]$
    \ENDIF
  \ENDFOR
  \STATE GBF$_S[\text{emptySlot}]=\text{share}$
\ENDFOR
\FOR{$i=0$ \TO $m-1$}
  \IF{GBF$_S[i] == \NULL$}
    \STATE GBF$_S[i] \gets_{\$} \{0,1\}^\lambda$
  \ENDIF
\ENDFOR
\end{algorithmic}
\end{algorithm}

\subsection{Linear Secret Sharing}
Given set \cS and access structure $\Gamma_\cS$ over \cS, a \ac{MSP} is defined as a triple $(\mathbb{F},M,\rho)$ where $\mathbb{F}$ is a field, $M$ is a $l\times n$ share-generating matrix over $\mathbb{F}$ ($l$ and $n$ are constants depending on  $\cS$ and $\Gamma_\cS$) and $\rho:\{1,...l\}\rightarrow \cS$ labels each row of $M$ with an element in $\cS$. 
(\ac{LSSS} matrix $M$ can be generated from a boolean formula for example using \citet[Algorithm 1]{LiuC10}.)
Given a secret $\mathfrak{s}\in \mathbb{F}$, we can choose $r_2,\ldots,r_n \in \mathbb{F}$ at random and set a column vector $\mathbf{v}=(\mathfrak{s},r_2,\ldots,r_n)$. 
Then $M\mathbf{v}$ is a vector of $l$ shares of the secret. 
The $j$th share $(M\mathbf{v})_{j}$ is associated with an element $\rho(j) \in \cS$. 
For any set $C\in \Gamma_\cS$ that is an authorised set, we can define a set $I\subseteq \{1,\ldots,l\}$ as $I=\{i|\rho(i)\in C\}$. 
The vector $(1,0,\ldots,0)$ is in the span of rows of $M$ indexed by $I$, \ie there exists a set of constants $\{\omega_i\}_{i\in I}$ such that $\omega_iM_i=(1,0,\ldots,0)$. 
The set of shares associated with $C$ is $\{\mathfrak{s}_i\}_{i\in I}$ and the secret $\mathfrak{s}$ can be reconstructed from it by computing $\mathfrak{s}=\sum_{i\in I}\omega_i\mathfrak{s}_i$.

% \begin{algorithm}
% \caption{Converting Boolean Formula $F$ to LSSS Matrix $M$}
% \label{alg:lsssM}
% \begin{algorithmic}[1]
% \REQUIRE Formatted boolean formula $F$
% \ENSURE LSSS matrix $M$, representing $F$
% \STATE $(M[1,1], L[1], m, d) = (1, F, 1, 1)$; $z = 1$
% \WHILE{$z \not= 0$}
%   \STATE $z = 1$; $i = 1$
%   \WHILE{$i\leq m$ and $z = 0$}
%     \IF{$L[i]$ is a threshold-tree-string}
%       \STATE $z = i$
%     \ENDIF 
%     \STATE $i = i+1$
%   \ENDWHILE
%   \IF{$z \not= 0$}
%     \STATE $F_z = L[z]$
%     \STATE $m_2 =$ number of children of $F_z$; $d_2 =$ threshold value of $F_z$
%     \STATE $L_{2}[i] =$ $i$th child of $F_z$ for all children
%     \STATE $(M_1, L_1, m_1, d_1) = (M, L, m, d)$
%     \FOR{$i = 1$ \TO $z-1$}
%       \STATE $L[i] = L_{1}[i]$
%       \FOR{$j = 1$ \TO $d_1$}
%         \STATE $M[i,j] = M_{1}[i,j]$
%       \ENDFOR
%       \FOR{$j = d_1+1$ \TO $d_1+d_1-1$}
%         \STATE $M_[i,j] = 0$
%       \ENDFOR
%     \ENDFOR
%     \FOR{$i = z$ \TO $z + m_2 - 1$}
%       \STATE $L[i] = L_{2}[i-z+1]$
%       \FOR{$j = 1$ \TO $d_1$}
%         \STATE $M[i,j] = M_{1}[z,j]$
%       \ENDFOR
%       \STATE $a = i - (z-1)$; $x = i - (z-1)$
%       \FOR{$j = d_1 + 1$ \TO $d_1 + d_2 - 2$}
%         \STATE $M[i,j] = x$
%         \STATE $x = x \cdot a \mod p$
%       \ENDFOR
%     \ENDFOR
%     \FOR{$i = z + m_2$ \TO $m_1 + m_2 -1$}
%       \STATE $L[i] = L_{1}[i-m_2+1]$
%       \FOR{$j = 1$ \TO $d_1$}
%         \STATE $M[i,j] = M_{1}[i-m_2+1, j]$
%       \ENDFOR
%       \FOR{$j = d_1 + 1$ \TO $d_1 + d_2 - 1$}
%         \STATE $M[i,j] = 0$
%       \ENDFOR
%     \ENDFOR
%     \STATE $(m, d) = (m_1 + m_2 - 1, d_1 + d_2 - 1)$
%   \ENDIF
% \ENDWHILE
% \end{algorithmic}
% \end{algorithm}

%----------------------- SPHF---------------------------
\subsection{Smooth Projective Hashing}
Smooth projective hashing allows to compute a hash value of an element from a set in two different ways:
either by using a secret hashing key on the element, or utilising the public projection key and some secret information proving that the particular element is part of a specific subset under consideration.
In addition, smooth projective hash values guarantee to be uniformly distributed in their domain as long as the input element is not from a specific subset of the input set.
\aclp{SPHF} are due to \citet{Cramer2002} who used them to construct \ac{CCA}-secure public key encryption schemes and analyse mechanisms from \citet{Cramer1998}.
While \acp{SPHF} are useful in many areas of cryptography we focus on describing them in the context of \ac{PAKE}, which is where it will be used in this work.
For a general treatment we refer to \cite{Cramer2002,cryptoeprint:2013:034}.
The first use of \acp{SPHF} in the construction of a \ac{PAKE} protocol is due to Gennaro and Lindell \cite{Gennaro2003}, who introduced the additional requirement of pseudorandomness to \acp{SPHF} that was later extended by \citet{Katz2011}.
The \ac{SPHF}-based approach taken by \citet{Gennaro2003} was further helpful in the ``explanation'' of the KOY protocol from \citet{KatzOY01}, where those functions were implicitly applied.

First, we recall definitions for classical \ac{SPHF} tailored to the \ac{PAKE} use-case and cyclic groups \GG of prime-order $p$.
To this end we use languages of ciphertexts with the password as message and the randomness as witness.
An \ac{SPHF} language $L$ for a given password \pwd from dictionary \cD is given by \Lpwd, containing all possible ciphertexts encrypting \pwd. 
The public parts of the language are given by the \acl{CRS} \crs containing the public key \pk of the used encryption scheme.
By $\tau$ we denote the \crs trapdoor, the secret key to \pk.
Let \cL denote the encryption scheme used to generate words in \Lpwd.

\citet{Benhamouda2013} identify three different \ac{SPHF} classes:
word-independent key and adaptive smoothness (KV-SPHF, first proposed by \citet{Katz2011}),
word-independent key and non-adaptive smoothness (CS-SPHF, first proposed by \citet{Cramer2002}),
and word-dependent key (GL-SPHF, first proposed by \citet{Gennaro2003}).
In this work we focus on the strongest notion behind KV-SPHF: \emph{word-independent key} with \emph{adaptive smoothness}.
Unless stated otherwise all \acp{SPHF} in the following are KV-SPHFs where the projection key is independent of the ciphertext and \cL is a labelled CCA-secure encryption scheme.

\mynote{have to properly define \Lpwd and \cC, we want ciphertext $C$ being part of it, not the entire triple $(\Label, C, \pwd)$ ????}

\begin{definition}[Languages of Ciphertexts]\label{def:language}
Let $L_\pwd \subseteq \{(\Label, C, \pwd^\ast)\}=\cC$ denote the language of labelled ciphertexts under consideration with ciphertext $(\Label,C)$ under \pk and password $\pwd^\ast\in\cD$.
A ciphertext $C$ is in language \Lpwd iff there exists randomness $r$ such that $C\gets\Enc^{\cL}_\pk(\ell,\pwd;r)$.
\eod
\end{definition}

\noindent
Smooth projective hashing for languages of ciphertexts is then defined as follows.
Note that we describe only KV-SPHF where the projection key does not depend on the word (ciphertext).

\begin{definition}[KV-SPHF]\label{def:sphf}
Let \Lpwd denote a language of ciphertexts such that $C\in \Lpwd$ if there exists randomness $r$ proving so.
A \emph{\acl{SPHF}} for ciphertext language \Lpwd consists of the following four algorithms:

\begin{itemize}
	\item $\HKGen(\Lpwd)$ generates a random hashing key $\hk\in\ZZ_p^n$ for language \Lpwd.
	\item $\PKGen(\hk,\Lpwd)$ derives the projection key $\hp\in\GG^m$ from hashing key \hk. 
	\item $\Hash(\hk,\Lpwd,C)$ computes hash value $h$ from hashing key \hk and ciphertext $C$.
	\item $\PHash(\hp,\Lpwd,C,r)$ computes hash value $h$ from projection key \hp, ciphertext $C$ and randomness $r$. \eod
\end{itemize}
\end{definition}

\noindent
An \ac{SPHF} has to fulfil the following three properties:
\begin{itemize}
	\item \emph{Correctness}: If $C\in \Lpwd$, with $r$ proving so, then \[\Hash(\hk,\Lpwd,C)=\PHash(\hp,\Lpwd,C,r).\]
	\item \emph{Smoothness}: If $\{(\Label, C, \pwd^\ast)\}\ni \cC\not\in\Lpwd$, the hash value $h$ is (statistically) indistinguishable from a random element. 
	\item \emph{Pseudorandomness}: If $(\ell, C, \pwd^\ast)\in\Lpwd$, the hash value $h$ is (computationally) indistinguishable from a random element. 
\end{itemize}

\noindent
In a nutshell, smoothness ensures that the hash value always looks random in \GG when computed on an element not in the language, while pseudorandomness ensures that it looks random in \GG when computed on an element in the language.
Note again that we are only concerned with KV-SPHF that have word-independent keys and offer adaptive smoothness.
The corresponding notion of adaptive smoothness with word-independent keys is defined as follows.
For any function $f:\GG^m \mapsto \cC\setminus \Lpwd$ the following distributions are statistically $\varepsilon$-close:
\begin{align*}
& \{(\hp,h) ~|~ \hk\ralgout\HKGen(\Lpwd); \hp\algout\PKGen(\hk,\Lpwd); h\algout\Hash(\hk,\Lpwd,f(\hp))\} \\
\stackrel{\varepsilon}{=}~ & \{(\hp,h) ~|~ \hk\ralgout\HKGen(\Lpwd); \hp\algout\PKGen(\hk,\Lpwd); h\rin\GG\}
\end{align*}

\noindent
\citet{Gennaro2003} introduced pseudorandomness of \acp{SPHF} to show that \Hash and \PHash are the only way to compute the hash value even though the adversary knows some triples $(\hp,C,\Hash(\hk,\allowbreak\Lpwd,C))$ for $C\in\Lpwd$.
An \ac{SPHF} is pseudorandom if the hash values produced by \Hash and \PHash are indistinguishable from random without the knowledge of the uniformly chosen hash key \hk or a witness $w$, \ie for all $C\in\Lpwd$ the following distributions are computationally $\varepsilon$-close:
\begin{align*}
& \{(\hp,C,h) ~|~ \hk\ralgout\HKGen(\Lpwd); \hp\algout\PKGen(\hk,\Lpwd); h\algout\Hash(\hk,\Lpwd,C)\} \\
\stackrel{\varepsilon}{=}~ & \{(\hp,C,h) ~|~ \hk\ralgout\HKGen(\Lpwd); \hp\algout\PKGen(\hk,\Lpwd); h\rin\GG\}
\end{align*}

\noindent
The formalisation from \citet{Katz2011} defines pseudorandomness to hold even if hashing keys and ciphertexts are re-used, which is necessary in the \ac{PAKE} context.

\begin{definition}[Pseudorandomness]\label{def:prplusc}
An \ac{SPHF} $\Pi$ offers pseudorandomness if for all \ac{PPT} algorithms $\cA$ and polynomials $l$ there exists a negligible function $\varepsilon(\cdot)$ such that
\[\Adv_{\Pi,\cA}^{\Pr}=\left|\Pr[\Exp_{\Pi,\cA}^{\Pr}(\secpar)=1] - \frac12 \right|\leq \varepsilon(\secpar)\]

\noindent
$\Exp_{\Pi,\cA}^{\Pr}(\secpar):$ \\
\hspace*{2em} choose $b\rin\bits$\\
\hspace*{2em} $b'\algout\cA^{\Omega^{\cL}_\pk(\cdot),\Dec^\cL_\pi(\cdot)}(\secpar,\hp_1,\dots,\hp_l)$ \\
\hspace*{4em}~ with $\hp_i\algout\PKGen(\hk_i,\Lpwd,C)$ and $\hk_i\ralgout\HKGen(\Lpwd)$ for all $i\in 1,\dots,l$ \\
\hspace*{2em} return $b=b'$.

\begin{description}
	\item[$\Omega^{\cL}_\pk(\ell,\pwd)$] returns elements $C\in \Laux$ with $C\gets\Enc^\cL_\pk(\Label,\allowbreak\pwd;r)$ using encryption algorithm \cL and label \Label.
    	It additionally returns $\Hash(\hk_{i},\Lpwd,C)$ if $b=0$ or $h_{i}\rin\GG$ if $b=1$ for all $i\in 1,\dots, l$.
	
	\item[$\Dec^\cL_\pi(\Label,C)$] decrypts the ciphertext $C$ with label \Label if $(\Label,C)$ was not obtained from $\Omega^\cL_\pk$. \eod
\end{description}
\end{definition}

\paragraph{SPHF on Cramer-Shoup Ciphertexts}
Several \acp{SPHF} on labelled Cramer-Shoup ciphertexts have been proposed in literature.
Here the perfectly smooth \ac{SPHF} proposed by \citet{Benhamouda2013} is used.
The \ac{SPHF} is defined as follows, where $(g_1,g_2,h,c,d,\xi,r,e,u_1,u_2,v)$ are variables from the labelled \ac{CS} encryption:
\begin{itemize}
  \item $\HKGen(\Lpwd)$ return $\hk=(\eta_1,\eta_2,\theta,\mu,\nu)\rin\ZZ_p^{1\times 5}$
  \item $\PKGen(\hk, \Lpwd)$ returns $\hp=(\hp_1=g_1^{\eta_1} g_2^{\theta} h^\mu c^\nu, \hp_2=g_1^{\eta_2} d^{\nu})$
  \item $\Hash(\hk, \Lpwd, C)$ computes $H=u_1^{\eta_1+\xi\eta_2} u_2^{\theta} (e/g_1^{\pwd})^\mu v^\nu$
  \item $\PHash(\hp, \Lpwd, C, r)$ computes $H=(\hp_1 \hp_2^\xi)^r$
\end{itemize}

\subsubsection{Trapdoor Smooth Projective Hashing}\label{sec:tsphf}
To build efficient one-round UC-secure PAKE protocols \citet{Benhamouda2013} introduce the notion of \acp{T-SPHF}.
We recall the definition of \ac{T-SPHF} and additional security properties such as $(t,\varepsilon)$-soundness and computational smoothness necessary in this context.
\ac{T-SPHF} adds three additional functions to the classical \ac{SPHF} definition that allow computation of the hash value knowing only the projection key, ciphertext and a trapdoor $\tau'$.
Note that $\tau'$ is a different trapdoor than the \ac{CRS} trapdoor $\tau$.

\begin{definition}[Trapdoor SPHF]\label{def:tsphf}
Let \Lpwd denote a language of ciphertexts such that $C\in \Lpwd$ if there exists randomness $r$ proving so.
A \acl{T-SPHF} for ciphertext language \Lpwd consists of the following seven algorithms:

\begin{itemize}
  \item \HKGen, \PKGen, \Hash and \PHash are as given in Definition \ref{def:sphf}
	\item $\TSetup(\crs)$ generates a second $\crs'$ with trapdoor $\tau'$ on input of \crs
	\item $\VerHp(\hp, \Lpwd)$ returns $1$ iff \hp is a valid projection key, $0$ otherwise
	\item $\THash(\hp, \Lpwd, C, \tau')$ computes hash value $h$ of $C$ using  projection key \hp and trapdoor $\tau'$
\end{itemize}

\noindent
We assume $\crs'$ is, like \crs, made available to all parties.
\eod
\end{definition}

\paragraph{Correctness} Correctness of \acp{T-SPHF} extends correctness of \acp{SPHF} by the statement that for every valid ciphertext $C$, generated by \cL, and honestly generated keys \hk and \hp, it holds that $\VerHp(\hp, \Lpwd)=1$ and $\Hash(\hk, \Lpwd, C)=\THash(\hp, \Lpwd, C, \tau')$.

\paragraph{Soundness}
To capture soundness of \acp{T-SPHF} \citet{Benhamouda2013} introduce \emph{$(t,\varepsilon)$-soundness}, complementing the previous correctness extension.

\begin{definition}[$(t,\varepsilon)$-soundness]
Given \crs, $\crs'$ and $\tau$, no adversary running in time at most $t$ can produce a projection key \hp, a password \pwd, a word $C$, and valid witness $r$ such that \hp is valid, \ie $\VerHp(\hp,\Lpwd)=1$, but $\THash(\hp,\Lpwd,C,\tau')\not=\PHash(\hp,\Lpwd,C,r)$ with probability at least $\varepsilon(\secpar)$.
Perfect soundness states that the property holds for any $t$ and any $\varepsilon(\secpar)>0$.
\eod
\end{definition} 

\paragraph{Computational Smoothness}
As statistical smoothness is impossible for \ac{T-SPHF}, \citet{Benhamouda2013} introduce computational smoothness, which is similar to the definition of pseudorandomness for \acp{SPHF}.

\begin{definition}[Computational Smoothness]
An \ac{SPHF} is $(t,\varepsilon)$-smooth if for all adversaries $\cA$ running in time at most $t$
\[ \Adv_{\Pi, \cA}^{\smooth{b}} = \left|\Pr[\Exp^{\smooth{1}}_{\SPHF,\cA}(\secpar)=1] - \Pr[\Exp^{\smooth{0}}_{\SPHF,\cA}(\secpar)=1]\right| \leq \varepsilon(\secpar).\]

\noindent
$\Exp^{\smooth{b}}_{\SPHF,\cA}(\secpar):$ \\
\hspace*{2em} generate $(\crs',\tau')\ralgout\TSetup(\crs)$\\
\hspace*{2em} $b'\gets\cA^{\PKGen^1(\cdot), \Hash_b^1(\cdot)}(\secpar, \crs, \crs', \tau)$ \\
% The adversary, given $\crs, \crs'$ and $\tau$, is then allowed to query $\cO_{\PKGen}(\cdot)$ and $\cO_{\Hash_b}(\cdot)$ once before returning a bit $b'$.
\hspace*{2em} return $b=b'$\\

\noindent
On input \pwd the \PKGen oracle draws a new hash key \hk for \ac{T-SPHF} on \Lpwd, computes the according projection key \hp using \PKGen, and returns it to the adversary.
The \Hash oracle returns $h\gets \Hash$ honestly computed on input ciphertext $C$ if $b=0$ or $C\in\Lpwd$, and $h\rin \GG$ if $b=1$.
\eod
\end{definition}


\paragraph{\ac{T-SPHF} on Cramer-Shoup Ciphertexts}
\citet{Benhamouda2013} propose a \ac{T-SPHF} for labelled \ac{CS} ciphertexts under the \ac{SXDH} assumption.
The \ac{T-SPHF} is a straight-forward extension of the previously described \ac{SPHF} in labelled \ac{CS} ciphertexts.
Let $(q, \GG_1, \GG_2, \GG_T, e)$ denote a bilinear group and replace \GG from the previous \ac{SPHF} with $\GG_1$ and $g_1,g_2$ by $g_{1,1},g_{1,2}$, generators for $\GG_1$.
All other previous parameters are in $\GG_1$ instead of \GG and $g_2$ is generator of $\GG_2$.
The additional algorithms for \ac{T-SPHF} and changes to the hash functions are defined as follows.
\begin{itemize}
  \item $\TSetup(\crs)$ draws a random $\tau'\rin\ZZ_p$ and sets $\crs'=\zeta=g_2^{\tau'}$.
  \item $\PKGen(\hk, \Lpwd)$ generates 
      \[\hp=(\hp_1=g_1^{\eta_1} g_2^{\theta} h^\mu c^\nu, \hp_2=g_1^{\eta_2} d^{\nu}, \hp_3)\] with 
      $\hp_3=(\chi_{1,1}, \chi_{1,2}, \chi_2$, $\chi_3, \chi_4)$ for 
      $\chi_{1,1}={\zeta}^{\eta_1}, \chi_{1,2}={\zeta}^{\eta_2}, \chi_2={\zeta}^{\theta}, \chi_3={\zeta}^{\mu}, \chi_4={\zeta}^{\nu}$
  \item $\Hash(\hk, \Lpwd, C)$ computes 
      \[h'=u_1^{\eta_1+\xi\eta_2} u_2^{\theta} (e/g_1^{\pwd})^\mu v^\nu\] 
      as before and outputs $h=e(h',g_2)$
  \item $\PHash(\hp, \Lpwd, C, r)$ computes $h'=(\hp_1 \hp_2^\xi)^r$ as before and outputs $h=e(h',g_2)$
  \item $\VerHp(\hp, \Lpwd)$ verifies that 
      \[e(\hp_1, \crs')\stackrel{?}{=} e(g_{1,1}, \chi_{1,1})\cdot e(g_{1,2}, \chi_2)\cdot e(h_1, \chi_3)\cdot e(c, \chi_4)\] and
      \[e(\hp_2, \crs') \stackrel{?}{=} e(g_{1,1}, \chi_{1,2})\cdot e(d, \chi_4)\]
  \item $\THash(\hp, \Lpwd, C, \tau')$ computes 
  \[\left[ e(u_1, \chi_{1,1} \chi_{1,2}^{\xi})\cdot e(u_2, \chi_2)\cdot e(e/g_{1,1}^{\pwd}, \chi_3)\cdot e(v, \chi_4) \right]^{1/\tau'}\]
\end{itemize}
