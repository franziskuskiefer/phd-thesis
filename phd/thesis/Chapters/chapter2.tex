%*******************************************************************************
%****************************** Preliminaries *********************************
%*******************************************************************************

\chapter{Prerequisites and Building Blocks}\label{ch:prelims}

In this chapter we recall known facts and assumptions as well as notations used throughout this thesis.
We start with some general mathematical fundamentals before giving generally useful definition in our setting.
While these definitions are all well known and do not need reference, most of them can be found (in maybe slightly different version) in \citet{katz2008introduction} or \citet{Goldreich2001}.

%********************************** %Math  **************************************
\section{Mathematical Background}
This is not a complete mathematical introduction but recalls the most important definitions needed in our context.
One very central definition when modelling computational security is the notion of computational indistinguishability.

\begin{definition}[Computational Indistinguishability]
Polynomial-time indistinguishability between two ensembles $X=\{X_n\}_{n\in\NN}$ and $Y=\{Y_n\}_{n\in\NN}$ is given if for every \ac{PPT} algorithm $D$, there exists a negligible function $\varepsilon(\cdot)$ such that
\[
  \left| \Pr[D(X) = 1] - \Pr[D(Y) = 1] \right| < \varepsilon(n).
\]
We use computational or polynomial-time indistinguishable interchangeably and write $X\stackrel{\varepsilon}{=}Y$.
\eod
\end{definition}

\subsection{Groups}
Groups are an important mathematical structure in cryptography.
In the following we give some useful definitions in the context of cyclic and composite order groups.

\begin{definition}[Groups]\label{def:groups}
Let \GG denote a set and $\circ$ a binary operation on two elements from \GG.
\GG is a group if it has \emph{closure}, a \emph{neutral} element, every element has an \emph{inverse} element, and it is \emph{associative}, \ie :
\begin{itemize}
	\item For all $g,h\in\GG$, $g\circ h \in\GG$
	\item There exists an element $e\in\GG$, called \emph{identity}, such that for all $g\in\GG$, $e\circ g=g=g\circ e$.
	\item For all $g\in\GG$ there exists an \emph{inverse} element $h\in\GG$ such that $g\circ h=e=h\circ g$.
	\item For all $g,h,k\in\GG$, $(g\circ h)\circ k=g\circ (h \circ k)$.
\end{itemize}
\eod
\end{definition}

\noindent
The \emph{order} of a finite group \GG is denoted by $|\GG|$ and is defined as the number of elements in \GG.
An \emph{abelian} group additionally is commutative, \ie for all $g,h\in\GG$, $g\circ h=h\circ g$.
In this work, and cryptography in general, we mainly use cyclic groups.

\subsubsection{Cyclic Groups}
Since many computational assumptions on groups used in cryptography rely on the cyclic property of groups we have to ensure that all groups used in this context are cyclic.

\begin{definition}[Cyclic Groups]\label{def:cyclicgroups}
Let \GG denote a finite group of order $p$.
\GG is \emph{cyclic} if there exists a \emph{generator} $g\in\GG$ such that $\{g^0,g^1,\dots,g^{p-1}\}=\GG$.
\eod
\end{definition}

\noindent
Therefore, we usually use groups of prime order $p$ since groups of prime order are cyclic.
Another useful feature of prime order groups is that all elements of group \GG, except the identity, are generators of \GG.
We write $\GG=\genG$ to denote a group \GG is generate by $g$.
Working in subgroups of $\ZZ_p$ it is further useful to know that $\ZZ^\ast_p=\{x\in{1,\dots,p-1}~|~\gcd(x,p)=1\}$ is a cyclic group as well.
In the case of cyclic groups where $p$ is prime all elements in $\ZZ^\ast_p$ are relatively prime to $p$ (and thus invertible modulo $p$) such that $\phi(p)=p-1$, where $\phi(p)=|\ZZ^\ast_p|$ denotes the cardinality of $\ZZ^\ast_p$.

\subsubsection{Composite Order Groups}
Composite order groups $\ZZ^\ast_N$ for integer $N=pq$ that is a product of two distinct primes $p$ and $q$ are another useful group for cryptography.
Note that $\ZZ^\ast_N=\{x\in{1,\dots,N-1}~|~\gcd(x,N)=1\}$ is always an abelian group under multiplication modulo integer $N>1$.
The cardinality of $\ZZ^\ast_N$ is given by $\phi(p)=(p-1)(q-1)$.

\subsection{Elliptic Curves}
This work is only marginally concerned with elliptic curve cryptography.
We therefore keep this section short and refer to \citet{HankersonMS03} for further introduction into elliptic curves in cryptography and more general definitions.

An \emph{elliptic curve} $E$ over prime-field $\ZZ_p$ is given by 
\[
  y^2 = x^3 + ax + b \mod p,
\]
with $a,b\in\ZZ_p$, $p>5$, and $4a^3 + 27b^2 \not= 0 \mod p$.
Points on curve $E$ are given by pairs $(x,y)\in\ZZ^2_p$ that fulfil those equations.
The set containing all these points, plus the point at infinity $\infty$, are denoted $E(\ZZ_p)$.
$E(\ZZ_p)$ with $\infty$ as identity and common arithmetic operations such as addition, subtraction, multiplication, and inversion forms an abelian group.
Note that we use the multiplicative notation for elliptic curves (even though it is an additive group).

\subsection{Pairings}
Let $\GG_1=\genG[1], \GG_2=\genG[2]$, and $\GG_T=\genG[T]$ denote cyclic groups of prime-order $p$.
A pairing is defined by an efficient bilinear map $e: \GG_1 \times \GG_2 \mapsto \GG_T$ with $e(g_1^x, g_2^y) = g_T^{xy}$ for $x,y\in\ZZ_p$.
In cryptography we usually distinguish between three different types of pairings \cite{GalbraithPS08}:

\begin{itemize}
  \item Type I: $\GG_1 = \GG_2$;
  \item Type II: $\GG_1 \not= \GG_2$ and there exists an efficiently computable homomorphism $\phi: \GG_2 \mapsto \GG_1$ (bot not for $\GG_1 \mapsto \GG_2$);
  \item Type III: $\GG_1 \not= \GG_2$, without any efficiently computable homomorphism between $\GG_1$ and $\GG_2$.
\end{itemize}

\subsection{Computational Assumptions}
In this section we recall computational assumptions used in the remainder of this thesis.
We distinguish between assumptions on cyclic groups and assumptions on composite order groups.
When saying something is hard with respect to the security parameter \secpar, this means that there exists no algorithm that can solve the problem in polynomial time in \secpar.

Asymptotic notation allows us to describe the behaviour of a function when its arguments converging towards some limit.
As mentioned earlier, security models used in this work are from the computational world.
In particular, running time and success or advantage probabilities of algorithms, \ie adversaries, are modelled as functions on security parameter \secpar.
Security is therefore only given for \emph{reasonable} security parameters.
To express this asymptotic notation is used.

\begin{definition}[Negligible Functions]\label{def:negligible}
A function $f$ is \emph{negligible} if for every polynomial $p(\cdot)$ there exists an $N\in\NN$ such that for all $n\in\NN$ with $n>N$ it holds that $f(n)<1/p(n)$.
\eod
\end{definition}

% \begin{definition}[Asymptotic Notation]\label{def:asymptotic}
% Let $f(n)$ and $g(n)$ denote functions from $\NN_0$ to $\RR_{\geq 0}$.
% \begin{itemize}
% 	\item $f(n)=\cO(g(n)):$ There exist $c,N\in\NN_0$ such that for all $n>N$ it holds that $f(n)\leq c\cdot g(n)$.
% 	\item $f(n)=\Omega(g(n)):$ There exist $c,N\in\NN_0$ such that for all $n>N$ it holds that $f(n)\geq c\cdot g(n)$.
% 	\item $f(n)=\Theta(g(n)):$ Both $f(n)=\cO(g(n))$ and $f(n)=\Omega(g(n))$ hold.
% 	\item $f(n)=o(g(n)):$ $\lim_{m\rightarrow\infty}\frac{f(n)}{g(n)}=0$
% 	\item $f(n)=\omega(g(n)):$ $\lim_{m\rightarrow\infty}\frac{f(n)}{g(n)}=\infty$ 
% 	\eod
% \end{itemize}
% \end{definition}

\paragraph{Probabilistic Polynomial-Time}
We often use the phrase \ac{PPT} to describe an efficient algorithm.
The actual definition of \ac{PPT}, first defined by \citet{gill1977}, is given for \ac{PP}, how \ac{PPT} is usually called in complexity theory, as follows:

\begin{definition}[\acl{PP}]\label{def:ppt}
\ac{PP} denotes the class of decision problems solvable by a \ac{PTM} \cA such that
\begin{itemize}
	\item \cA runs in polynomial-time,
	\item at least $1/2$ of the computation paths accept when the answer is `yes', and
	\item less than $1/2$ of the computation paths accept when the answer is `no'. \eod
\end{itemize}
\end{definition}

\noindent
The informal description for \aclp{PTM} is given in Definition \ref{def:ptm}.
We refer the interested reader to works concerned with complexity theory, \eg \cite{santos1969,WaterlooComplexity} for more on \ac{PTM} and a formal definition.

\begin{definition}[\acl{PTM} \cite{gill1977}]\label{def:ptm}
A \ac{PTM} is a Turing machine with distinguished states called coin-tossing states.
For each coin-tossing state, the finite control unit specifies two possible next states.
The computation of a \ac{PTM} is deterministic except that in coin-tossing states the machine tosses an unbiased coin to decide between the two possible next states.
\end{definition}

\noindent
Note that the running time is always parametrised with security parameter \secpar.
One may think of \ac{PPT} as a notion for ``feasible strategies'' or ``efficient algorithms'' running in time polynomial in \secpar.
In other words, this means that for some constants $a$ and $c$ the algorithm runs in time $a\cdot \secpar^c$ with security parameter \secpar.

\subsubsection{Cyclic Groups}
In this section we recall some computational assumptions in the group context that are believed to be hard.
The \ac{DLP} is the basis of all assumptions in those groups.

\begin{definition}[\acl{DLP}]\label{def:dlp}
Let \GG denote a group of prime order $p$ with generator $g$.
The \ac{DLP} in \GG states that given a random element $h\rin\GG$ it is hard to compute $x$ such that $h=g^x$, i.e. 

\[
  \Pr[\DLog_{\cA,\GG}(\secpar)=1] \leq \varepsilon(\secpar)
\]

\noindent
$\Exp_{\cA,\GG}^{\DLog}(\secpar):$\\
\hspace*{2em} obtain cyclic group $\GG$ of prime order $p$ with length $\secpar$ and generator $g$\\
\hspace*{2em} choose $h\rin\GG$\\
\hspace*{2em} $x \gets \cA(\GG, p, g, h)$\\
\hspace*{2em} output $1$ iff $g^x=h$, otherwise $0$\\
\eod
\end{definition}

\noindent
Several \ac{DLP}-based assumptions have been proposed.
The two most important ones are the \ac{DDH} and \ac{CDH} assumptions.

\begin{definition}[\acl{DDH}]\label{def:ddh}
Let \GG denote a group of order $p$ of length $\secpar$ with generator $g$.
The \ac{DDH} assumption in \GG states that given $(g,g^a,g^b,g^c)\in\GG^4$ it is hard relative to $\secpar$ to determine whether $c=ab$ for random scalars $a,b,c\rin\ZZ_p$, i.e. 

\[
  \left| \Pr[\cA(\GG, p, g, g^a, g^b, g^c)=1] - \Pr[\cA(\GG, p, g, g^a, g^b, g^{ab})=1] \right| \leq \varepsilon(\secpar).
\]
% for $a,b,c\rin\ZZ_p$.
\eod
\end{definition}

\begin{definition}[\acl{CDH}]\label{def:cdh}
Let \GG denote a group of order $p$ of length $\secpar$ with generator $g$.
The \ac{CDH} assumption in \GG states that given $(g,g^a,g^b)\in\GG^3$ it is hard relative to $\secpar$ to compute $g^{ab}$ for random scalars $a,b\rin\ZZ_p$.
\eod
\end{definition}

\noindent
When using \ac{DLP}-based assumptions in pairing groups we have to be more careful as the \ac{DDH} assumption might not hold and additional treatment of the pairing setting is necessary.

\begin{definition}[\acl{SXDH} \cite{BallardGMM05,AtenieseCHM05}]\label{def:sxdh}
Let $\GG_1=\genG[1]$, $\GG_2=\genG[2]$, and $\GG_T=\genG[T]$ denote groups of prime-order $p$ of length $\secpar$ with associated bilinear map $e$.
The \ac{SXDH} assumption states that the DDH assumption in $\GG_1$ and $\GG_2$ is hard relative to $\secpar$, i.e. given $(w_1,x_1,y_1,z_1)\in\GG^4_1$ and $(w_2,x_2,y_2,z_2)\in\GG^4_2$ it is hard to decide whether there exists values $a_1,a_2$ such that $x_1=w_1^{a_1}$, $z_1=y_1^{a_1}$, $x_2=w_2^{a_2}$, and $z_2=y_2^{a_2}$.
\eod
\end{definition}

\subsubsection{Composite Order Groups}
The basic problem underlying all hardness assumptions in composite order groups is the factoring problem.

\begin{definition}[Factoring Problem]\label{def:factoring}
Let $N=pq$ denote an integer with prime factors $p$ and $q$ of length \secpar each.
The factoring problem in $\ZZ^\ast_N$ states that given modulus $N$ it is hard relative to \secpar to compute $p',q'$ such that $N=p'q'$.
\eod
\end{definition}

\noindent
To define RSA-based assumptions we have to define the RSA key generation algorithm first.
Let $(N, e, d)\ralgout\KGen(\secpar)$ denote the RSA key-generation algorithm that generates $(N, e, d)$ such that $N=pq$ for two distinct primes $p$ and $q$ of size $\secpar$ each, $\gcd(e, \phi(N))=1$, and $ed=1\mod \phi(N)$.

\begin{definition}[RSA Assumption]\label{def:rsa}
Let $N=pq$ denote an integer with prime factors $p$ and $q$ of length \secpar each and $y\rin\ZZ^\ast_N$ a random element from $\ZZ^\ast_N$.
The RSA problem over $\ZZ^\ast_N$ states that given $(N,e,d,y)$ defined as above it is hard with respect to \secpar to compute $x$ such that $x^e = y \mod N$.
\eod
\end{definition}

\noindent
Informally, the one-more RSA assumption indicates that the RSA problem is hard relative to $\secpar$ even if the adversary is given access to an RSA oracle.

\begin{definition}[One-more RSA]\label{def:onemoreRSA}
Let $(N, e, d)\ralgout\KGen(\lambda)$ denote the RSA key-generation algorithm, and $r_j\rin\ZZ^\ast_N$ be uniformly random integers in $\ZZ^\ast_N$ for $j\in[1,t+1]$.
We say the one-more RSA problem is $(\lambda, t)$-hard if for every PPT adversary \cA we have
\[ \Pr[\{x_i\}_{i\in[1,t+1]} \gets \cA^{(\cdot)^d \bmod N}(N, e, \lambda, r_1, \dots, r_{t+1})] \leq \varepsilon(\secpar), \]
where $x_i^e=r_i\mod N$, \cA made at most $t$ queries to the RSA oracle $(\cdot)^{^d \mod N}$ and $\varepsilon(\cdot)$ is a negligible function.
\eod
\end{definition}


% In addition to common notations (we do not recall here), we give here all notations used throughout this work.
% \mynote{see if anything of this is useful ...}
% \begin{itemize}
% 	\item If $A$ is an algorithm, then $x\algout A(y)$ denotes running $A$ with input $y$ and storing the result in $x$.
% 	\item If $A$ is a randomised algorithm, then $x\ralgout A(y;r)$ denotes running $A$ with input $y$ and randomness $r$, and storing the result in $x$.
% 	\item If $U$ is a set, then $x\rin U$ denotes that $x$ is chosen uniformly at random form $U$.
% 	\item A variable $y$ is assigned to $x$ by $x:=y$.
% 	\item The boolean operations \emph{and} and \emph{or} are denoted by $\wedge$ and $\vee$.
% 	\item Exclusive or (xor) is denoted by $\oplus$.
% 	\item Set of binary strings of length $n$ $\bits^n$.
% 	\item The length of a binary string $x$ is denoted by $|x|$, the bit-length of an integer $y$ is denoted by $\|y\|$.
% 	\item $\bigo,\Theta,\Omega,\omega$
% 	\item Since $\log_2$ is the most used logarithm we denote it by $\log$.
% 	\item The security parameter is denoted $\secpar$.
% 	\item Oracle access to $O(\cdot)$ for algorithm $A$ is denoted by $A^{O(\cdot)}$.
% 	\item Public/private key-pairs are denoted by $(\pk,\sk)$
% 	\item Negligible functions are denoted by $\varepsilon(\cdot)$.
% 	\item \aclp{PRF} are denoted by \PRF.
% 	\item \ZZ, \NN, \RR, $\NN_0$, $\NN_{\geq 0}$
% \end{itemize}


%********************************** %Building Blocks  **************************************
\section{Building Blocks}
This section describes building blocks used throughout this work to build the proposed protocols.
But before starting with that we want to give a short description of some general models used to specify security in.
% the random oracle, which is an important though disputed, and standard model.
The two most popular models are the \ac{ROM} and the standard model.
In the \ac{ROM} a public randomly chosen black-box function $H$ is available to all parties, whereas no such function exists in the \emph{standard model}.
While this function $H$ can not be instantiated in the real world it is useful (sometimes necessary) in many proofs.
Implementations of protocols requiring a random oracle usually instantiate it with a cryptographic hash function.
The function $H$ is queried on an input $x$ and returns the ``hash value'' of $x$.
It is consistent, such that $y=H(x)$ for all $y\gets H(x)$, and the output $y$ of $H$ is uniformly at random such that one can think of $H$ as drawing a random element $y$ each time it is queried on a new $x$.
If $H$ has seen $x$ before, it returns the previously chosen element $y$.
While not including random oracles, the standard model often includes a \ac{CRS} that is made available to all parties and can be seen as common set-up parameters.

\subsection{Common Reference String}
The \acl{CRS} model, proposed by \citet{CanettiF01}, is a generalisation of the common random string model.
In the \ac{CRS} model all parties have access to a common reference string that was chosen according to some predefined distribution.
This model is usually referred to as the standard model with \ac{CRS} as the assumption of the additional \ac{CRS} being available is rather weak.

\subsection{Hash Functions}

\mynote{* Collision resistant\\ * any other?}

\subsection{Commitments} \label{sec:commitments}
Let $\Commitment=(\SetupC,\Com)$ denote a commitment scheme and $C\gets\Com(x;r)$ a commitment on $x$ using randomness $r$, with \SetupC generating parameters for \Commitment.
A commitment scheme $\Commitment=(\SetupC,\Com)$ is \emph{efficient} if $\SetupC(\secpar)$ and $(C,d)\gets\Com(x;r)$ are computable in polynomial time ($d$ denotes the decommitment to $C$ and is usually omitted), \emph{complete} if $\Com(d)=(C,d)$ for $(C,d)\gets\Com(x;r)$, and secure if it is
\begin{itemize}
  \item Binding: For all PPT adversaries \cA there exists a negligible function $\varepsilon_{\mathrm{bi}}(\cdot)$ such that for all $(x,x',r,r',C)\gets \cA(\secpar)$:
    $\Pr[x\not=x'\wedge (C,d)=\Com(x;r)\wedge (C,d')=\Com(x';r')] \leq \varepsilon_{\mathrm{bi}}(\secpar)$,
  \item Hiding: For all PPT adversaries $\cA$ there exists a negligible function $\varepsilon_{\mathrm{hi}}(\cdot)$ such that for all $x_0,x_1$ with $|x_0|=|x_1|$, $b\rin\bits, (C,d)\gets\Com(x_b;r)$, and $b'\gets \cA(C,x_1,x_2)$:
    $\Pr[b=b'] \leq 1/2+\varepsilon_{\mathrm{hi}}(\secpar)$.
\end{itemize}

\noindent
A commitment scheme is further homomorph if there exist functions $\circ$ and $\star$ such that for all commitments $(C_i,d_i)\gets\Com(x_i;r_i)$  for $i\in[1,n]$ that $C_1 \circ \cdots \circ C_n = \Com(x_1\star \cdots \star x_n, r_i\star \cdots \star r_n)$.

\subsubsection{Pedersen commitments}
\citet{Pedersen91} commitments are perfectly hiding, computationally binding, homomorphic commitments, defined as follows.
Let $\Pedersen=(\SetupC$, $\Com)$ with $(g,h,p,\secpar)\gets\SetupC(\secpar)$ and $C\gets\Com=(x;r)=g^x h^r$ denote the Pedersen commitment scheme where $g$ and $h$ are generators of a cyclic group \GG of prime order $p$ with bit-length in the security parameter $\secpar$ and the discrete logarithm of $h$ with respect to base $g$ is not known.
Pedersen commitments are \emph{additively homomorph}, i.e. for all $(C_i,d_i) \gets \Com(x_i;r_i)$ for $i\in 1,\dots,n$ it holds that $\prod_{i=1}^{n}C_i=\Com(\sum_{i=1}^{n}x_i$; $\sum_{i=1}^{n}r_i)$.

\paragraph{Trapdoor commitments}
In some scenarios such as zero-knowledge proofs of knowledge with malicious verifiers we require trapdoor commitments, which allow a party knowing the correct trapdoor to open a commitment to any value (equivocable commitment).
Pedersen commitments are trapdoor commitments as they can be opened to any element using the discrete logarithm $\log_g h$ as trapdoor.

%----------------------------------- Zero Knowledge Proofs-----------------------
\subsection{Zero Knowledge Proofs}
A zero-knowledge proof is executed between a prover and a verifier, proving that a word $x$ is in a language $L$, using a witness $w$ proving so.
An interactive protocol $\Pi$ for a language $L$ between prover $P$ and verifier $V$ is a zero knowledge proof if the following holds:
\begin{itemize}
	\item Completeness: If $x\in L$, $V$ accepts if $P$ holds a witness proving so.
	\item Soundness: For every malicious prover $P^\ast(x)$ with $x\not\in L$ the probability of making $V$ accept is negligible.
	\item Zero-Knowledge: If $x\in L$, then there exists an efficient simulator \Sim that on input of $x$ is able to generate a view, indistinguishable from the view of a (malicious) verifier $V^\ast$.
\end{itemize}

\paragraph{Zero-Knowledge Proof of Knowledge}
A zero-knowledge proof of knowledge \ZKPoK is a zero-knowledge proof with the following special soundness definition:
\begin{itemize}
	\item Soundness: There exists an efficient knowledge extractor \Ext that can extract a witness from interaction with any (malicious) prover $P^\ast(x)$ with $x\in L$ that makes the verifier accept.
\end{itemize}

\paragraph{$\bm{\Sigma}$ Protocols}\hfill\\
\mynote{briefly describe standard $\Sigma$ protocols}

\subsubsection{Committed Zero-knowledge Proofs}
\citet{Damgard00} and \citet{JareckiL00} proposed the following committed $\Sigma$-protocol to ensure extractability (\ZKPoK) and simulatability when interacting with a malicious verifier and preserve zero-knowledge under parallel execution.
Let $P_1(x,w,r)$ and $P_2(x,w,r,c)$ denote the two prover steps of a $\Sigma$-protocol and $H:\bits^\ast\mapsto\ZZ_p$ a collision-resistant hash function.
A committed $\Sigma$-protocol based on Pedersen commitments is then given by the following four steps:
\begin{itemize}
  \item The prover computes the first message $m_1\gets P_1(x,w,r)$, computes 
  \[M_1\gets\Com(H(x,m_1); r_1)=g^{H(x,m_1)}h^{r_1},\]
  and sends $M_1$ to the verifier.
  \item The verifier chooses challenge $c\rin\bits^\secpar$ and returns it to the prover.
  \item The prover computes the second message $m_2\gets P_2(x,w,r,c)$, computes 
  \[M_2\gets\Com(H(m_2); r_2)=g^{H(m_2)}h^{r_2},\]
   and sends $M_2$ to the verifier.
  \item Further, the prover opens the commitments $M_1$ and $M_2$ by sending $(x,m_1,m_2,r_1,r_2)$ to the verifier.
  \item The verifier accepts iff both commitments are valid and if the verification of the $\Sigma$-protocol $(x,m_1,c,m_2)$ is successful.
\end{itemize}

% \noindent
% Despite being zero-knowledge in the malicious verifier setting, this type of protocol has the advantage of concurrent zero-knowledge (since no rewinding is necessary \cite{Damgard00,JareckiL00}).


%----------------------- PK Encryption schemes---------------------------
\subsection{Public Key Encryption}

Public key encryption allows party $A$ holding a \emph{public key \pk} of some party $B$ to encrypt a message $m$ in ciphertext $c$ such that only the party holding the according \emph{secret key \sk} ($B$ usually) to decrypt the ciphertext $c$ to $m$.
It is formally defined as follows.

\begin{definition}[Public Key Encryption]\label{def:pkencryption}
A public key encryption scheme $\PKE=(\PKEGen$, $\Enc$, $\Dec)$ consists of the following three algorithms:
\begin{itemize}
  \item $\PKEGen(\secpar)$ generates a secret/public key-pair $(\sk,\pk)$ on input of the security parameter \secpar
  \item $\Enc_\pk(m; r)$ encrypts message $m$ with public key \pk and randomness $r$, and outputs ciphertext $c$
  \item $\Dec_\sk(c)$ decrypts ciphertext $c$ with secret key \sk and outputs message $m$
\end{itemize}
\end{definition}


\subsubsection{Public Key Encryption secure against Chosen-Plaintext Attacks}
\acp{CPA} define security for \ac{PKE} schemes where the attacker is allowed to query an encryption oracle.

\begin{definition}[IND-CPA Security]\label{def:indcpa}
A \ac{PKE} scheme $\Pi=(\PKEGen,\Enc,\Dec)$ is \emph{IND-CPA} secure if for all \ac{PPT} adversaries $\cA$ there exists a negligible function $\varepsilon(\cdot)$ such that:
\[\Adv_{\Pi,\cA}^{\cpa}(\secpar)=\left|\Pr[\Exp^{\cpa}_{\Pi,\cA}(\secpar)=1]-\frac12\right|\leq\varepsilon(\secpar)\]

\noindent
$\Exp^{\cpa}_{\Pi,\cA}(\secpar):$\\
\hspace*{2em}$(\pk,\sk)\ralgout\KGen(\secpar),~b\rin\bits$\\
\hspace*{2em}$(m_0,m_1)\gets\cA^{\Enc_\pk(\cdot)}(\secpar,\pk)$\\
\hspace*{2em}$c\gets\Enc_\pk(m_b)$\\
\hspace*{2em}$b'\gets\cA^{\Enc_\pk(\cdot)}(\secpar,\pk,m_0,m_1,c)$\\
\eod
\end{definition}


\paragraph{ElGamal Encryption}\label{sec:elgamalencryption}
\citet{Gamal84} encryption operates on a multiplicative group \GG of prime order $p$ with generator $g$.
Key generation $\PKEGen(\secpar)$ outputs a public key $\pk=h=g^z$ for random $\sk=z\rin\ZZ_p$ and $x$ as secret key.
Let $C=(u,e)\algout\Enc^{\EG}_\pk(m;r)$ with $u=g^r$ and $e=h^rg^m$ denote an El-Gamal ciphertext.
Note that we assume $m\in\GG$, which can be achieved by $m=g^{m'}$ for a message $m'\in\ZZ_p$.
Decryption is given by $m=\Dec_\sk^\EG(C)=e/u^z$.


\subsubsection{Public Key Encryption secure against Chosen-Ciphertext Attacks}
\acp{CCA} define security for \ac{PKE} schemes where the attacker is allowed to query encryption \emph{and} decryption oracles.
It is therefore a stronger security notion than \ac{CPA}.
Note that we always refer to adaptive \ac{CCA}-security, i.e. \ac{CCA}2, when talking about \ac{CCA}-security.

\begin{definition}[IND-CCA Security]\label{def:indcca2}
A \ac{PKE} scheme $\Pi=(\PKEGen,\Enc,\Dec)$ is \emph{IND-CCA2} secure if for all \ac{PPT} adversaries $\cA$ there exists a negligible function $\varepsilon(\cdot)$ such that:
\[\Adv_{\Pi,\cA}^{\cca}(\secpar)=\left|\Pr[\Exp^{\cca}_{\Pi,\cA}(\secpar)=1]-\frac12\right|\leq\varepsilon(\secpar)\]

\noindent
$\Exp^{\cca}_{\Pi,\cA}(\secpar):$\\
\hspace*{2em}$(\pk,\sk)\ralgout\PKEGen(\secpar),~b\rin\bits$\\
\hspace*{2em}$(m_0,m_1)\gets\cA^{\Enc_\pk(\cdot),\Dec_\sk(\cdot)}(\secpar,\pk)$\\
\hspace*{2em}$c\gets\Enc_\pk(m_b)$\\
\hspace*{2em}$b'\gets\cA^{\Enc_\pk(\cdot),\Dec_\sk(\cdot)}(\secpar,\pk,m_0,m_1,c)$\\
\hspace*{2em}return $b=b'$ if \cA did not query $\Dec_\sk(c)$; $0$ otherwise
\eod
\end{definition}

\paragraph{Labelled Public Key Encryption}
Labelled \ac{PKE} \cite{Shoup01,Canetti2005} is a variant of \ac{PKE} that takes a public \emph{label $\ell$} as additional input to the encryption ($\Enc_\pk(m,\ell; r)$) and decryption algorithm ($\Dec_\sk(c,\ell)$).
The attacker in the \ac{CCA}-security experiment is now also allowed to query the decryption oracle on $c$ as long as the label $\ell'$ handed to the oracle is different from $\ell\not=\ell'$.


\paragraph{Cramer-Shoup Encryption}\label{sec:csencryption}

We describe labelled \ac{CS} encryption here.
Common \ac{CS} encryption simply omits the label $\ell$.
\ac{CS} encryption operations on multiplicative group $\GG$ of prime order $p$ with generators $g_1$ and $g_2$.
Key generation $\PKEGen(\secpar)$ returns public key $\pk=(c,d,H_k)$ with $c=g_{1}^{x_1}g_{2}^{x_2}, d=g_{1}^{y_1}g_{2}^{y_2}, h=g_{1}^z$ and hash function $H_k$ such that $\sk=(x_1,x_2,y_1,y_2,z)$ denotes the decryption key.
Note that we assume $m\in\GG$, which can be achieved by $m=g^{m'}$ for a message $m'\in\ZZ_p$.
Let $C=(\ell,\bm{u},e,v)\algout\Enc^{\CS}_\pk(\ell,m;r)$ (on label $\ell$, message $m$, and randomness $r$) with $\bm{u}=(u_1,u_2)=(g_{1}^r,g_{2}^r),~ e=h^rg_1^m$ and $v=(cd^{\xi})^r$ with $\xi=H_k(\ell,\bm{u},e)$ denote a labelled Cramer-Shoup ciphertext.
Decryption is defined as $g_1^m=\Dec_\sk^\CS(C)=e/u_1^z$ if $u_1^{x_1+y_1\cdot \xi'}u_2^{x_2+y_2\cdot \xi'}=v$ with $\xi'=H_k(\ell,\bm{u},e)$.

%----------------------- OBI ---------------------------
\subsection{Oblivious Bloom Intersection}\label{sec:obi}
The Oblivious Bloom Intersection (OBI) protocol by \citet{DongCW13} is executed between a client and a server on the respective sets \cC and \cS. 
Originally, the OBI protocol was designed for Private Set Intersection (PSI) such that at the end of the protocol, the client learns the intersection $\cC\cap \cS$ and the server learns nothing. 
As observed by \citet{WenD14}, OBI can be extended to a Private Set Intersection with Data Transfer protocol. In this case, the server can associate each element $s_i\in\cS$ with a data item $d_i$. 
At the end of the protocol, for each element in the intersection the client also receives the corresponding data item from the server. 
The protocol can be described at a high level as follows: let the server hold a set $\cS=\{s_i\}$ and a data set $\cS_d=\{d_{i}\}$. The two sets are of equal cardinality and each $(s_i,d_i)$ can be viewed as a key-value pair. The server generates a garbled Bloom filter $G_\cS$ on \cS and $\cS_d$ using \citet[Algorithm 1]{WenD14}. 
The garbled Bloom filter encodes both $\cS$ and $\cS_d$ in a way such that querying the key $s_i\in\cS$ against $G_\cS$ returns the data item $d_i$ and querying $s_j\not \in \cS$ returns a random string. Let the client hold a set $\cC$. The client encodes the set into a conventional Bloom filter~\cite{blo70} $B_\cC$. 
The client and the server run an oblivious transfer protocol using the Bloom filter and the garbled Bloom filter as inputs. 
As the result, the client receives a garbled Bloom filter $G_{\cC\cap\cS}$ that encodes the intersection $\cC\cap \cS$ and the data items associated with the elements in $\cC\cap \cS$. Then the client can query $G_{\cC\cap\cS}$ with each element $c_i\in\cC$. If $c_i$ is in the intersection then there must be  some $s_j\in \cS$ such that $c_i=s_j$ and the query result is $d_j$, the data item associated with $s_j$, otherwise the client gets a random string. 

In this paper we use OBI so that the server can send a set of secret shares to the client based on the client's set $\cC$ without knowing anything about $\cC$. Although in general we can use any PSI with Data Transfer protocol (e.g. \citet{fre04}), we choose OBI here because of its efficiency. OBI is very efficient due to the fact that it relies mostly on hash operations. 
The performance can be further improved by the modifications proposed by \citet{Pinkas0Z14}. 
Note that although \citet{Pinkas0Z14} also proposed a new PSI protocol based on hashtable + oblivious transfer in \cite{Pinkas0Z14} that is more efficient than OBI, the new PSI protocol cannot be used in our case because it does not support data transfer.

\begin{algorithm}[htb]
\caption{GBFIntesection $(G, B, m, \lambda)$}
\label{alg:gbfintersection}
\begin{algorithmic}[1]
\REQUIRE Garbled bloom filter $G$, Bloom filter $B$, integer $m, \lambda$
\ENSURE An $(m, n, k, H, \lambda)$-garbled Bloom filter GBF$_X$
\STATE GBF$_X = [m]$ \COMMENT{create empty array of size $m$}
\FOR{$i=0$ \TO $m-1$}
  \IF{$B[i] == 1$}
    \STATE GBF$_X[i] = G[i]$
  \ELSE
    \STATE GBF$_X[i] \ralgout \{0,1\}^\lambda$
  \ENDIF
\ENDFOR
\end{algorithmic}
\end{algorithm}

\begin{figure}[htb]
\centering
\scalebox{0.58}{
\begin{tikzpicture}[framed] %[scale=0.7, every node/.style={scale=0.7}, ]
\matrix (m)[matrix of nodes, column  sep=.1cm,row  sep=1mm, ampersand replacement=\&,
		nodes={draw=none, anchor=center,text depth=1pt},
		column 1/.style={nodes={minimum width=23em, align=left}}, %,text width=15em
		column 2/.style={nodes={minimum width=14em}},
		column 3/.style={nodes={minimum width=18em, align=right, text width=18em}}]{
	\node[align=center](client){$C~ (B_\cC)$}; \draw[]($(client.south west)+(.5,0)$)--($(client.south east)-(.5,0)$); \& \& \node[align=center](server){$S$ $(G_\cS)$}; \draw[]($(server.south west)+(.5,0)$)--($(server.south east)-(.5,0)$);\\ [1mm]
	
	\parbox{23em}{} \& %generate Bloom filter $B$ for $\cC$, generate GBF $G$ with Algorithm \ref{alg:gbf}
	  neg. params $(n, m, k, H, E)$ \& \\
	  
	\parbox{23em}{} \& \&  \\ %	  on $(\cS, S_d, n, m, k, H, \lambda)$
	
	\parbox{23em}{generates  $r_i\ralgout\{0,1\}^\lambda$ for $i\in[0,m-1]$} \&
	   $\{r_i\}_{i\in[0,m-1]}$ \&
	   $\sk$ $\ralgout$ $\KGen_E(\lambda)$\\ 
	   
	\& \& $\forall i$ $\in$ $[0,m-1]$ $: c_i$ $\gets$ $\Enc_\sk(r_i||G[i])$ \\
	
	\& \& share \sk into $(t_0, \dots, t_{m-1})$ using XOR\\
	
  \parbox{23em}{$\forall i\in[0,m-1]:$ if $B[i]=1$ get $c_i;$ else $t_i$} \& 
  $B \rightarrow$ {\bf OT} $\leftarrow \{(c_i, t_i)\}_{i\in[0,m-1]}$ \& \\
  
  \parbox{23em}{Recover \sk from recovered $t_i$ XOR} \& \& \\
  
  \parbox{23em}{$\forall $ recovered $c_i: d_i\gets\Dec_\sk(c_i)$} \& \&  \\
  
  \parbox{23em}{$\forall $ recovered $d_i: d_i[0,\lambda-1] \stackrel{?}{=} r_i$; else return with $\bot$} \& \&  \\
  
  \parbox{23em}{Build $G'$ with Algorithm \ref{alg:gbfintersection} on $(\{d_i\}, B, m, \lambda)$} \& \&  \\
  
  \parbox{23em}{Return recovered $\{d_i\}$ from $G'$} \& \& \\
};

\draw[<->] (m-2-2.south west) -- (m-2-2.south east);
\draw[->] (m-4-2.south west) -- (m-4-2.south east);
\draw[<->] (m-7-2.south west) -- (m-7-2.south east);
\end{tikzpicture}}
\caption{Oblivious Bloom Intersection} % on $(n, m, k, H, E, \lambda)$
\label{fig:obi}
\end{figure}

\begin{algorithm}[htb]
\caption{GBF $(S, S_d , n, m, k, H, \lambda)$}
\label{alg:gbf}
\begin{algorithmic}[1]
\REQUIRE A set $S$, a set of data $S_d$ with $|S|=|S_d|$, integers $n, m, k, \lambda$, set of hash functions $H=\{h_0, \dots, h_{k-1}\}$
\ENSURE An $(m, n, k, H, \lambda)$-garbled Bloom filter GBF$_S$ of \key
\STATE GBF$_S = [m]$ \COMMENT{create empty array of size $m$}
\FOR{$i=0$ \TO $|S|-1$}
  \STATE emptySlot $= -1$; share $=S_d[i]$
  \FOR{$j=0$ \TO $k-1$}
    \STATE $\alpha=h_i(S[i])$
    \IF{GBF$_S[\alpha] == \NULL$}
      \IF{emptySlot $== -1$}
        \STATE emptySlot $= \alpha$
        \ELSE
          \STATE GBF$_S[j] \gets_{\$} \{0,1\}^\lambda$
          \STATE share $= share \oplus$GBF$_S[\alpha]$
      \ENDIF
      \ELSE
        \STATE share $= share \oplus$GBF$_S[\alpha]$
    \ENDIF
  \ENDFOR
  \STATE GBF$_S[\text{emptySlot}]=\text{share}$
\ENDFOR
\FOR{$i=0$ \TO $m-1$}
  \IF{GBF$_S[i] == \NULL$}
    \STATE GBF$_S[i] \gets_{\$} \{0,1\}^\lambda$
  \ENDIF
\ENDFOR
\end{algorithmic}
\end{algorithm}

%----------------------- SPHF---------------------------
\subsection{Smooth Projective Hashing}
Smooth projective hashing allows to compute the hash value of an element from a set in two different ways:
either by using a secret hashing key on the element, or utilising the public projection key and some secret information proving that the particular element is part of a specific subset under consideration.
In addition, smooth projective hash values guarantee to be uniformly distributed in their domain as long as the input element is not from a specific subset of the input set.
\aclp{SPHF} are due to \citet{Cramer2002} who used them to construct \ac{CCA}-secure public key encryption schemes and analyse mechanisms from \cite{Cramer1998}.
While \acp{SPHF} are useful in many areas of cryptography we focus on describing them here in the context of \ac{PAKE}, which is where it will be used in this work.
For a general treatment we refer to \cite{Cramer2002,cryptoeprint:2013:034}.
The first use of \acp{SPHF} in the construction of a \ac{PAKE} protocol is due to Gennaro and Lindell \cite{Gennaro2003}, who introduced additional requirements to \ac{SPHF} such as pseudorandomness that was later extended by \citet{Katz2011}.
The \ac{SPHF}-based approach taken by \citet{Gennaro2003} was further helpful in the ``explanation'' of the KOY protocol from \citet{KatzOY01}, where those functions were implicitly applied.

First, we recall definitions for classical \ac{SPHF} tailored to the \ac{PAKE} use-case and cyclic groups \GG of prime-order $p$.
We use languages of ciphertexts with the password as message and the randomness as witness.
An \ac{SPHF} language $L$ for a given password \pwd from dictionary \cD is given by \Lpwd. 
The public parts of the language are given by the \acl{CRS} \crs containing the public key \pk of the used encryption scheme.
By $\tau$ we denote the \crs trapdoor, the secret key to \pk.
We denote \cL the encryption scheme used to generate words in \Lpwd.

The authors of \cite{Benhamouda2013} identify three different SPHF classes:
word-independent key and adaptive smoothness (KV-SPHF, first proposed by \citet{Katz2011}),
word-independent key and non-adaptive smoothness (CS-SPHF, first proposed by \citet{Cramer2002}),
and word-dependent key (GL-SPHF, first proposed by \citet{Gennaro2003}).
In this work we focus on the strongest notion behind KV-SPHF: \emph{word-independent key} with \emph{adaptive smoothness}.
Unless stated otherwise all \acp{SPHF} in the following are KV-SPHFs where the projection key is independent of the ciphertext and \cL is a labelled CCA-secure encryption scheme.

\mynote{have to properly define \Lpwd and \cC, we want ciphertext $C$ being part of it, not the entire triple $(\Label, C, \pwd)$!}

\begin{definition}[Languages of Ciphertexts]\label{def:language}
Let $L_\pwd \subseteq \{(\Label, C, \pwd^\ast)\}=\cC$ denote the language of labelled ciphertexts under consideration with ciphertext $(\Label,C)$ under \pk and password $\pwd^\ast\in\cD$.
A ciphertext $C$ is in language \Lpwd iff there exists randomness $r$ such that $C\gets\Enc^{\cL}_\pk(\ell,\pwd;r)$.
\end{definition}

\noindent
Smooth projective hashing for languages of ciphertexts is then defined as follows.
Note that we describe only KV-SPHF where the projection key does not depend on the word (ciphertext).

\begin{definition}[KV-SPHF]\label{def:sphf}
Let \Lpwd denote a language of ciphertexts such that $C\in \Lpwd$ if there exists randomness $r$ proving so.
A \emph{\acl{SPHF}} for ciphertext language \Lpwd consists of the following four algorithms:

\begin{itemize}
	\item $\HKGen(\Lpwd)$ generates a random hashing key $\hk\in\ZZ_p^n$ for language \Lpwd.
	\item $\PKGen(\hk,\Lpwd)$ derives the projection key $\hp\in\GG^m$ from hashing key \hk. 
	\item $\Hash(\hk,\Lpwd,C)$ computes hash value $h$ from hashing key \hk and ciphertext $C$.
	\item $\PHash(\hp,\Lpwd,C,r)$ computes hash value $h$ from projection key \hp, ciphertext $C$ and randomness $r$. 
\end{itemize}
\end{definition}

\noindent
An \ac{SPHF} has to fulfil the following three properties:
\begin{itemize}
	\item \emph{Correctness}: If $C\in L$, with $r$ proving so, then $\Hash(\hk,\Lpwd,C)=\PHash(\hp,\Lpwd,C,r)$.
	\item \emph{Smoothness}: If $\{(\Label, C, \pwd^\ast)\}\ni \cC\not\in\Lpwd$, the hash value $h$ is (statistically) indistinguishable from a random element. 
	\item \emph{Pseudorandomness}: If $(\ell, C, \pwd^\ast)\in\Lpwd$, the hash value $h$ is (computationally) indistinguishable from a random element. 
\end{itemize}

\noindent
In a nutshell, smoothness ensures that the hash value always looks random in \GG when computed on an element not in the language, while pseudorandomness ensures that it looks random in \GG when computed on an element in the language.
Note again that we are only concerned with KV-SPHF that have word-independent keys and offer adaptive smoothness.
The corresponding notion of adaptive smoothness with word-independent keys is defined as follows.
For any function $f:\GG^m \mapsto \cC\setminus \Lpwd$ the following distributions are statistically $\varepsilon$-close:
\begin{align*}
& \{(\hp,h) ~|~ \hk\ralgout\HKGen(\Lpwd); \hp\algout\PKGen(\hk,\Lpwd); h\algout\Hash(\hk,\Lpwd,f(\hp))\} \\
\stackrel{\varepsilon}{=}~ & \{(\hp,h) ~|~ \hk\ralgout\HKGen(\Lpwd); \hp\algout\PKGen(\hk,\Lpwd); h\rin\GG\}
\end{align*}

\noindent
\citet{Gennaro2003} introduced pseudorandomness of \acp{SPHF} to show that \Hash and \PHash are the only way to compute the hash value even though the adversary knows some tuples $(\hp,C,\Hash(\hk,\allowbreak\Lpwd,C))$ for $C\in\Lpwd$.
An \ac{SPHF} is pseudorandom if the hash values produced by \Hash and \PHash are indistinguishable from random without the knowledge of the uniformly chosen hash key \hk or a witness $w$, i.e. for all $C\in\Lpwd$ the following distributions are computationally $\varepsilon$-close:
\begin{align*}
& \{(\hp,C,h) ~|~ \hk\ralgout\HKGen(\Lpwd); \hp\algout\PKGen(\hk,\Lpwd); h\algout\Hash(\hk,\Lpwd,C)\} \\
\stackrel{\varepsilon}{=}~ & \{(\hp,C,h) ~|~ \hk\ralgout\HKGen(\Lpwd); \hp\algout\PKGen(\hk,\Lpwd); h\rin\GG\}
\end{align*}

\noindent
The formalisation from \citet{Katz2011} defines pseudorandomness to hold even if hashing keys and ciphertexts are re-used.

\begin{definition}[Pseudorandomness]\label{def:prplusc}
An \ac{SPHF} $\Pi$ offers pseudorandomness if for all PPT algorithms $\cA$ and polynomials $l$ there exists a negligible function $\varepsilon(\cdot)$ such that
\[\Adv_{\Pi,\cA}^{\Pr}=\left|\Pr[\Exp_{\Pi,\cA}^{\Pr}(\secpar)=1] - \frac12 \right|\leq \varepsilon(\secpar)\]

\noindent
$\Exp_{\Pi,\cA}^{\Pr}(\secpar):$ \\
\hspace*{2em} choose $b\rin\bits$\\
\hspace*{2em} $b'\gets\cA^{\Omega^{\cL}_\pk(\cdot),\Dec^\cL_\pi(\cdot)}(\secpar,\hp_1,\dots,\hp_l)$ \\
\hspace*{4em}~ with $\hp_i\gets\PKGen(\hk_i,\Lpwd,C)$ and $\hk_i\gets\HKGen(\Lpwd)$ for all $i\in 1,\dots,l$ \\
\hspace*{2em} return $b=b'$.

\begin{description}
	\item[$\Omega^{\cL}_\pk(\ell,\pwd)$] returns elements $C\in \Laux$ with $C\gets\Enc^\cL_\pk(\Label,\allowbreak\pwd;r)$ using encryption algorithm \cL and label \Label.
    	It additionally returns $\Hash(\hk_{i},\Lpwd,C)$ if $b=0$ or $h_{i}\rin\GG$ if $b=1$ for all $i\in 1,\dots, l$.
	
	\item[$\Dec^\cL_\pi(\Label,C)$] decrypts the ciphertext $C$ with label \Label if $(\Label,C)$ was not obtained from $\Omega^\cL_\pk$.
\end{description}
\end{definition}

\paragraph{SPHF on Cramer-Shoup Ciphertexts}
Several \acp{SPHF} on labelled Cramer-Shoup ciphertexts exist.
This work is based on the the perfectly smooth \ac{SPHF} proposed by \citet{Benhamouda2013}.
The \ac{SPHF} is defined as follows:
\begin{itemize}
  \item $\HKGen(\Lpwd)$ return $\hk=(\eta_1,\eta_2,\theta,\mu,\nu)\rin\ZZ_q^{1\times 5}$
  \item $\PKGen(\hk, \Lpwd)$ returns $\hp=(\hp_1=g_1^{\eta_1} g_2^{\theta} h^\mu c^\nu, \hp_2=g_1^{\eta_2} d^{\nu})$
  \item $\Hash(\hk, \Lpwd, C)$ computes $h=u_1^{\eta_1+\xi\eta_2} u_2^{\theta} (e/g_1^{\pwd})^\mu v^\nu$
  \item $\PHash(\hp, \Lpwd, C, r)$ computes $h=(\hp_1 \hp_2^\xi)^r$
\end{itemize}

\subsubsection{Trapdoor Smooth Projective Hashing}\label{sec:tsphf}
To build efficient one-round UC-secure PAKE protocols \citet{Benhamouda2013} introduce the notion of \acp{T-SPHF}.
We recall the definition of \ac{T-SPHF} and additional security properties such as $(t,\varepsilon)$-soundness and computational smoothness.
\ac{T-SPHF} adds three additional functions to the classical \ac{SPHF} definition that allow computation of the hash value knowing only the projection key, ciphertext and a trapdoor $\tau'$.
Note that $\tau'$ is a different trapdoor than the \ac{CRS} trapdoor $\tau$.

\begin{definition}[Trapdoor SPHF]\label{def:tsphf}
Let \Lpwd denote a language of ciphertexts such that $C\in \Lpwd$ if there exists randomness $r$ proving so.
A \acl{T-SPHF} for ciphertext language \Lpwd consists of the following seven algorithms:

\begin{itemize}
  \item \HKGen, \PKGen, \Hash and \PHash are as given in Definition \ref{def:sphf}
	\item $\TSetup(\crs)$ generates a second $\crs'$ with trapdoor $\tau'$ on input of a \crs
	\item $\VerHp(\hp, \Lpwd)$ returns $1$ iff \hp is a valid projection key, $0$ otherwise
	\item $\THash(\hp, \Lpwd, C, \tau')$ computes the hash value $h$ of $C$ using the projection key \hp and trapdoor $\tau'$
\end{itemize}

\noindent
We assume $\crs'$ is, like \crs, made available to all parties.
\end{definition}

\paragraph{Correctness} Correctness of \acp{T-SPHF} extends correctness of \acp{SPHF} by the statement that for every valid ciphertext $C$, generated by \cL, and honestly generated keys \hk and \hp, it holds that $\VerHp(\hp, \Lpwd)=1$ and $\Hash(\hk, \Lpwd, C)=\THash(\hp, \Lpwd, C, \tau')$.

\paragraph{Soundness}
To capture soundness of \acp{T-SPHF} \citet{Benhamouda2013} introduce \emph{$(t,\varepsilon)$-soundness}, complementing the previous correctness extension.

\begin{definition}[$(t,\varepsilon)$-soundness]
Given \crs, $\crs'$ and $\tau$, no adversary running in time at most $t$ can produce a projection key \hp, a password \pwd, a word $C$, and valid witness $r$ such that \hp is valid, i.e. $\VerHp(\hp,\Lpwd)=1$, but $\THash(\hp,\Lpwd,C,\tau')\not=\PHash(\hp,\Lpwd,C,r)$ with probability at least $\varepsilon(\secpar)$.
Perfect soundness states that the property holds for any $t$ and any $\varepsilon(\secpar)>0$.
\end{definition} 

\paragraph{Computational Smoothness}
As statistical smoothness is impossible for \ac{T-SPHF}, \citet{Benhamouda2013} introduce the notion computational smoothness, which is similar to the definition of pseudorandomness for \acp{SPHF}.

\begin{definition}[Computational Smoothness]
An \ac{SPHF} is $(t,\varepsilon)$-smooth if for all adversaries $\cA$ running in time at most $t$
\[ \Adv_{\Pi, \cA}^{\smooth{b}} = \left|\Pr[\Exp^{\smooth{1}}_{\SPHF,\cA}(\secpar)=1] - \Pr[\Exp^{\smooth{0}}_{\SPHF,\cA}(\secpar)=1]\right| \leq \varepsilon(\secpar).\]

\noindent
$\Exp^{\smooth{b}}_{\SPHF,\cA}(\secpar):$ \\
\hspace*{2em} generate $(\crs',\tau')\ralgout\TSetup(\crs)$\\
\hspace*{2em} $b'\gets\cA^{\PKGen^1(\cdot), \Hash_b^1(\cdot)}(\secpar, \crs, \crs', \tau)$ \\
% The adversary, given $\crs, \crs'$ and $\tau$, is then allowed to query $\cO_{\PKGen}(\cdot)$ and $\cO_{\Hash_b}(\cdot)$ once before returning a bit $b'$.
\hspace*{2em} return $b=b'$\\

\noindent
On input \pwd the \PKGen oracle draws a new hash key \hk for \ac{T-SPHF} on \Lpwd, computes the according projection key \hp using \PKGen, and returns it to the adversary.
The \Hash oracle returns $h\gets \Hash$ honestly computed on input ciphertext $C$ if $b=0$ or $C\in\Lpwd$, and $h\rin \GG$ if $b=1$.\\
\end{definition}


\paragraph{\ac{T-SPHF} on Cramer-Shoup Ciphertexts}
\citet{Benhamouda2013} propose a \ac{T-SPHF} for labelled \ac{CS} ciphertexts under the \ac{SXDH} assumption.
The \ac{T-SPHF} is a straight-forward extension of the previously described \ac{SPHF} in labelled \ac{CS} ciphertexts.
Let $(q, \GG_1, \GG_2, \GG_T, e)$ denote a bilinear group and replace \GG from the previous \ac{SPHF} with $\GG_1$ and $g_1,g_2$ by $g_{1,1},g_{1,2}$, generators for $\GG_1$.
All other previous parameters are in $\GG_1$ instead of \GG and $g_2$ is generator of $\GG_2$.
The additional algorithms for \ac{T-SPHF} and changes to the hash functions are defined as follows.
\begin{itemize}
  \item $\TSetup(\crs)$ draws a random $\tau'\rin\ZZ_q$ and sets $\crs'=\zeta=g_2^{\tau'}$.
  \item $\PKGen(\hk, \Lpwd)$ generates 
      \[\hp=(\hp_1=g_1^{\eta_1} g_2^{\theta} h^\mu c^\nu, \hp_2=g_1^{\eta_2} d^{\nu}, \hp_3)\] with 
      $\hp_3=(\chi_{1,1}, \chi_{1,2}, \chi_2$, $\chi_3, \chi_4)$ for 
      $\chi_{1,1}={\zeta}^{\eta_1}, \chi_{1,2}={\zeta}^{\eta_2}, \chi_2={\zeta}^{\theta}, \chi_3={\zeta}^{\mu}, \chi_4={\zeta}^{\nu}$
  \item $\Hash(\hk, \Lpwd, C)$ computes 
      \[h'=u_1^{\eta_1+\xi\eta_2} u_2^{\theta} (e/g_1^{\pwd})^\mu v^\nu\] 
      as before and outputs $h=e(h',g_2)$
  \item $\PHash(\hp, \Lpwd, C, r)$ computes $h'=(\hp_1 \hp_2^\xi)^r$ as before and outputs $h=e(h',g_2)$
  \item $\VerHp(\hp, \Lpwd)$ verifies that 
      \[e(\hp_1, \crs')\stackrel{?}{=} e(g_{1,1}, \chi_{1,1})\cdot e(g_{1,2}, \chi_2)\cdot e(h_1, \chi_3)\cdot e(c, \chi_4)\] and
      \[e(\hp_2, \crs') \stackrel{?}{=} e(g_{1,1}, \chi_{1,2})\cdot e(d, \chi_4)\]
  \item $\THash(\hp, \Lpwd, C, \tau')$ computes $\left[ e(u_1, \chi_{1,1} \chi_{1,2}^{\xi})\cdot e(u_2, \chi_2)\cdot e(e/g_{1,1}^{\pwd}, \chi_3)\cdot e(v, \chi_4) \right]^{1/\tau'}$
\end{itemize}


\section{Security Models}
\mynote{* PAKE\\ * VPAKE\\ * 2PAKE}



\subsection{Simulation in the Malicious Model}\label{app:simulation}
We recall the basic setting of the malicious model from \cite{Goldreich2004}.
Let $f:\bits^\ast \times \bits^\ast \rightarrow \bits^\ast \times \bits^\ast$ be a functionality such that $f(x,y)=(f_1(x, y), f_2(x,y))$ and $\Pi$ a two-party protocol to compute $f$.
% $\Lambda$ denotes the empty string and
In the ideal model every party gets an input and access to a trusted party.
Honest participants send their input to the trusted party while malicious parties, with additional input $z$ and random tape $r$, either aborts or sends some value with the length of their non-additional input to the trusted party.
The trusted party answers to the first party with $f_1(x, y)$ after obtaining inputs $(x,y)$.
If only one input is received, the trusted party replies with $\bot$ to both parties.
The trusted party further answers the second party with $f_2(x,y)$ if it didn't stop before, $\bot$ otherwise.
It may stop depending on its input and output if the first party is malicious.
While an honest party always outputs the value received from the trusted party, malicious parties can output any polynomially computable function of all its inputs.
The ideal and real model are formalised as follows.

\begin{definition}[Ideal Model \texorpdfstring{\cite[Definition 7.2.4]{Goldreich2004}}{}]
Let $B=(B_1, B_2)$ be a pair of PPT algorithms representing strategies in the ideal model.
Such a pair is \emph{admissible} in the ideal malicious model if for at least one \emph{honest} $i\in\{1,2\}$, we have $B_i(u, z, r)=u$ and $B_i(u, z, r, v)=v$ for all possible $u,z,r$ and $v$.
Furthermore, $|B_i(u, z, r)| = |u|$ must hold for both $i$'s.
The joint execution of $f$ under $B$ in the ideal model on input pair $(x, y)$ and auxiliary input $z$, denoted $\IDEAL_{f, B(z)} (x, y)$, is defined by uniformly selecting a random tape $r$ for the adversary and letting 
\[ \IDEAL_{f, B(z)} (x, y) := \Xi(x,y,z,r),\]
with $\Xi(x,y,z,r)$ defined as follows.
If party 1 is honest:
\[ \Xi(x,y,z,r) := (f_1(x,B_2(y,z,r)), B_2(y,z,r,f_2(x,y'))); \]
If party 2 is honest:
\[
 \Xi(x,y,z,r) := \left\{
 \begin{array}{lllr}
    (B_1(x, z, r, f_1(x',y), \bot)&, \bot&) &\text{if } B_1(x, z, r, f_1(x',y)) = \bot ;\\
    (B_1(x,z,r,f_1(x',y))&, f_2(x',y)&) &\text{otherwise,}
  \end{array}\right.
\]
% $(B_1(x, z, r, v), B_2(y, z, r, \Lambda))$
with $x'=B_2(x,z,r)$.
\end{definition}

\begin{definition}[Real Model \texorpdfstring{\cite[Definition 7.2.5]{Goldreich2004}}{}]
Let $A=(A_1, A_2)$ be a pair of PPT algorithms representing strategies in the real model.
Such a pair is \emph{admissible} with respect to $\Pi$ if at least one $A_i$ coincides with the strategy specified in $\Pi$.
The joint execution of $\Pi$ under $A$ in the real model, on input pair $(x, y)$ and auxiliary input $z$, denoted $\REAL_{\Pi, A(z)}(x, y)$, is defined as the output pair resulting from the interaction between $A_1(x, z)$ and $A_2(y, z)$.
\end{definition}

\noindent
A protocol $\Pi$ is said to be secure if its execution in the real model emulates execution of the ideal model with trusted party for the according functionality.

\begin{definition}[Security \texorpdfstring{\cite[Definition 7.2.6]{Goldreich2004}}{}]
Protocol $\Pi$ is said to securely compute $f$ in the malicious model if for every PPT pair of algorithms $A=(A_1, A_2)$ that is admissible for the real model, there exists a PPT pair of algorithms $B=(B_1, B_2)$ that is admissible for the ideal model such that 
\[ \{\IDEAL_{f, B(z)}(x, y)\}_{x, y, z} \stackrel{c}{\equiv} \{\REAL_{\Pi, A(z)}(x, y)\}_{x, y, z} \]
where $x,y,z\in\bits^\ast$ such that $|x|=|y|$ and $|z|=\poly(|x|)$.
\end{definition}

\paragraph{The Hybrid Model}
When proving security of a protocol that is combined of other primitives and protocols we view those protocols as black boxes and prove security in the \HYBRID model instead of the \REAL model.
Security then follows from the composition theorem from \citet{Canetti00}.
In the $g$-\HYBRID world protocol $f$ is executed between two parties like in the \REAL world, but every invocation of sub-protocol $g$ is replaced with the according ideal functionality, i.e. a call to the trusted party that computes $g$.
The output of the $g$-\HYBRID world for functionality $f$ and protocol $\Pi$ is denoted by $\HYBRID_{\Pi, A(z)}^{g} (x, y)$.
Let $\Pi^\Gamma$ denote the real world protocol $\Pi$ that uses $\Gamma$ as a sub-protocol, i.e. instead of querying the trusted party to compute $g$, the real protocol $\Gamma$ is executed.
To prove security it is sufficient to show 
$\{\IDEAL_{f, B(z)}(x, y)\}_{x, y, z} \stackrel{c}{\equiv} \{\HYBRID_{\Pi, A(z)}^{g} (x, y)\}_{x, y, z}$,
which implies
$\{\IDEAL_{f, B(z)}(x, y)\}_{x, y, z} \stackrel{c}{\equiv} \{\REAL_{\Pi^{\Gamma}, A(z)} (x, y)\}_{x, y, z}$
as shown by \citet{Canetti00}.
