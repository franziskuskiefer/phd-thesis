%*******************************************************************************
%****************************** Preliminaries *********************************
%*******************************************************************************

\chapter{Prerequisites and Building Blocks}

In this chapter we recall known facts and assumptions as well as notations used throughout this work.
We start with some general mathematical fundamentals before giving generally useful definition in our setting.
While these definitions are all well known and do not need reference, most of them can be found (in maybe slightly different version) in \cite{katz2008introduction}.


%********************************** %Math  **************************************
\section{Mathematical Background}
We will not give an entire mathematical introduction but recall the most important definitions needed in our context.

\subsection{Groups}
Groups are an important mathematical structure in cryptography.
In the following we give some useful definitions in the context of cyclic and composite order groups.

\begin{definition}[Groups]\label{def:groups}
Let \GG denote a set and $\circ$ a binary operation on two elements from \GG.
\GG is a group if it has \emph{closure}, a \emph{neutral} element, every element has an \emph{inverse} element and it is \emph{associative}:
\begin{itemize}
	\item For all $g,h\in\GG$, $g\circ h \in\GG$
	\item There exists an element $e\in\GG$, called \emph{identity}, such that for all $g\in\GG$, $e\circ g=g=g\circ e$.
	\item For all $g\in\GG$ there exists an \emph{inverse} element $h\in\GG$ such that $g\circ h=e=h\circ g$.
	\item For all $g,h,k\in\GG$, $(g\circ h)\circ k=g\circ (h \circ k)$.
\end{itemize}
\eod
\end{definition}

\noindent
The \emph{order} of a finite group \GG is denoted by $|\GG|$ and is defined as the number of elements in \GG.
An \emph{abelian} group additionally is commutative, \ie for all $g,h\in\GG$, $g\circ h=h\circ g$.
In this work, and cryptography in general, we mainly use cyclic groups.

\begin{definition}[Cyclic Groups]\label{def:cyclicgroups}
Let \GG denote a finite group of order $p$.
\GG is \emph{cyclic} if there exists a \emph{generator} $g\in\GG$ such that $\{g^0,g^1,\dots,g^{p-1}\}=\GG$.
\eod
\end{definition}

\noindent
Let $\phi(p)=|\ZZ^\ast_p|$ denote the cardinality of $\ZZ^\ast_p$.

\subsubsection{Cyclic Groups}
Since many computational assumptions on groups used in cryptography rely on the cyclic property of groups we have to ensure that all groups used in this context are cyclic.
Therefore, we usually use groups of prime order $p$ since groups of prime order are cyclic.
Another useful feature of prime order groups is that all elements of group \GG, except the identity, are generators of \GG.
We write $\GG=\genG$ to denote a group \GG is generate by $g$.
Working in subgroups of $\ZZ_p$ it is further useful to know that $\ZZ^\ast_p=\{x\in{1,\dots,p-1}~|~\gcd(x,p)=1\}$ is a cyclic group as well.
In the case of cyclic groups where $p$ is prime all elements in $\ZZ^\ast_p$ are relatively prime to $p$ (and thus invertible modulo $p$) such that $\phi(p)=p-1$.

\subsubsection{Composite Order Groups}
Composite order groups $\ZZ^\ast_N$ for integer $N=pq$ that is a product of two distinct primes $p$ and $q$ are another useful group for cryptography.
Note that $\ZZ^\ast_N=\{x\in{1,\dots,N-1}~|~\gcd(x,N)=1\}$ is always an abelian group under multiplication modulo integer $N>1$.
The cardinality of $\ZZ^\ast_N$ is given by $\phi(p)=(p-1)(q-1)$.


\subsection{Elliptic Curves}
This work is only marginally concerned with elliptic curve cryptography.
We therefore keep this section short and refer to \cite{HankersonMS03} for further introduction into elliptic curves in cryptography.

An \emph{elliptic curve} $E$ over prime-field $\FF_p$ is given by 
\[
  y^2 = x^3 + ax + b \mod p,
\]
with $a,b\in\FF_p$ and $4a^3 + 27b^2 \not= 0 \mod p$.
Points on curve $E$ are given by pairs $(x,y)\in\FF^2_p$ that fulfil those equations.
The set containing all these points, plus the point at infinity $\infty$, are denoted $E(\FF_p)$.
$E(\FF_p)$ with $\infty$ as identity and common arithmetic operations such as addition, subtraction, multiplication, and inversion forms an abelian group.
Note that we use the multiplicative notation for elliptic curves (even though it is an additive group).

\subsection{Pairings}
Let $\GG_1=\genG[1], \GG_2=\genG[2]$, and $\GG_T=\genG[T]$ denote cyclic groups of prime-order $p$.
A pairing is defined by an efficient bilinear map $e: \GG_1 \times \GG_2 \mapsto \GG_T$ with $e(g_1^x, g_2^y) = g_T^{xy}$ for $x,y\in\ZZ_p$.
In cryptography we usually distinguish between three different types of pairings \cite{GalbraithPS08}:

\begin{itemize}
  \item Type I: $\GG_1 = \GG_2$;
  \item Type II: $\GG_1 \not= \GG_2$ and there exists an efficiently computable homomorphism $\phi: \GG_2 \mapsto \GG_1$ (bot not for $\GG_1 \mapsto \GG_2$);
  \item Type III: $\GG_1 \not= \GG_2$, without any efficiently computable homomorphism between $\GG_1$ and $\GG_2$.
\end{itemize}

\subsection{Computational Assumptions}
In this section we recall computational assumption used in the remainder of this thesis.
We distinguish between assumptions on cyclic groups and assumptions on composite order groups.

\mynote{give games here with security parameter}

\subsubsection{Cyclic Groups}
In this section we recall some computational assumptions in the group context that are believed to be hard.
The \ac{DLP} is the basis of all assumptions in groups.

\begin{definition}[\acl{DLP}]\label{def:dlp}
Let \GG denote a group of prime order $p$ with generator $g$.
The \ac{DLP} in \GG states that given a random element $h\rin\GG$ it is hard to compute $x$ such that $h=g^x$.
\eod
\end{definition}

\noindent
Several \ac{DLP}-based assumptions have been proposed.
The two most important ones are the \ac{DDH} and \ac{CDH} assumptions.

\begin{definition}[\acl{DDH}]\label{def:ddh}
Let \GG denote a group of order $p$ with generator $g$.
The \ac{DDH} assumption in \GG states that given $(g,g^a,g^b,g^c)\in\GG^4$ it is hard to determine whether $c=ab$ for random scalars $a,b,c\rin\ZZ_p$.
\eod
\end{definition}

\begin{definition}[\acl{CDH}]\label{def:cdh}
Let \GG denote a group of order $p$ with generator $g$.
The \ac{CDH} assumption in \GG states that given $(g,g^a,g^b)\in\GG^3$ it is hard to compute $g^{ab}$ for random scalars $a,b\rin\ZZ_p$.
\eod
\end{definition}

\begin{definition}[\acl{SXDH} \cite{BallardGMM05,AtenieseCHM05}]\label{def:sxdh}
Let $\GG_1=\genG[1]$, $\GG_2=\genG[2]$, and $\GG_T=\genG[T]$ denote groups of prime-order $p$ with associated bilinear map $e$.
The \ac{SXDH} assumption states that the DDH assumption in $\GG_1$ and $\GG_2$ is hard, i.e. given $(w_1,x_1,y_1,z_1)\in\GG^4_1$ and $(w_2,x_2,y_2,z_2)\in\GG^4_2$ it is hard to decide whether there exists values $a_1,a_2$ such that $x_1=w_1^{a_1}$, $z_1=y_1^{a_1}$, $x_2=w_2^{a_2}$, and $z_2=y_2^{a_2}$.
\eod
\end{definition}

\subsubsection{Composite Order Groups}
The basic problem underlying all hardness assumptions in composite order groups is the factorisation problem.

\begin{definition}[Factoring is hard]\label{def:factoring}
Let $N=pq$ denote an integer with prime factors $p$ and $q$.
The factoring problem in $\ZZ^\ast_N$ states that given modulus $N$ it is hard to compute $p',q'$ such that $N=p'q'$.
\eod
\end{definition}

\begin{definition}[RSA Assumption]\label{def:rsa}
Let $N=pq$ denote an integer with prime factors $p$ and $q$ and $y\rin\ZZ^\ast_N$ a random element from $\ZZ^\ast_N$.
The RSA problem over $\ZZ^\ast_N$ states that given $(N,e,d,y)$ with $\gcd(e, \phi(N))=1$ and $ed=1\mod \phi(N)$ it is hard to compute $x$ such that $x^e = y \mod N$.
\eod
\end{definition}

\begin{definition}[One-more RSA]\label{def:onemoreRSA}
...
\eod
\end{definition}

%********************************** %Definitions  **************************************
\section{Definitions}
Asymptotic notation allows us to describe the behaviour of a function when its arguments tend towards some limit.
As mentioned earlier, security models used in this work are from the computational world.
In particular, running time and success or advantage probabilities of algorithms, \ie adversaries, are modelled as functions on a security parameter.
Security is therefore only given for \emph{reasonable} security parameters.
To express this asymptotic notation is used.

\begin{definition}[Negligible Functions]\label{def:negligible}
A function $f$ is \emph{negligible} if for every polynomial $p(\cdot)$ there exists an $N\in\NN$ such that for all $n\in\NN$ with $n>N$ it holds that $f(n)<1/p(n)$.
\eod
\end{definition}

\begin{definition}[Asymptotic Notation]\label{def:asymptotic}
Let $f(n)$ and $g(n)$ denote functions from $\NN_0$ to $\RR_{\geq 0}$.
\begin{itemize}
	\item $f(n)=\cO(g(n)):$ There exist $c,N\in\NN_0$ such that for all $n>N$ it holds that $f(n)\leq c\cdot g(n)$.
	\item $f(n)=\Omega(g(n)):$ There exist $c,N\in\NN_0$ such that for all $n>N$ it holds that $f(n)\geq c\cdot g(n)$.
	\item $f(n)=\Theta(g(n)):$ Both $f(n)=\cO(g(n))$ and $f(n)=\Omega(g(n))$ hold.
	\item $f(n)=o(g(n)):$ $\lim_{m\rightarrow\infty}\frac{f(n)}{g(n)}=0$
	\item $f(n)=\omega(g(n)):$ $\lim_{m\rightarrow\infty}\frac{f(n)}{g(n)}=\infty$ 
	\eod
\end{itemize}
\end{definition}

\paragraph{Probabilistic Polynomial-Time}
We often use the phrase \ac{PPT} to describe an efficient algorithm.
The actual definition of \ac{PPT}, first defined in \cite{gill1977}, is given for \ac{PP}, how \ac{PPT} is usually called in complexity theory, as follows:

\begin{definition}[\acl{PP}]\label{def:ppt}
\ac{PP} denotes the class of decision problems solvable by a \ac{PTM} $A$ such that
\begin{itemize}
	\item $A$ runs in polynomial-time,
	\item at least $1/2$ of the computation paths accept when the answer is `yes', and
	\item less than $1/2$ of the computation paths accept when the answer is `no'. \eod
\end{itemize}
\end{definition}

\noindent
The informal description for \aclp{PTM} is given in Definition \ref{def:ptm}.
We refer the interested reader to works concerned with complexity theory like \cite{santos1969,WaterlooComplexity} for more on \ac{PTM} and a formal definition.

\begin{definition}[\acl{PTM} \cite{gill1977}]\label{def:ptm}
A \ac{PTM} is a Turing machine with distinguished states called coin-tossing states.
For each coin-tossing state, the finite control unit specifies two possible next states.
The computation of a \ac{PTM} is deterministic except that in coin-tossing states the machine tosses an unbiased coin to decide between the two possible next states.
\end{definition}

\noindent
Note that the running time is always parametrised with the security parameter \secpar.
You can think of \ac{PPT} as a notion for ``feasible strategies'' or ``efficient algorithms'' running in time polynomial in \secpar.
In other words, this means that for some constants $a$ and $c$ the algorithm runs in time $a\cdot \secpar^c$ with security parameter \secpar \cite{katz2008introduction}.

\paragraph{The Random Oracle Model}
Many cryptographic proofs are only possible in the \emph{random oracle model} where a public randomly chosen black-box function $H$ is available.
The other popular model is the so-called \emph{standard model} where no such function exists.
While this function $H$ does not actually exist in the real world it is useful in many proves.
It is usually instantiated with a cryptographic hash function.
The function $H$ is queried on an input $x$ and returns the ``hash value'' of $x$.
It is consistent, such that $y=H(x)$ for all $y\gets H(x)$.
The output $y$ of $H$ is uniformly at random such that one can think of $H$ as drawing a random element $y$ each time it is queried on a new $x$.
If $H$ has seen $x$ before, it returns the previously chosen element $y$.

\subsection{Notations}
In addition to common notations (we do not recall here), we give here all notations used throughout this work.
\mynote{see if anything of this is useful ...}
\begin{itemize}
	\item If $A$ is an algorithm, then $x\algout A(y)$ denotes running $A$ with input $y$ and storing the result in $x$.
	\item If $A$ is a randomised algorithm, then $x\ralgout A(y;r)$ denotes running $A$ with input $y$ and randomness $r$, and storing the result in $x$.
	\item If $U$ is a set, then $x\rin U$ denotes that $x$ is chosen uniformly at random form $U$.
	\item A variable $y$ is assigned to $x$ by $x:=y$.
	\item The boolean operations \emph{and} and \emph{or} are denoted by $\wedge$ and $\vee$.
	\item Exclusive or (xor) is denoted by $\oplus$.
	\item Set of binary strings of length $n$ $\bits^n$.
	\item The length of a binary string $x$ is denoted by $|x|$, the bit-length of an integer $y$ is denoted by $\|y\|$.
	\item $\bigo,\Theta,\Omega,\omega$
	\item Since $\log_2$ is the most used logarithm we denote it by $\log$.
	\item The security parameter is denoted $\secpar$.
	\item Oracle access to $O(\cdot)$ for algorithm $A$ is denoted by $A^{O(\cdot)}$.
	\item Public/private key-pairs are denoted by $(\pk,\sk)$
	\item Negligible functions are denoted by $\varepsilon(\cdot)$.
	\item \aclp{PRF} are denoted by \PRF.
	\item \ZZ, \NN, \RR, $\NN_0$, $\NN_{\geq 0}$
\end{itemize}


%********************************** %Building Blocks  **************************************
\section{Building Blocks}

\subsection{Commitments}
Let $\Commitment=(\SetupC,\Com)$ denote a commitment scheme and $C\gets\Com(x;r)$ a commitment on $x$ using randomness $r$, with \SetupC generating parameters for \Commitment.
A commitment scheme $\Commitment=(\SetupC,\Com)$ is \emph{efficient} if $\SetupC(\secpar)$ and $(C,d)\gets\Com(x;r)$ are computable in polynomial time, \emph{complete} if $\Com(d)=(C,d)$ for $(C,d)\gets\Com(x;r)$, and secure if it is
\begin{itemize}
  \item Binding: For all PPT adversaries $\cA$ there exists a negligible function $\varepsilon_{\mathrm{bi}}(\cdot)$ such that for all $(x,x',r,r',C)\gets A$:
    $\Pr[x\not=x'\wedge (C,d)=\Com(x;r)\wedge (C,d')=\Com(x';r')] \leq \varepsilon_{\mathrm{bi}}(\secpar)$,
  \item Hiding: For all PPT adversaries $\cA$ there exists a negligible function $\varepsilon_{\mathrm{hi}}(\cdot)$ such that for all $x_0,x_1$ with $|x_0|=|x_1|$ and $b\rin\bits, (C,d)\gets\Com(x_b;r)$ and $b'\gets A(C,x_1,x_2)$:
    $\Pr[b=b'] \leq 1/2+\varepsilon_{\mathrm{hi}}(\secpar)$.
\end{itemize}

\subsubsection{Pedersen commitments \cite{Pedersen91}}
We will use perfectly hiding, computationally binding, homomorphic Pedersen commitments \cite{Pedersen91} defined as follows.
Let $\Pedersen=(\SetupC$, $\Com)$ with $(g,h,q,\secpar)\gets\SetupC(\secpar)$ and $C\gets\Com=(x;r)=g^x h^r$ denote the Pedersen commitment scheme where $g$ and $h$ are generators of a cyclic group $G$ of prime order $q$ with bit-length in the security parameter $\secpar$ and the discrete logarithm of $h$ with respect to base $g$ is not known.
Pedersen commitments are \emph{additively homomorph}, i.e. for all $(C_i,d_i) \gets \Com(x_i;r_i)$ for $i\in0,\dots,m$ it holds that $\prod_{i=0}^{m}C_i=\Com(\sum_{i=0}^{m}x_i$; $\sum_{i=0}^{m}r_i)$.

\paragraph{Trapdoor commitments}
In order to build zero-knowledge proofs of knowledge with malicious verifiers we require a trapdoor commitment scheme, which allows a party knowing the correct trapdoor to open a commitment to any value (equivocable commitment).
Fortunately, Pedersen commitments are trapdoor commitments as they can be opened to any element using the discrete logarithm $\log_g h$ as a trapdoor.

%----------------------------------- Zero Knowledge Proofs-----------------------
\subsection{Zero Knowledge Proofs}
A zero-knowledge proof is executed between a prover and a verifier, proving that a word $x$ is in a language $L$, using a witness $w$ proving so.
An interactive protocol \ZKP for a language $L$ between prover $P$ and verifier $V$ is a zero knowledge proof if the following holds:
\begin{itemize}
	\item Completeness: If $x\in L$, $V$ accepts if $P$ holds a witness proving so.
	\item Soundness: For every malicious prover $P^\ast(x)$ with $x\in L$ that the probability of making $V$ accept is negligible.
	\item Zero-Knowledge: If $x\in L$, then there exists an efficient simulator \Sim that on input of $x$ is able to generate a view, indistinguishable from the view of a malicious verifier $V^\ast$.
\end{itemize}

\paragraph{Zero-Knowledge Proof of Knowledge}
A zero-knowledge proof of knowledge \ZKPoK is a zero-knowledge proof with the following special soundness definition:
\begin{itemize}
	\item Soundness: There exists an efficient knowledge extractor $\Ext$ that can extract a witness from any malicious prover $P^*(x)$ with $x\in L$ that has non-negligible probability of making $V$ accept.
\end{itemize}

\subsubsection{Committed Zero-knowledge Proofs}
We use the following committed $\Sigma$-protocol to ensure extractability (\ZKPoK) and simulatability when interacting with a malicious verifier~\cite{Damgard00,JareckiL00}.
Let $P_1(x,w,r)$ and $P_2(x,w,r,c)$ denote the two prover steps of a $\Sigma$-protocol and $H:\bits^\ast\mapsto\ZZ_q$ a collision-resistant hash function.
A committed $\Sigma$-protocol based on Pedersen commitments is then given by the following four steps:
\begin{itemize}
  \item The prover computes the first message $m_1\gets P_1(x,w,r)$, computes 
  \[M_1\gets\Com(H(x,m_1); r_1)=g^{H(x,m_1)}h^{r_1},\]
  and sends $M_1$ to the verifier.
  \item The verifier chooses challenge $c\rin\ZZ_q$ and returns it to the prover.
  \item The prover computes the second message $m_2\gets P_2(x,w,r,c)$, computes 
  \[M_2\gets\Com(H(m_2); r_2)=g^{H(m_2)}h^{r_2},\]
   and sends $M_2$ to the verifier.
  \item Further, the prover sends the opens the commitments $M_1$ and $M_2$ sending $(x,m_1,m_2,r_1,r_2)$ to the verifier.
  \item The verifier accepts iff both commitments are valid and if the verification of the $\Sigma$-protocol $(x,m_1,c,m_2)$ is successful.
\end{itemize}

\noindent
Despite being zero-knowledge in the malicious verifier setting, this type of protocol has the advantage of concurrent zero-knowledge (since no rewinding is necessary \cite{Damgard00,JareckiL00}).


%----------------------- PK Encryption schemes---------------------------
\subsection{Public Key Encryption}

Public key encryption allows party $A$ holding a \emph{public key \pk} of some party $B$ to encrypt a message $m$ in ciphertext $c$ such that only the party holding the according \emph{secret key \sk} ($B$ in this case) to decrypt the ciphertext $c$ to $m$.
It is formally defined as follows.

\begin{definition}[Public Key Encryption]\label{def:pkencryption}
A public key encryption scheme $\PKE=(\PKEGen, \Enc, \Dec)$ consists of the following three algorithms:
\begin{itemize}
  \item $\PKEGen(\secpar)$ generates a secret/public key-pair $(\sk,\pk)$ on input of the security parameter \secpar
  \item $\Enc_\pk(m; r)$ encrypts message $m$ with \pk and randomness $r$, and outputs ciphertext $c$
  \item $\Dec_\sk(c)$ decrypts ciphertext $c$ with \sk and outputs message $m$
\end{itemize}
\end{definition}


\subsubsection{Public Key Encryption secure against Chosen-Plaintext Attacks}
\ac{CPA} defines a security for \ac{PKE} schemes where the attacker is allowed to query encryption and decryption oracles.

\begin{definition}[IND-CPA Security]\label{def:indcpa}
An encryption scheme $\Pi=(\PKEGen,\Enc,\Dec)$ is \emph{IND-CPA} secure if for all \ac{PPT} adversaries $\cA$ there exists a negligible function $\varepsilon(\cdot)$ such that:
\[\Adv_{\Pi,\cA}^{\cpa}(\secpar)=\left|\Pr[\Exp^{\cpa}_{\Pi,\cA}(\secpar)=1]-\frac12\right|\leq\varepsilon(\secpar)\]

\noindent
$\Exp^{\cpa}_{\Pi,\cA}(\secpar):$\\
\hspace*{2em}$(\pk,\sk)\ralgout\KGen(\secpar),~b\rin\bits$\\
\hspace*{2em}$(m_0,m_1)\gets\cA^{\Enc_\pk(\cdot)}(\secpar,\pk)$\\
\hspace*{2em}$c\gets\Enc_\pk(m_b)$\\
\hspace*{2em}$b'\gets\cA^{\Enc_\pk(\cdot)}(\secpar,\pk,m_0,m_1,c)$\\
\eod
\end{definition}


\paragraph{ElGamal Encryption}\label{sec:elgamalencryption}

Let $C=(u,e)\algout\Enc^{\EG}_\pk(m;r)$ with $u=g^r$ and $e=h^rg^m$ denote an El-Gamal ciphertext.
Note that we assume $m\in\ZZ_q$ and $\GG$ is a cyclic group of prime order $q$ with generator $g$ such that $g^m\in\GG$.
The ElGamal public key is defined as $\pk=(q,\GG,g,h)$ with $h=g^z$ such that $\dk=z$ denotes the decryption key.
Decryption is given by $g^m=\Dec_\dk^\EG(C)=e/u^z$.


\subsubsection{Public Key Encryption secure against Chosen-Ciphertext Attacks}
\ac{CCA} defines a security for \ac{PKE} schemes where the attacker is allowed to query encryption and decryption oracles.
It is therefore a stronger security requirement than \ac{CPA}.
Note that we always refer to adaptive \ac{CCA}-security, i.e. \ac{CCA}2, when talking about \ac{CCA}-security.

\begin{definition}[IND-CCA2 Security]\label{def:indcca2}
An encryption scheme $\Pi=(\PKEGen,\Enc,\Dec)$ is \emph{IND-CCA2} secure if for all \ac{PPT} adversaries $\cA$ there exists a negligible function $\varepsilon(\cdot)$ such that:
\[\Adv_{\Pi,\cA}^{\ccatwo}(\secpar)=\left|\Pr[\Exp^{\ccatwo}_{\Pi,\cA}(\secpar)=1]-\frac12\right|\leq\varepsilon(\secpar)\]

\noindent
$\Exp^{\ccatwo}_{\Pi,\cA}(\secpar):$\\
\hspace*{2em}$(\pk,\sk)\ralgout\KGen(\secpar),~b\rin\bits$\\
\hspace*{2em}$(m_0,m_1)\gets\cA^{\Enc_\pk(\cdot),\Dec_\sk(\cdot)}(\secpar,\pk)$\\
\hspace*{2em}$c\gets\Enc_\pk(m_b)$\\
\hspace*{2em}$b'\gets\cA^{\Enc_\pk(\cdot),\Dec_\sk(\cdot)}(\secpar,\pk,m_0,m_1,c)$\\
\hspace*{2em}return $b=b'$\\
Note that $\cA$ must not query the decryption oracle on $c$.
\eod
\end{definition}

\paragraph{Labelled Public Key Encryption}
We mainly use a variant of public key encryption, called labelled \ac{PKE} \cite{Shoup01,Canetti2005}.
Labelled \ac{PKE} takes a public \emph{label $\ell$} as additional input to the encryption ($\Enc_\pk(m,\ell; r)$) and decryption algorithm ($\Dec_\sk(c,\ell)$).
The attacker in the \ac{CCA}-security experiment is now also allowed to query the decryption oracle on $c$ as long as the label $\ell'$ handed to the oracle is different from $\ell\not=\ell$.


\paragraph{Cramer-Shoup Encryption}\label{sec:csencryption}

We use SPHFs on labelled \emph{Cramer-Shoup (CS)} encryptions throughout this work. %, i.e. $\cL=\CS$.
Here we briefly recall its definition.
Let $C=(\ell,\bm{u},e,v)\algout\Enc^{\CS}_\pk(\ell,m;r)$ (on label $\ell$, message $m$, and randomness $r$) with $\bm{u}=(u_1,u_2)=(g_{1}^r,g_{2}^r),~ e=h^rg_1^m$ and $v=(cd^{\xi})^r$ with $\xi=H_k(\ell,\bm{u},e)$ denote a labelled Cramer-Shoup ciphertext.
We assume $m\in\ZZ_q$ and $\GG$ is a cyclic group of prime order $q$ with generators $g_1$ and $g_2$ such that $g_1^m\in\GG$.
The CS public key is defined as $\pk=(p,\GG,g_{1},g_{2},c,d,H_k)$ with $c=g_{1}^{x_1}g_{2}^{x_2}, d=g_{1}^{y_1}g_{2}^{y_2}, h=g_{1}^z$ and hash function $H_k$ such that $\tau=(x_1,x_2,y_1,y_2,z)$ denotes the decryption key.
Decryption is defined as $g_1^m=\Dec_\dk^\CS(C)=e/u_1^z$ if $u_1^{x_1+y_1\cdot \xi'}u_2^{x_2+y_2\cdot \xi'}=v$ with $\xi'=H_k(\ell,\bm{u},e)$.


%----------------------- SPHF---------------------------
\subsection{Smooth Projective Hashing}
We focus in this work on two-server PAKE and therefore describe SPHF and its variants only for our purpose, for general definitions see \cite{cryptoeprint:2013:034,KieferM14a}.
First, we recall definitions for classical SPHF tailored to the PAKE use-case and cyclic groups $\GG$ of prime-order $q$.
Hence, we use languages of ciphertexts with the password as message and the randomness as witness.
An SPHF language $L$ for a given password \pwd from dictionary \cD is given by \Lpwd. 
The public parts of the language are given by the common reference string \crs containing the public key \pk of the used encryption scheme.
By $\tau$ we denote the \crs trapdoor, the secret key to \pk.
We denote $\cL$ the encryption scheme used to generate words in \Lpwd.
Unless stated otherwise we assume that $\cL$ is a labelled CCA-secure encryption scheme.

% FIXME: \fk{remark for \GG}

\begin{definition}[Languages of Ciphertexts]\label{def:language}
Let $L_\pwd \subseteq \{(\Label, C, \pwd^\ast)\}=\cC$ denote the language of labelled ciphertexts under consideration with ciphertext $(\Label,C)$ under \pk and password $\pwd^\ast\in\cD$.
A ciphertext $C$ is in language $L_\pwd$ iff there exists randomness $r$ such that $C\gets\Enc^{\cL}_\pk(\ell,\pwd;r)$.
\end{definition}

\noindent
Smooth projective hashing for languages of ciphertexts is then defined as follows.
Note that we describe only KV-SPHF where the projection key does not depend on the word (ciphertext).

\begin{definition}[KV-SPHF]\label{def:sphf}
Let $\Lpwd$ denote a language of ciphertexts such that $C\in \Lpwd$ if there exists randomness $r$ proving so.
A \emph{smooth projective hash function} for ciphertext language \Lpwd consists of the following four algorithms:

\begin{itemize}
	\item $\HKGen(\Lpwd)$ generates a random hashing key \hk for language \Lpwd.
	\item $\PKGen(\hk,\Lpwd)$ derives the projection key $\hp$ from hashing key \hk. 
	\item $\Hash(\hk,\Lpwd,C)$ computes hash value $h$ from hashing key \hk and ciphertext $C$.
	\item $\PHash(\hp,\Lpwd,C,r)$ computes hash value $h$ from projection key \hp, ciphertext $C$ and randomness $r$. 
\end{itemize}
\end{definition}

\noindent
A SPHF has to fulfil the following three properties:
\begin{itemize}
	\item \emph{Correctness}: If $C\in L$, with $r$ proving so, then $\Hash(\hk,\Lpwd,C)=\PHash(\hp,\Lpwd,C,r)$.
	\item \emph{Smoothness}: If $\{(\Label, C, \pwd^\ast)\}\ni C\not\in\Lpwd$, the hash value $h$ is (statistically) indistinguishable from a random element. 
	\item \emph{Pseudorandomness}: If $C\in\Lpwd$, the hash value $h$ is (computationally) indistinguishable from a random element. 
\end{itemize}

\noindent
In a nutshell, smoothness ensures that the hash value always looks random in $\GG$ when computed on an element not in the language, while pseudorandomness ensures that it looks random in $\GG$ when computed on an element in the language.
Note again that we are only concerned with KV-SPHF that have word-independent keys and offer adaptive smoothness (first proposed in \cite{Katz2011}).
The corresponding notion of adaptive smoothness with word-independent keys is defined as follows.
For any function $f:\GG \mapsto \cC\setminus \Lpwd$ the following distributions are statistically $\varepsilon$-close:
\begin{align*}
& \{(\hp,h) ~|~ \hk\ralgout\HKGen(\Lpwd); \hp\algout\PKGen(\hk,\Lpwd); h\algout\Hash(\hk,\Lpwd,f(\hp))\} \\
\stackrel{\varepsilon}{=}~ & \{(\hp,h) ~|~ \hk\ralgout\HKGen(\Lpwd); \hp\algout\PKGen(\hk,\Lpwd); h\rin\GG\}
\end{align*}

\noindent
Gennaro and Lindell \cite{Gennaro2003} introduced pseudorandomness of SPHFs to show that \Hash and \PHash are the only way to compute the hash value even though the adversary knows some tuples $(\hp,C,\Hash(\hk,\allowbreak\Lpwd,C))$ for $C\in\Lpwd$.
An SPHF is pseudorandom if the hash values produced by \Hash and \PHash are indistinguishable from random without the knowledge of the uniformly chosen hash key \hk or a witness $w$, i.e. for all $C\in\Lpwd$ the following distributions are computationally $\varepsilon$-close:
\begin{align*}
& \{(\hp,C,h) ~|~ \hk\ralgout\HKGen(\Lpwd); \hp\algout\PKGen(\hk,\Lpwd); h\algout\Hash(\hk,\Lpwd,C)\} \\
\stackrel{\varepsilon}{=}~ & \{(\hp,C,h) ~|~ \hk\ralgout\HKGen(\Lpwd); \hp\algout\PKGen(\hk,\Lpwd); h\rin\GG\}
\end{align*}

\noindent
The formalisation from Katz and Vaikuntanathan \cite{Katz2011} define pseudorandomness to hold even if hashing keys and ciphertexts are re-used.

\begin{definition}[Pseudorandomness]\label{def:prplusc}
An \SPHF $\Pi$ offers pseudorandomness if for all PPT algorithms $\cA$ and polynomials $l$ there exists a negligible function $\varepsilon(\cdot)$ such that
\[\Adv_{\Pi,\cA}^{\Pr}=\left|\Pr[\Exp_{\Pi,\cA}^{\Pr}(\secpar)=1] - \frac12 \right|\leq \varepsilon(\secpar)\]

\noindent
$\Exp_{\Pi,\cA}^{\Pr}(\secpar):$ Choose $b\rin\bits$, call $b'\gets\cA^{\Omega^{\cL}_\pk(\cdot),\Dec^\cL_\pi(\cdot)}(\secpar,\hp_1,\dots,\hp_l)$ with $\hp_i\gets\PKGen(\hk_i,\Lpwd,C)$ and $\hk_i\gets\HKGen(\Lpwd)$ for all $i\in 1,\dots,l$.
Return $b=b'$.

\begin{description}
	\item[$\Omega^{\cL}_\pk(\ell,\pwd)$] returns elements $C\in \Laux$ with $C\gets\Enc^\cL_\pk(\Label,\allowbreak\pwd;r)$ using encryption algorithm \cL and label \Label.
    	It additionally returns $\Hash(\hk_{i},\Lpwd,C)$ if $b=0$ or $h_{i}\rin\GG$ if $b=1$ for all $i\in 1,\dots, l$.
	
	\item[$\Dec^\cL_\pi(\Label,C)$] decrypts the ciphertext $C$ with label \Label if $(\Label,C)$ was not obtained from $\Omega^\cL_\pk$.
\end{description}
\end{definition}

\paragraph{SPHF on Cramer-Shoup Ciphertexts}
Benhamouda et al. propose a new perfectly smooth SPHF for labelled Cramer-Shoup encryptions in \cite{Benhamouda2013}.
The SPHF is defined as follows:
\begin{itemize}
  \item $\HKGen(\Lpwd)$ return $\hk=(\eta_1,\eta_2,\theta,\mu,\nu)\rin\ZZ_q^{1\times 5}$
  \item $\PKGen(\hk, \Lpwd)$ returns $\hp=(\hp_1=g_1^{\eta_1} g_2^{\theta} h^\mu c^\nu, \hp_2=g_1^{\eta_2} d^{\nu})$
  \item $\Hash(\hk, \Lpwd, C)$ computes $h=u_1^{\eta_1+\xi\eta_2} u_2^{\theta} (e/g_1^{\pwd})^\mu v^\nu$
  \item $\PHash(\hp, \Lpwd, C, r)$ computes $h=(\hp_1 \hp_2^\xi)^r$
\end{itemize}

\subsubsection{Trapdoor \SPHF (\TSPHF)}\label{sec:tsphf}
To build efficient one-round UC-secure PAKE protocols Benhamouda et al. \cite{Benhamouda2013} introduce the notion of \TSPHF.
We briefly recall their definition and additional security properties such as $(t,\varepsilon)$-soundness and computational smoothness in the light of PAKE protocols.
\TSPHF adds three additional functions to the classical SPHF definition that allow computation of the hash value knowing only the projection key, ciphertext and trapdoor $\tau'$.\footnote{Note that $\tau'$ is a different trapdoor than the CRS trapdoor $\tau$.}

\begin{definition}[Trapdoor SPHF]\label{def:tsphf}
Let $\Lpwd$ denote a language of ciphertexts such that $C\in \Lpwd$ if there exists randomness $r$ proving so.
A \emph{trapdoor smooth projective hash function} for ciphertext language \Lpwd consists of the following seven algorithms:

\begin{itemize}
  \item \HKGen, \PKGen, \Hash and \PHash are as given in Definition \ref{def:sphf}
	\item $\TSetup(\crs)$ generates a second $\crs'$ with trapdoor $\tau'$ on input of a \crs
	\item $\VerHp(\hp, \Lpwd)$ returns $1$ iff \hp is a valid projection key, $0$ otherwise
	\item $\THash(\hp, \Lpwd, C, \tau')$ computes the hash value $h$ of $C$ using the projection key \hp and trapdoor $\tau'$
\end{itemize}

\noindent
We assume $\crs'$ is, like \crs, made available to all parties.
\end{definition}

\emph{Correctness} of T-SPHFs extends correctness of SPHFs by the statement that for every valid ciphertext $C$, generated by \cL, and honestly generated keys \hk and \hp, it holds that $\VerHp(\hp, \Lpwd)=1$ and $\Hash(\hk, \Lpwd, C)=\THash(\hp, \Lpwd, C, \tau')$.
To capture soundness of T-SPHFs \cite{Benhamouda2013} introduces \emph{$(t,\varepsilon)$-soundness}, complementing the previous correctness extension.

\begin{definition}[$(t,\varepsilon)$-soundness]
Given \crs, $\crs'$ and $\tau$, no adversary running in time at most $t$ can produce a projection key \hp, a password \pwd, a word $C$, and valid witness $r$ such that \hp is valid, i.e. $\VerHp(\hp,\Lpwd)=1$, but $\THash(\hp,\Lpwd,C,\tau')\not=\PHash(\hp,\Lpwd,C,r)$ with probability at least $\varepsilon(\secpar)$.
Perfect soundness states that the property holds for any $t$ and any $\varepsilon(\secpar)>0$.
\end{definition} 

\noindent
As statistical smoothness is impossible for T-SPHF, \cite{Benhamouda2013} introduces the notion computational smoothness, which is similar to the definition of pseudorandomness for SPHFs.

\begin{definition}[Computational Smoothness \cite{Benhamouda2013}]
An SPHF is $(t,\varepsilon)$-smooth if for all adversaries $\cA$ running in time at most $t$
\[ \Adv_{\Pi, \cA}^{\smooth{b}} = \left|\Pr[\Exp^{\smooth{1}}_{\SPHF,\cA}(\secpar)=1] - \Pr[\Exp^{\smooth{0}}_{\SPHF,\cA}(\secpar)=1]\right| \leq \varepsilon(\secpar).\]

\noindent
$\Exp^{\smooth{b}}_{\SPHF,\cA}(\secpar):$ Generate $(\crs',\tau')\ralgout\TSetup(\crs)$.
The adversary, given $\crs, \crs'$ and $\tau$, is then allowed to query $\cO_{\PKGen}(\cdot)$ and $\cO_{\Hash_b}(\cdot)$ once before returning a bit $b'$.
Return $b=b'$.\\

\noindent
On input \pwd the $\cO_{\PKGen}$ oracle draws a new hash key \hk for \TSPHF on \Lpwd, computes the according projection key \hp using \PKGen, and returns it to the adversary.
The $\cO_{\Hash}$ oracle returns $h\gets \Hash$ honestly computed on input ciphertext $C$ if $b=0$ or $C\in\Lpwd$, and $h\rin \GG$ if $b=1$.\\
\end{definition}


\paragraph{\TSPHF on Cramer-Shoup Ciphertexts}
Benhamouda et al. propose a \TSPHF for labelled CS ciphertexts in \cite{Benhamouda2013} under the SXDH assumption.
The \TSPHF is a straight-forward extension of the previously described \SPHF in labelled CS ciphertexts.
Let $(q, \GG_1, \GG_2, \GG_T, e)$ denote a bilinear group and replace \GG from the previous \SPHF with $\GG_1$ and $g_1,g_2$ by $g_{1,1},g_{1,2}$, generators for $\GG_1$.
All other previous parameters are in $\GG_1$ instead of \GG and $g_2$ is generator of $\GG_2$.
The additional algorithms for \TSPHF and changes to the hash functions are defined as follows.
\begin{itemize}
  \item $\TSetup(\crs)$ draws a random $\tau'\rin\ZZ_q$ and sets $\crs'=\zeta=g_2^{\tau'}$.
  \item $\PKGen(\hk, \Lpwd)$ generates $\hp=(\hp_1=g_1^{\eta_1} g_2^{\theta} h^\mu c^\nu$, $\hp_2=g_1^{\eta_2} d^{\nu}$, $\hp_3)$ with 
      $\hp_3=(\chi_{1,1}, \chi_{1,2}, \chi_2$, $\chi_3, \chi_4)$ for 
      $\chi_{1,1}={\zeta}^{\eta_1}, \chi_{1,2}={\zeta}^{\eta_2}, \chi_2={\zeta}^{\theta}, \chi_3={\zeta}^{\mu}, \chi_4={\zeta}^{\nu}$
  \item $\Hash(\hk, \Lpwd, C)$ computes $h'=u_1^{\eta_1+\xi\eta_2} u_2^{\theta} (e/g_1^{\pwd})^\mu v^\nu$ as before and outputs $h=e(h',g_2)$
  \item $\PHash(\hp, \Lpwd, C, r)$ computes $h'=(\hp_1 \hp_2^\xi)^r$ as before and outputs $h=e(h',g_2)$
  \item $\VerHp(\hp, \Lpwd)$ verifies that 
      $e(\hp_1, \crs')\stackrel{?}{=} e(g_{1,1}, \chi_{1,1})\cdot e(g_{1,2}, \chi_2)\cdot e(h_1, \chi_3)\cdot e(c, \chi_4)$ and
      $e(\hp_2, \crs')$ $\stackrel{?}{=}$ $e(g_{1,1}$, $\chi_{1,2})\cdot e(d, \chi_4)$
  \item $\THash(\hp, \Lpwd, C, \tau')$ computes $\left[ e(u_1, \chi_{1,1} \chi_{1,2}^{\xi})\cdot e(u_2, \chi_2)\cdot e(e/g_{1,1}^{\pwd}, \chi_3)\cdot e(v, \chi_4) \right]^{1/\tau'}$
\end{itemize}
