\chapter{Password Authentication Framework in the Two-Server Setting} \label{ch:2pake}

While \ac{PAKE} and \ac{VPAKE} solve one of the most pressing problems in user authentication they are still vulnerable to offline dictionary attacks once the server is compromised.
To alleviate the impact of password leaks on the server threshold \ac{PAKE} has been proposed.
However, research in this area is rather limited compared to the single-server case.
This chapter proposes a framework for the two-server setting, similar to the framework from Chapter \ref{ch:vpake}, which uses \ac{2PAKE} for user authentication and a \ac{2BPR} protocol for password share registration.
We further propose a new security model for two \ac{2PAKE} protocols in the \ac{UC} model.

This chapter is based on work in \cite{KieferM14b,KieferM15b,KieferM15c}.

\paragraph{Two-Server Blind Password Registration}

Considering that ``password-cracking tools'' such as Hashcat \cite{hashcat} and John the Ripper \cite{JohnTheRipper} are very efficient, it is reasonable to assume that leaking password hashes is more or less equivalent to leaking passwords \cite{NarayananS05a,WeirAMG09,DellAmicoMR10,Bonneau12}.
The notion of threshold and two-server password authenticated key-exchange \cite{FordK00,MacKenzieSJ02} has been proposed where the password is not stored on a single server but split between a number of servers such that leakage of a password database on a non-qualified subset does not reveal the password.
The two-server setting is regarded as more practical (in comparison to a more general threshold setting) given that if one server is compromised a notification to change the password can be sent out to the clients.
\ac{2PAKE} protocols \cite{BrainardJKS03,SzydloK05,Katz2012a} split the client's password $\pwd$ into two shares $\share_1$ and $\share_2$ such that each share is stored on a distinct server.
During the authentication phase both servers collaborate in order to authenticate the client.
Yet, no server alone is supposed to learn the plain password.
A second, more recent development in two-server (and threshold) password protocols is \ac{PPSS} \cite{Bagherzandi2011,Camenisch2012,JareckiKK14} where a client stores shares of a (high-entropy) secret key on a number of servers and uses a (low-entropy) password to authenticate the retrieval process.

Registering password shares for \ac{2PAKE}/\ac{PPSS} protocols however makes it impossible for the servers to verify their password policies upon registration unless the password is transferred to each of them in plain. 
This however, would imply that the client trusts both servers to securely handle the password, which contradicts the purpose and trust relationships of multi-server protocols.
The use of two-server password protocols in a remote authentication setting, therefore, requires a suitable password registration procedure in which none of the servers would receive information enabling it (or an attacker in control of the server) to deliberately or inadvertently recover the client's password.
This registration procedure must further allow for policy compliance checks to be performed by the servers since secret sharing does not protect against weak passwords.
A trivial approach of sending $\share_1$ and $\share_2$ to the corresponding servers over secure channels is not helpful here since it is not clear how the two servers can perform the required compliance check.

The concept of blind password registration for two-server password protocols proposed as first step in this chapter shows how to realise secure registration of password shares in a way that protects against at most one malicious server (if both servers are malicious, the attacker obviously gets the password), yet allows both servers to check password compliance against their mutual password policy.
\ac{2BPR} is not vulnerable to offline dictionary attacks as long as one server remains honest.
This is in contrast to the single-server setting where an attacker is always able to perform offline dictionary attacks on password verifiers after compromising a server. %password BPR protocol
% Our main contribution is the 2BPR security model and the corresponding protocol for secure registration of 2PAKE/2PASS passwords. We show how secure distribution of password shares can be combined with an appropriate policy-compliance proof for the chosen password in a way that does not reveal the password and can still be verified by both servers.
% Our 2BPR protocol can be used to enforce policies over the alphabet of all 94 printable ASCII characters, including typical requirements on password length and character types.

\paragraph{Two-Server Password Authenticated Key Exchange}
% Before diving into technical preliminaries in the next section we want to discuss two-server PAKE and security guarantees it should provide.
We discuss informally several security requirements for 2PAKE protocols, which is the basis for the ideal functionality \FTWOPAKE defined later.
% Depending on the 2PAKE protocol not all of them can be achieved.
First, note that the adversary has full control over the communication channel between the client and the servers as usual.
% \emph{Security against offline dictionary attacks}
The first and foremost security requirement of password protocols is security against \emph{offline dictionary attacks} and therefore has to be fulfilled by 2PAKE protocols as well.
In particular, no eavesdropping adversary must be able to perform an offline dictionary attack on the exchanged messages.
% \emph{Security against impersonation attacks}
Further, a malicious server must not be able to \emph{impersonate a registered client} in a 2PAKE execution.
An attacker, even with knowledge and capabilities of one of the two servers, must have success probability that is not significantly better than the success probability of a brute-force attacker when running a 2PAKE protocol on behalf of a registered client.
% \emph{Security against malicious server}
The BPR game-based security notion for PAKE and two-server PAKE, which is derived from the AKE security notion, captures security by testing whether an attacker is able to distinguish between a real session key generated by a (two-server) PAKE protocol, and a randomly chosen session key.
This implies in particular that the client agrees on two independent session keys with the two servers in the two-server PAKE setting.
UC-security in contrast requires simulatability of a (two-server) PAKE protocol and is therefore harder to instantiate because the protocol has to be simulated in the case the adversary is able to guess the correct password (in which case the game-based model simply aborts the protocol execution and declares the adversary won the game).

% The strongest requirement on a 2PAKE protocol is the security against a malicious server.
% Here, a malicious server, or attacker controlling the server, must not be able to distinguish the session key between the client and the other server.
% The malicious server may be active or passive in its activities.
% Note again that not all server necessarily compute keys.

We want to further elaborate the difference between 2PAKE protocols where both servers compute the same key, compared to a 2PAKE protocol where the servers compute different keys.
Note that asymmetric key generation may also imply that only one server calculates a key while the second server only assists in the computation.
In the symmetric setting both servers calculate the same session key as result of the 2PAKE protocol.
Even though it is the first natural extension to the single server PAKE scenario, to the best of our knowledge no such protocol has been proposed yet.
This may be due to the fact that corruption of a single server compromises the session key of any execution of a 2PAKE protocol that involves this server.
In the asymmetric setting both servers generate different session keys as result of the 2PAKE protocol, possibly none.
Katz et al. proposed the first password-only 2PAKE provably secure in the standard model, based on the Katz-Ostrovsky-Yung (KOY) protocol \cite{Katz_Ostrovsky_Yung_2001} in 2005 \cite{KatzMTB05}.
While their protocol is symmetric in its execution the client computes two independent session keys, one with each server.
Other asymmetric 2PAKE protocols have been proposed \cite{Yang_Deng_Bao_2006,Jin_Wong_Xu_2007} where the server interacts with only one server.
% In this setting the second server may not even interact with the client or compute a session key.
% Before discussing these possible 2PAKE classes and their security properties we give an informal overview on security requirements on 2PAKE protocols.
% \emph{Symmetric Key Generation}
% Key generation in 2PAKE protocols however can have different forms.
% We distinguish here between \emph{symmetric} and \emph{asymmetric} key generation.
% In this case 2PAKE offers resistance against offline dictionary attacks by the server and server compromise attacks of a single server that leak the server's password database.
% However, an attacker controlling one of the two servers calculates the same session key as the honest server and the client.
% A 2PAKE protocol secure in this setting can only protect against impersonation attacks, and password database leaks while they can not prevent malicious servers from attacking it.
% \emph{Asymmetric Key Generation}
In this work we stick to the asymmetric setting where only one server computes a session key.
This however can be easily extended to a 2PAKE protocol that computes an independent session keys for each server.
% However, instead of using a game-based model such as the BPR derivatives, we propose an ideal functionality for the UC framework to show security of our 2PAKE protocol.
To this end we give the first definition of a 2PAKE UC functionality.
It brings all benefits UC-security carries in the PAKE setting such as universal composability, security holds with arbitrary (related) password choices, security on execution with non-matching password (shares), etc.
For a comprehensible overview of advantages using UC in the PAKE setting we refer to \cite{Canetti2005}.


\paragraph{Application to existing 2PAKE/2PASS protocols}
Our 2BPR protocol can be used to register passwords for two-server protocols such as two-server password authenticated key exchange (2PAKE) and two-server password authenticated secret sharing (2PASS).
2BPR can be used with two-server protocols that adopt additive password sharing in $\ZZ_q$ or multiplicative sharing in $G$.
This includes 2PAKE protocols from \cite{Katz2005,Kiefer14}, which do not consider password registration such that our protocol can simply be used as part of the registration process.
Integration of 2BPR into 2PASS on the other hand is more involved as password registration is part of the 2PASS protocol, i.e. the secret sharing phase.
2PASS protocols in general can be divided in two stages: password and secret registration/sharing and secret reconstruction.
While the approach from Bagherzandi et al. \cite{Bagherzandi2011}, as well as subsequent work using similar approaches \cite{PryvalovK14,CamenischLLN14,JareckiKK14}, does not actually share the password and could therefore use other means to verify policy compliance of a prospective password, the UC-secure 2PASS protocol from Camenisch, Lysyanskaya and Neven \cite{CamenischLN2012} uses multiplicative password sharing in $G$.
To use our 2BPR protocol in conjunction with the setup protocol from \cite{CamenischLN2012} we redefine the encoded password to $g^{\pi}$ with $\pi\gets\pwdint(\pwd)$ such that shares are computed as $g^{\pi}=g^{\share_0}g^{\share_1}$.
The first message (step 1) from the setup protocol in \cite{CamenischLN2012} can piggyback the first 2BPR protocol message.
The subsequent three messages between the client and each server are performed between step 1 and step 2, while the inter-server communication can be piggybacked on step 2 and step 3.
In addition to checking correctness of shares done in the setup of \cite{CamenischLN2012} the servers can now verify the 2BPR proofs and thus the password's policy compliance.
This adds three flows to the setup protocol of \cite{CamenischLN2012} in order verify policy compliance of password shares.

\paragraph{Outline}
\hfill\\
\mynote{do outline}

\input{Chapters/passwords2}

%********************************** %2PAKE Registration  **************************************
% \mynote{2BPR ???(ePrint/ESORICS'15) \cite{KieferM15c}}
\input{Chapters/2bpr}


%********************************** %2PAKE  **************************************
% \section{Two-Server PAKE} \label{sec:2pake-uc}

\input{Chapters/dsphf}
% \mynote{DSPHF ACNS'14 \cite{KieferM14b}}

\input{Chapters/uc2pake}
% \mynote{2PAKE UC ???(ePrint) \cite{KieferM15b}}

\section{Conclusion}
\mynote{2BPR and 2PAKE conclusion}
