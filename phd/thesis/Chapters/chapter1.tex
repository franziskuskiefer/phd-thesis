%*******************************************************************************
%*********************************** First Chapter *****************************
%*******************************************************************************

\chapter{Introduction}\label{ch:intro}  %Title of the First Chapter

\ifpdf
    \graphicspath{{Chapters/Figs/Raster/}{Chapters/Figs/PDF/}{Chapters/Figs/}}
\else
    \graphicspath{{Chapters/Figs/Vector/}{Chapters/Figs/}}
\fi

% \section{Setting things into perspective}
This work is concerned with cryptography from low-entropy secrets, better known as \emph{passwords}.
In contrast to conventional cryptographic algorithms and protocols, secrets used here have low-entropy, such that an adversary is able to iterate through all possible secrets in reasonable time.
This leads directly to the threats dictionary attacks (cf. Section \ref{sec:introdictionaryattacks}) that are inherent to everything we are dealing with in this work.
So why do we want to perform cryptography with passwords at all, when they comprise intrinsic attack possibilities?

\begin{quote}
``Humans are incapable of securely storing high-quality cryptographic keys, and they have unacceptable speed and accuracy when performing cryptographic operations.''~\citet{Kaufmann02}
\end{quote}

\noindent
While human's lack of speed and accuracy in performing cryptographic operations can be mitigated by using computers, human's inability to remember high-quality cryptographic keys is a major challenge.
Even though there exist several standardised authentication tokens for humans, we nowadays heavily rely on passwords.
In general we distinguish between three major categories of authentication data according to \citet{Burr11}:
\begin{itemize}
	\item Something you know (\eg password, \ac{PIN})
	\item Something you have (\eg mobile phone, cryptographic key)
	\item Something you are (\eg fingerprint)
\end{itemize}
But since everything someone has or is may be stolen or duplicated, knowledge (of a password) is a very important factor in authenticating a human (as long as it is not written down).
To perform cryptography with humans entering a secret/authentication token, those have to be human-memorable.
This leads to the necessity of password-based cryptography as everything humans are able to remember correctly is rather short and has limited entropy.

\paragraph{Outline of this Chapter}
This chapter gives a broad overview of password-based security mechanisms, security research, and cryptography research.
Section \ref{sec:intro:pwd-security} gives necessary definitions in the context of passwords used in this thesis and gives an overview of different ways of looking at passwords.
Section \ref{sec:intro:provable-security} describes general concepts and models used in the field of provable security this thesis is placed in.
Sections \ref{sec:intro:registration} and \ref{sec:intro:pake} give an overview of password-based cryptography research and related work.
The chapter is concluded with Section \ref{sec:intro:real-world} describing real world challenges and architectures in the password context and the outline of this thesis in Section \ref{sec:intro:outline}.

% *****************************************************************************
% Password-Based Cryptography
% *****************************************************************************

\section{Password-based Security} \label{sec:intro:pwd-security}
Using passwords as means of authentication in a computer system allows users to log into the system without the need for any additional devices or tools.
This huge advantage over other ways of authenticating, \ie with something you have or are, is probably responsible for passwords being the most popular authentication mechanism and is likely to stay such despite increasing efforts to changes this (cf. Section \ref{sec:enhanced-login}).
The most common place where passwords are used as user authentication mechanism is the Internet, where personal content is protected with a username and password.
Only when providing a valid identifier (username, often e-mail address) and the according password that the server stored for this identifier, the client is allowed to access data associated with this account.
Password and identifier are usually chosen by the client when registering a new account.
When someone forgets the password or wants to change it, websites offer the possibility to change the password for an account after providing the old password or other means of authentication (often done by sending a one-time link to the registered e-mail address).
This and other practical challenges such as password resets bring additional security risks that are out of scope of this thesis.

While passwords are used in other contexts such as device logins as well, we focus on the online setting in this thesis.
We look in particular at the previously described scenario of registering user accounts and their use for authentication and login purposes.
The used setting therefore contains a \emph{client} (controlled by the human user) that interacts with a remote \emph{server} controlling the client's account.

Password-based protocols are usually classified as symmetric because both parties hold the same secret (password).
Other variants exist where the server uses only a \emph{password verifier}, which can be classified as asymmetric.
In contrast to other cryptographic mechanisms where \emph{keys} are chosen from a \emph{key space}, \emph{passwords} are chosen from a \emph{dictionary}.
(A dictionary is defined as an efficiently traversable set.)
Note that dictionaries in our case denote sets of characters, \ie passwords, rather than a \emph{real} lexicon like dictionaries containing a certain set of words.
When talking about those we use the term \emph{lexicon}.
Even though password is the umbrella term, we distinguish between several types of passwords, discussed in the following.

\paragraph{Password}
The term \emph{password} refers to character strings chosen from a dictionary consisting of alpha-numeric characters \texttt{a-z}, \texttt{A-Z}, \texttt{0-9} and special characters like \texttt{\$,\%,@} and so on.
While \acs{UTF-8} based passwords or passwords based on other character encodings are possible, we focus on \acs{ASCII} based passwords in this thesis for convenience.
Despite the fact that many (online) services have password policies in place, humans tend to choose easily memorable and therefore often easy to guess passwords that can be found in a lexicon \cite{Florencio2007,Gaw2006}.
To encourage users to use stronger passwords, password-strength meters are used by many services, which display some measure of password strength entered by the client.
A recent study by \citet{Ur2012} on password-strength meters shows that this could have a significant impact on user's password-strength.
We define several other forms of user authentication that are similar to passwords in the following.
% Note however that those terms are usually not used in cryptography research and this thesis (but security research).

\paragraph{Graphical Passwords}
Graphical passwords were first proposed by \citet{Blonder96}. 
Microsoft Window's picture passwords \cite{picturepwd1,picturepwd2} is the best known implementation of a subclass of graphical passwords.
Instead of relying on entropy in a character string, graphical passwords require the user to recognise certain images or features in an image.
The security usually stems from the ability of humans to reliably recognise pictures and small features inside pictures whereas algorithms struggle to do so.
This approach is somewhat related to using \acsp{CAPTCHA} to distinguish between humans and machines by asking a question hard for computers to solve, but easy for humans (hence the name \ac{CAPTCHA}, \acl{CAPTCHA}).
The term \ac{CAPTCHA} was coined by \citet{AhnBHL03}.

\paragraph{Passphrase}
Passphrases are very similar to passwords in the sense that they are character strings.
But instead of using relatively short words with characters from a big character set in order to reach security (entropy), passphrases are longer and generate their strength (entropy) from length over a rather small character set.
One big advantage of passphrases over passwords is that they are usually easier to memorise.

\paragraph{\acl{PIN}}
\acp{PIN} are rather short passwords, chosen only from the numeric dictionary containing numbers \texttt{0-9}.
They are mainly used to secure access to the actual authentication token like credit or other smart cards.
Since the card is a second authentication factor (\emph{something you have}), a short \ac{PIN} is sufficient to reach reasonable security.
The smaller dictionary containing only numbers is most likely due to practical restrictions on the input device, used to enter the \ac{PIN} and the fact that they are easier to memorise.

\paragraph{One-time Password}
While most passwords are meant to be memorised by humans, \acp{OTP} are used only once and therefore do not have to be memorised.
They are mainly chosen from the numeric dictionary \texttt{0-9}.
\acp{OTP} have become more popular recently as a second factor, in addition to the ``regular'' password, in two-factor authentication, \eg Google \cite{Google2Factor}, Facebook \cite{FB2Factor}, Twitter \cite{Twitter2Factor} and GitHub \cite{Github2Factor}.
The most popular standards for \ac{OTP} that are for example implemented in the Google Authenticator App \cite{GAuthenticator} are the \acs{HMAC} based algorithm specified in RFC 4226 \cite{rfc4226} and the time based algorithm specified in RFC 6238 \cite{rfc6238}.

\paragraph{Transaction authentication numbers}
\acp{TAN} are special \acp{OTP} mainly used to authorise single financial transactions in online banking applications.
These mainly short passwords are usually drawn from the numeric dictionary containing numbers \texttt{0-9}.
They can be seen as transaction bound \acp{OTP}.

% *****************************************************************************
% The inherent Threat of Dictionary Attacks
% *****************************************************************************

\subsection{The inherent Threat of Dictionary Attacks}\label{sec:introdictionaryattacks}
As mentioned already, most cryptographic mechanisms use high-entropy secrets such that it is impossible for anyone (any algorithm) to traverse all possible secrets from the particular key space in reasonable time.
Password-based schemes in contrast assume low-entropy secrets that are drawn from a polynomial sized dictionary.
Therefore, it is feasible for an algorithm to walk through the entire dictionary and just try every possible secret (password).
This kind of attack, \emph{dictionary attack}, is inherent to any password-based algorithm and is therefore one of the main challenges in password-based cryptography compared to mechanisms on high-entropy secrets.

We differentiate between offline and online dictionary attacks.
Offline dictionary attacks allow an attacker to try elements from the dictionary in question against offline available data, while online dictionary attacks require the attacker to perform online queries to another party/oracle to verify whether an element from the dictionary is the right password or not.

\paragraph{Poorly Chosen Passwords}
While dictionary attacks are unavoidable, poorly chosen passwords worsen the situation.
Due to poorly chosen passwords it is often sufficient to perform a lexicon attack that traverses only a relatively small dictionary containing for example words of the English language instead of a brute force dictionary attack that iterates the entire dictionary.
By choosing passwords that are available in lexicons or easy to derive from other parameters like the public e-mail address, the search space for dictionary attacks gets significantly smaller.
Password cracking tools like \emph{John the Ripper} \cite{JohnTheRipper} or \emph{HashCat} \cite{hashcat} gather lexicons of different languages in password lists \cite{JohnTheRipperWordlist} to speed up attacks.
Not only language lexicons can be used for brute-force attacks on passwords, but password lists of often used passwords that got somehow leaked.
Using for example a list with the most used passwords \cite{XatoPwds,XatoPwds2,skullSecurity}, dictionary attacks on online accounts may be performed very efficiently.
Other common attack vectors on poorly chosen passwords is by exploiting common password composition rules such as \verb+<word><numbers>+.

% *****************************************************************************
% The Real World
% *****************************************************************************

\subsection{Passwords in The Wild}
Systems currently deployed on the Internet use the approach of \emph{password-over-\acs{HTML}} --- sending the password over an encrypted channel (\ac{TLS}) to the server for verification or registration --- which is risky due to the threat of disclosing user credentials to malicious parties via a plethora of attacks such as phishing attacks or \ac{MitM} attacks.
Even though a confidential \ac{HTTPS} connection --- \ac{HTTP} over a \ac{TLS}-encrypted connection --- is often used to transport sensitive data such as passwords, the server authentication of the underlying \ac{TLS} protocol depends on the user actually validating the server's certificate, the accessed \ac{URL}, and trust in a properly working \ac{PKI}.
(This includes sophisticated and government aided attacks.)
Password-based mechanisms on the web are (except for some exceptions such as \cite{FirefoxSync}) missing cryptographic treatment of the password for authentication purposes all together.
Instead, their security relies on the security of the secure channel used for transportation (\ac{TLS}) and thus the user's ability to verify the channel and the server's correct handling.

\subsubsection{Enhanced User Login} \label{sec:enhanced-login}
As discussed previously humans are hardly able to remember high-entropy secrets.
But even remembering passwords seems complicated in many cases such that users re-use their passwords and choose them from lexicons to simplify the process of recalling \cite{Gaw2006,Florencio2007}.
To simplify the user login process many technical solutions are in use of which some require passwords and others do not.
This work is not primarily concerned with these technical aspects but we give a brief overview on what is out there.
Those mechanisms either avoid the process of logging onto a website all together or automate it as far as possible.
The former is achieved by \ac{SSO} services such as Kerberos \cite{rfc4120} OpenID \cite{OpenID} or OAuth \cite{rfc6749}.
The latter is done by using password managers in combination with auto completion implementations that store login information for websites and fill forms automatically.
Other mechanisms try to enhance security by adding additional authentication factors to the password.
Enhancements to password-based logins such as multi-factor authentication \cite{FleischhackerMA14} exist where multiple authentication mechanisms are combined.
Popular implementations of this paradigm use the two factors \ac{OTP} and password. % \cite{Google2Factor,FB2Factor,Twitter2Factor,Github2Factor}.


\subsection{On Password Security Research}\label{sec:passwordresearch}
Security research on passwords holds an excessive body of works at topics such as ``how to measure password strength'', ``how to securely hash and store passwords'', or ``how to encrypt using a password''.
Since this thesis is primarily concerned with cryptographic treatment of passwords and therefore uses idealised assumptions we give only a brief introduction into these research fields and highlight links to this thesis.

\paragraph{Password Strength}
One of the most difficult topics in password research is the question of how to measure the strength of a password.
While cryptography research usually assumes uniform or some other idealised distribution of passwords, this is clearly not the case in reality with humans choosing them.
Measuring password strength involves many non technical tasks (such as research into how humans choose passwords) and focuses on user studies and analysis of password database leaks \cite{ShayKKLMBCC10,KomanduriSKMBCCE11,MazurekKVBCCKSU13} in order to come up with a good model to predict min-entropy of passwords.
Min-entropy can capture many realistic password creation models and has been standardised by \citet{nist800}.
However, although min-entropy seems a reasonable measure for modelling dictionary attack resistance of passwords we stress that min-entropy alone is not sufficient to estimate the real password strength. 
As shown by \citet{MazurekKVBCCKSU13}, password strength is a complex matter (due to a variety of real-world attacks) and can hardly be captured through a single metric like min-entropy.
While min-entropy is the most practical way to model password strength, \citet{MazurekKVBCCKSU13} also use other metrics such as password length, number of characters from specific \ac{ASCII} subsets, substituting characters with numbers, placement of digits, and so on.
For a full overview of other metrics we refer to \citet{MazurekKVBCCKSU13}.

\paragraph{Password Hashing and Storage}
In order to securely store passwords or use them for encryption, hashing them in some form is essential to make attacks on them more expensive.
The current state of the art password hashing schemes are the \ac{PBKDF2} \cite{rfc2898}, bcrypt \cite{ProvosM99}, and scrypt \cite{rfcScrypt}.
This very limited number of possible password hashing schemes should be resolved by the recently concluded password hashing competition (\url{https://password-hashing.net} that proposes a new hashing scheme called Argon2 by \citet{Biryukov15}).
Other more technical means to avoid stealing stored passwords is to hide them in a huge amount of data that makes it impossible to steal without being detected (a recent implementation is given by Taplink \url{https://taplink.co/technology/}).

\subsection{Password-based Cryptography}
Cryptography research in the area of passwords focuses mainly on \ac{PAKE} protocols and recently \ac{PPSS}.
\ac{PAKE} allows to exchange an authenticated session key between two parties holding a common password for authentication.
In contrast to other authenticated key exchange protocols \ac{PAKE} has to consider online dictionary attacks, \ie that an attacker is always able to run the protocol often enough with the server in order to eventually successfully authenticate.
The recent development of \ac{PPSS} moves away from key exchange and tackles the problem of encrypted online storage that is secured with the user's password.
In order to achieve high security, data stored on servers should be encrypted with common encryption mechanisms such as \ac{AES} \cite{FIPS-197}.
However, to access the data, users would have to store the key used in \ac{AES} to encrypt the remote storage.
The solution proposed by \ac{PPSS} allows to split the key in shares that are stored at different servers and can only be retrieved if the user successfully authenticates itself to the servers with the correct password.
\ac{PPSS} therefore allows to achieve secure remote storage with only a password for authentication, where security is achieved by sharing the password and key among multiple servers.
By not trusting a single server, password and key shares can get leaked or stolen without compromising security directly.
A comprehensible overview of password-based cryptography research can be found at \citet{KieferXX}.

\paragraph{Strong Cryptography from Low-Entropy Secrets}
Despite authentication and key exchange, passwords are used in other contexts such as general strong cryptography.
Due to the low-entropy of passwords this obviously introduces new interesting challenges.
\citet{AbdallaBCP09} show how to build strong cryptography from weak secrets.
In particular, they propose a method to perform distributed public key cryptography when each party holds only a low entropy password, based on the \ac{DDH} assumption.
\citet{BoyenCFP10} extend the notion to the pairing world.

% *****************************************************************************
% Section: On Provable Security
% *****************************************************************************

\section{On Provable Security}\label{sec:intro:provable-security}
We briefly discuss general security models used in the field of provable security, this thesis is placed in, as well as other means of establishing confidence in the security of an algorithm.
More specialised methods used in password-based cryptography are analysed later.

To prove a cryptographic primitive secure, reductionist arguments are used.
Thereby, the attempt is made to reduce the security of the algorithm/protocol under consideration to a problem that is believed to be hard.\footnote{Note that this work is not concerned with the question whether specific problems are actually hard. We consider only well investigated problems, which the cryptography community beliefs to be hard.}
Thus, given a (tight) reduction from the primitive to an underlying problem, one can be confident that the primitive is secure as long as the underlying problem is actually hard to solve.
For an insightful and sceptical discussion on this kind of security verification we refer to the ``Another Look'' series by \citet{AnotherLook}.

Cryptographic primitives can only be proven secure considering the abilities of a certain adversary.
Therefore, before being able to proof anything about a cryptographic primitive it has to be modelled considering an appropriate (hostile) environment.
It always has to be kept in mind that the resulting proof is only valid within the used model and thus not necessarily in every scenario, \ie the real world.
Before further discussion we give a brief introduction to another approach to analyse security: \emph{The Formal World}.
A formal view on modelling security goes back to work throughout the 1980's \cite{DeMillo82,Dolev83,Millen87,Meadows91,Kemmerer1988,Burrows90}.
While they explore different approaches of formal modelling, the so called Dolev-Yao model \cite{Dolev83} may be the best known one.
In this formal world, everything is modelled by formal expressions rather than bit strings.
The adversary controls the entire communication channel between participating parties and can replay, modify or drop messages.
A major drawback of this model is that it allows only all-or-nothing  and no probability or computational statements.

\paragraph{The Computational World}
In this thesis we deal with computational modelling.
The foundation of today's computational models were laid in the 1980's by Goldwasser and others \cite{Goldwasser82,Goldwasser84,Yao82,Blum82}.
The computational world consists of bit-string messages and cryptographic primitives performing computations on them.
It is therefore based on complexity theory rather than formal methods.
In this world the attacker is modelled as a \ac{PPT} Turing machine \cite{Turing37} that must not have significant success probability.
We give necessary formal definitions in Chapter \ref{ch:prelims}.

\paragraph{Reconciling the Two Worlds}
Even though efforts have been made to reconcile the two approaches of formal and computational models \cite{Abadi2002,Herzog2005}, there remain big differences in theory as well as in their communities.
For more discussion on these two worlds we refer the interested reader to \citet{cortier2011survey}.

%********************************** %Game-based Security  **************************************
\subsection{Game-based Security}
In this and the following section we give a short introduction to the two general directions of computational security proofs, game-based and simulation-based security.
Game-based security models allow the (\ac{PPT}) adversaries to play a game against a challenger.
During this game (\aka experiment) he is allowed to query a set of \emph{oracles} to simulate and interact with the primitive or protocol under consideration.
Eventually, the adversary outputs his answer to the challenger who decides whether the adversary wins the game or not.

Oracles are black-box functions simulating parts of the protocol's behaviour, the adversary can query.
On (possibly empty) input they return the result of their computation to the caller.
Thereby, oracles define an interface for the adversary to interact with the primitive.
The actual security definition and strength of the adversary therefore strongly depends on the available oracle.

Since simple reduction proofs from a protocol to a hard problem are rare, techniques have been developed to do this step by step.
An example on game-based security proofs using so called ``sequences of games'' is given by \citet{Shoup2004}.

%********************************** %Simulation-based Security  **************************************
\subsection{Simulation-Based Security}
The idea of simulation-based security proofs is due to \citet{Goldreich87}, further formalised by \citet{Canetti00}.
(We use the formalism by \citet{Goldreich2001,Goldreich2004}.)
In contrast to the previously described game-based approach simulation-based security does not define a challenger and oracles the adversary interacts with, but an ideal functionality in an ideal world the actual protocol should mimic in the real world.
The adversary's goal is to distinguish between the execution in the ideal world with a perfectly secure (ideal) algorithm/protocol, and the real world with the actual algorithm/protocol.
Security reasoning is then done as follows: since the ideal primitive does not leak any information other than publicly observable and its behaviour is indistinguishable from the real world, the real world primitive is secure.
Most game-based security models only allow to derive statements about the algorithm in a shielded environment or are limited otherwise.
As soon as the algorithm is used with other primitives, and thus sharing \ac{IO} channels and data, the security can not be guaranteed anymore.
Simulation-based security in contrast allows for composition of protocols.
This is strengthened in the \ac{UC} framework.

\paragraph{Universal Composability} \label{sec:uc-intro}
The \ac{UC} framework proposed by \citet{Canetti2001a} is a popular general purpose simulation-based security model.
It overcomes an inherent shortcoming of most game-based security models and improves on general simulation-based techniques as it allows for secure arbitrary concurrent composition with other primitives once a primitive is proven secure, which is stronger than the general simulation-based approach from \citet{Canetti00}.
The main difference between the general simulation-based security by \citet{Canetti00} and the \ac{UC} framework by \citet{Canetti2001a} is that the composition theorems from \citet{Canetti00} only hold in a non-concurrent setting.
The \ac{UC} framework uses ``distinguisher'' \UCZ, the environment, that generates all inputs for all parties, and reads their outputs.
A protocol is secure in \ac{UC} when it realises a given ideal functionality \UCF, such that for any real-world adversary \A, interacting with the protocol, there exists an ideal-world adversary \UCS, such that no environment \UCZ can decide whether it interacts with \A and the real-world protocol, or with the ideal world attacker \SIM and the ideal functionality \UCF.


% *****************************************************************************
% Section: Password Registration
% *****************************************************************************

\section{Cryptographic Password Registration}\label{sec:intro:registration}
Before using passwords for any kind of authentication protocol a password has to be registered with the server that performs the authentication process.
While registration of symmetric keys is not a particularly interesting cryptographic problem since security there has to be guaranteed by other means, password registration is more involved.
This is due to two different reasons;
First, passwords are not necessarily symmetric secrets.
In the verifier-based setting (cf. Section \ref{sec:intro:verifier-basedPAKE}) the server stores only a randomised function of the password and some randomness in order to authenticate the user holding the correct password, which results in an asymmetric setting.
Second, passwords are not chosen uniformly at random in practice but by humans and require additional attention.
In particular, systems commonly impose restrictions on possible passwords such as password policies in order to ensure a certain min-entropy of passwords in the system.
This should guarantee strong passwords that have reasonable security against dictionary attacks.

When users select passwords for remote access to systems or services, the password policy enforcement mechanism must be able to verify that selected passwords comply with the existing policy.
This compliance check can be performed either on the client side or on the server side.
For instance, when a web browser is used to register for some web service the policy can be checked within the browser using scripts embedded into the registration website, or on the server side upon the initial transmission of the password (\eg over a \ac{TLS} channel).
Both approaches, however, have security risks as discussed in the following.
If policy enforcement is performed solely on the client side, the server must trust the client to obey the policy and execute the check correctly.
This is not a threat if the compliance check is assumed to be in the interest of an honest user.
Nonetheless, malicious users or users who are too lazy to remember complicated passwords can easily circumvent such script-based verification and register passwords that are not compliant with the policy. The corresponding service provider might want to exclude this threat.
In this case the compliance check must be performed on the server side.
In order to perform policy checks with available technologies the client's password must be transmitted to the server, possibly over a secure channel.
This ultimately requires the client to trust the server to process and store the received password in a secure way.
While many servers adopt the current state-of-the-art approach for storing passwords in a hashed form, \eg using PBKDF2 \cite{rfc2898,nist800} or bcrypt \cite{ProvosM99}, with a random salt\footnote{The randomness used in password hashing is commonly called \emph{salt}.} to protect against server compromise or re-use attacks, there have been many known cases, \eg \cite{rockyouBreach,msBreach,cupidBreach}, where passwords have been stored in clear and compromised subsequently.
The ultimate goal, therefore, is to avoid trusting servers with secure processing and storage of user passwords.
% In order to offer better protection against compromised password databases servers are supposed to store only the randomised password hash and the random salt that was used.
% As mentioned previously however, the increasing number of successful password leaks suggest that many servers fail to protect passwords, which nullifies the potential of \ac{VPAKE}.
% For this reason, remote password registration should ideally be performed without the need for the client to send its password to the server; in other words, without trusting the server to securely process and store client passwords.
% The ultimate goal, therefore, is to avoid trusting servers with secure processing and storage of user passwords.
This goal imposes two main challenges:
(1) in the registration phase users must be able to choose passwords and prove their policy compliance to a remote server without actually transmitting their passwords, and 
(2) after the registration phase users must be able to authenticate themselves to the server using their passwords without transmitting them.
The first challenge of registering password verifiers while maintaining the server's ability to check their policy compliance has not been solved yet and is part of the contribution of this thesis (cf. Chapter \ref{ch:vpake} Section \ref{sec:bpr}).
% When the server stores a password verifier instead of the actual password the client authenticates itself with the password whereas the server uses stored password hash and salt to perform the check.
% This resembles the concept of \ac{VPAKE} (cf. Section \ref{sec:intro:verifier-basedPAKE}).


% *****************************************************************************
% Section: Password-Based Authentication and Key Exchange
% *****************************************************************************

\section{Cryptographic Password Authentication}\label{sec:intro:pake}
In this section we give a broad overview on password-based authentication and key exchange protocols found in literature.
We start with the most popular protocol \emph{\ac{PAKE}} before investigating more specialised protocol classes like threshold and group \ac{PAKE}.

%********************************** %PAKE  **************************************
\subsection{Password-Based Authenticated Key Exchange}
The notion of \emph{\ac{PAKE}} was introduced by \citet{bellovin92} and corresponding security models were initially developed by \citet{Bellare2000}, \citet{Boyko2000}, and \citet{Goldreich01}.
The first and maybe best known \ac{PAKE} protocols include SPEKE by \citet{Jablon96} and EKE by \citet{bellovin92}, proven secure by \citet{Bellare2000}.
Until now, numerous subsequent work explored the notion of \ac{PAKE} in depth.
\ac{PAKE} allows two parties, holding low-entropy keys, to negotiate a common authenticated session key.
Despite the key exchange functionality it authenticates the two parties explicitly or implicitly.
They aim to protect against offline dictionary attacks but require restrictions on the number of failed password trials as all password-based protocols in order to preserve security against online dictionary attacks.
In particular, security models aim at \ac{AKE}-security introduced by \citet{Bellare1993} and \citet{Bellare1995}.
One of the most promising applications of \ac{PAKE} protocols is the online authentication of users.
It is considered a more secure alternative to the nowadays mainly deployed approach of password-over-\ac{HTML}, \ie transmitting the password over a secure channel (\ac{HTTPS}) and let the server perform a check against a stored credential.
The standard model of \ac{PAKE} does not require any \ac{PKI}, which is necessary for the secure \ac{TLS} channel, and assumes that only a low-entropy secret, \ie a human memorable password, is shared between both parties.
% \footnote{Please note that this applies only for the authentication process \emph{not} for the registration process.
% There is no mechanism to store the password on the server without sending it there in a secure way.
% This is the key distribution problem, implicit to all symmetric key protocols.}
Thereby, \ac{PAKE} protocols solve the problem of potential password leakage, inherent to the approach based on secure channels.

In general, all \ac{PAKE} models (see~\citet{Pointcheval2012} for a recent overview) take into account unavoidable online dictionary attacks and aim to guarantee security against offline dictionary attacks.
While many \ac{PAKE} constructions require a constant number of communication rounds (\citet{KatzOY01,Gennaro2003,Abdalla2005,Gennaro2008,Katz2009a,Katz2011,AbdallaBP14a}); recent frameworks by \citet{Katz2011} and \citet{Benhamouda2013} offer optimal one-round \ac{PAKE}.

In addition to the aforementioned approaches that are tailored to the password-based setting there exist several more general authentication and key exchange frameworks such as the ones proposed by \citet{Camenisch2010} and \citet{Blazy2012} that also lend themselves to the constructions of (somewhat less practical) \ac{PAKE} protocols.

Like key exchange protocols with high entropy secrets, \ac{PAKE} protocols can be modelled in one of the following general settings.

\subsubsection{Game-Based PAKE-Security}
The original game-based \ac{PAKE} models in \citet{Bellare2000} (denoted \ac{BPR-M} here) and \citet{Boyko2000} specify the \ac{FtG} approach where the semantic security of the session key is considered with respect to one particular session, referred to as a \emph{test session}, determined by the adversary through one call to a \Test oracle.
(Semantic security states that no \ac{PPT} adversary exists that has non-negligible probability of winning the experiment, in this case the \ac{PAKE} experiment.)
The adversary has furthermore access to oracles that allow him to eavesdrop on protocol executions, take active part in executions and corrupt protocol participants to retrieve private information from a party.
\citet{Abdalla2005} proposed the stronger notion in the \ac{RoR} setting to model semantic security of PAKE protocols by allowing polynomially-many queries to the \Test oracle.
They showed not only that their \ac{RoR} approach leads to stronger security but were also able to simplify the model by removing the reveal oracle.
The models in~\citet{Bellare2000} and \citet{Abdalla2005} remain the most popular game-based PAKE models, adopted in the analysis of many protocols, including the random oracle-based protocols by \citet{Abdalla2006} and \citet{Abdalla2005b} and protocols requiring a \ac{CRS} (\citet{KatzOY01,Gennaro2003,Gennaro2008,Katz2009a}).

%TODO move
% by removing the \Reveal oracle that provides the adversary with established session keys.
%The adversary in~\cite{Abdalla2005} is thus left with access to the \Test oracle, the \Execute oracle that models passive attacks, and the \Send oracle accounting for active attacks.

\paragraph{\acl{FtG}}
The term \acl{FtG} goes back to \citet{Bellare97} whose definition of \ac{FtG}-security for symmetric encryption is based on work by \citet{Goldwasser84} and \citet{Micali86}.
In this thesis we focus on password-based cryptography where one of the first formal models for \ac{PAKE}, proposed by \citet{Bellare2000}, employs the \ac{FtG} approach.
The security requirement there is that an adversary must not be able to decide whether a given bit-string is the real key computed by honest parties performing the protocol, or a random element of the same length.
The adversary has only one approach to retrieve such a test key.

\paragraph{\acl{RoR}}
The term \acl{RoR} has been introduced by \citet{Bellare97} in a different context and a different meaning.
The notion of \ac{RoR} in the context of \acl{AKE} protocols has been introduced by \citet{Abdalla2005} to strengthen and simplify the \ac{FtG} approach used in the original \ac{BPR-M} model towards the \ac{RoR} approach.
In the \ac{AKE} context \ac{RoR} allows the adversary to query \emph{multiple} keys before deciding whether all of them have been computed by honest parties performing the protocol, or all of them  have been randomly chosen from the key space.

\subsubsection{Simulation-Based PAKE-Security}
Simultaneously with the first game-based models by \citet{Bellare2000} and \citet{Boyko2000}, the first simulation-based \ac{PAKE} model has been proposed by \citet{Goldreich01}.
Their work also comprises the first (and until now the only, but fairly inefficient) \ac{PAKE} protocol that is built from general secure multi-party computation techniques but does not require any setup assumptions nor random oracles.\footnote{The work by \citet{Goldreich01} is concerned with the general possibility of such a protocol rather than building a practical one.}
The protocol has been subsequently simplified at the cost of weakened security by \citet{NguyenV04}.
While the model from \citet{Goldreich01} is hardly used in the analysis of \ac{PAKE} protocols, a stronger simulation-based model in the framework of \acl{UC} by  \citet{Canetti2001a} has later been proposed by \citet{Canetti2005}.
In contrast to game-based \ac{PAKE} protocols, \ac{UC}-secure protocols require setup assumptions \cite{Canetti2005}, with \ac{CRS} being the most popular one~\cite{Katz2011}, albeit ideal ciphers / random oracles~\cite{Abdalla2008} and stronger hardware-based assumptions~\cite{cryptoeprint:2012:537} have also been used.
The most recent and most efficient \ac{PAKE} protocols are proven secure in the \ac{UC}-framework \cite{Benhamouda2013,AbdallaBBCP13,AbdallaBP14a,AbdallaBP15}.

%********************************** %VPAKE  **************************************
\subsection{Verifier-based Password Authenticated Key Exchange}\label{sec:intro:verifier-basedPAKE}

A challenge intrinsic to all \ac{PAKE} protocols is the issue of \emph{server compromise}.
It has been mentioned from the first PAKE protocols by \citet{BellovinM93} (augmented EKE) describing the threats arising from stolen password databases.
Servers store passwords in databases to retrieve them when necessary.
In order to offer better protection against password database compromise servers are supposed to store only the randomised password hash and the random salt that was used.
\citet{BellovinM93} first described how password authenticated key-exchange can be performed while the server stores only a verifier of the actual password.
The idea sketched by \citet{BellovinM93} resembles the concept of \ac{VPAKE}.
This concept is also known as asymmetric \cite{Bellare2000} or augmented \ac{PAKE} \cite{BellovinM93}.
% In \ac{VPAKE} protocols the client authenticates itself with the password whereas the server uses a password hash and salt to perform the check.
While this might sound compelling, the research community never picked up on \ac{VPAKE} with only few works considering this protocol class \cite{Wu1998,Gentry2006,Boyen2009a,BenhamoudaP13}.
\citet{Gentry2006} propose a way of transforming \ac{PAKE} protocols into \ac{UC}-secure \ac{VPAKE} protocols.
\citet{BenhamoudaP13} recently proposed the first game-based security model, based on the well known BPR model for \ac{PAKE} protocols.
% The fact that passwords require protection on the server that stores them is unquestionable.
% Different approaches have been proposed to mitigate the impact of server compromises.
% Two-server \ac{PAKE} protocols are another possibility to tackle server compromise and malicious servers.
% As discussed earlier however, an increasing number of successful password leaks suggest that many servers do not apply randomised password hashing at all. 
% Even though salted hashing of passwords is more or less standard, leakage of password databases is a big security risk.

% A large number of break-ins into server databases makes \ac{VPAKE} a particularly valuable concept for remote password-based authentication since in order to recover the actual client password the attacker must perform a costly dictionary attack on its password hash.
% Increasing number of successful password leaks~\cite{rockyouBreach,cupidBreach,adobeBreach} suggests however that many servers do not apply randomised password hashing at all. 
% \mynote{check password leak references}


% The body of research on \ac{VPAKE} is rather limited.


\subsubsection{On Rainbow Tables}
The reason for protecting passwords on a server is rather simple.
Computing a verifier from a password using only a one-way function allows an attacker to precompute a list of verifiers such that inverting the one-way function can be performed rather efficiently considering human password choice.
Those lists that can further be shared and re-used are commonly called \emph{rainbow tables}.
Note that actual rainbow tables usually build hash chains to reduce their size.
We refrain from further description of rainbow table as they are out of scope of this thesis.
Adding a small amount of true randomness to the input of the one-way function alleviates these attacks as rainbow tables for all possible random values would have to be created, which leads to a time/memory trade-off up to a point where storing those tables becomes inefficient.
This additional randomness is commonly referred to as \emph{salt}.

\subsubsection{Discussion}\label{sec:intro:vpake-discusion}
One reason for the relatively limited interest in \acl{VPAKE} might be the somewhat questionable security benefits of \ac{VPAKE}, depending on its definition.
Security models for \ac{PAKE} protocols consider security of a key-exchange protocol using a password as authentication mechanism.
Often however, they do \emph{not} consider any malicious server or attacker that tries to steal the authentication information, i.e. the password.
\ac{VPAKE} security models try to capture whether the protocol is secure (in the sense of \acl{PAKE}) \emph{and} if the server securely handles and stores the passwords/verifiers.
Since those security goals are significantly different and somewhat unrelated, it is difficult to find a meaningful security model for it.
Instead of checking the hardness of retrieving the actual password from a password hash it might be for example more interesting to model whether an attacker is able to use the password verifier as authentication credential directly (as is the case for na{\"i}ve \ac{VPAKE} constructions such as the discussed tSoke, see Section \ref{sec:tsoke} in Chapter \ref{ch:prelims}).

Another reason for low adoption rate of \ac{VPAKE} in the research community could be its questionable benefit considering efficiency of password cracking tools.
Nonetheless, \ac{VPAKE} is an interesting primitive that deserves more investigation because it gives stronger security guarantees than \ac{PAKE} and models a real-world need where servers store only password verifiers.
% While it is arguably that secure handling and storage of passwords is important, \ac{VPAKE} offers little benefit compared to \ac{PAKE}.
% Since necessary randomness has to be stored on the server (recall that the client is stateless and can only handle human memorable secrets), it has to be transferred to the client at some point in the protocol.
% However, when the randomness has to be transmitted from the server to the client, there is no reason not to do this as early in the protocol as possible and then use the verifier for authentication rather than the password in a common \ac{PAKE} protocol.


%********************************** %TPAKE and 2PAKE  **************************************
\subsection{Threshold and Two-Server PAKE}
Two-server PAKE protocols such as the one proposed by \citet{Abdalla2005} and general threshold \ac{PAKE} protocols \cite{MacKenzieSJ02,RaimondoG03,Abdalla2005b} tackle the problem of server compromise and malicious servers in a different way than \ac{VPAKE}.
They share the client's password amongst two or more servers that then jointly authenticate the client.
By splitting the password a malicious or compromised server can only recover a password share that does not allow to recover the password.
In contrast to \ac{PAKE} protocols two-server and threshold \ac{PAKE} protocols are less well studied.

\subsubsection{Threshold PAKE}
\citet{FordK00} first suggested to split the client's password among multiple servers to protect against server compromise.
\citet{RaimondoG03} and \citet{MacKenzieSJ02} were the first to propose t-out-of-n threshold \ac{PAKE} protocols, where the protocol remains secure as long as $t$ out of $n$ servers, participating in the protocol and holding a password share, are honest.
But not all of them, such as the protocol from \citet{MacKenzieSJ02} are password-only and they require additional cryptography such as a \ac{PKI} in addition to the password.

\subsubsection{Two-Server PAKE}
\ac{2PAKE} can be seen as a special case of threshold PAKE for $t=n=2$.
Compared to  general threshold \ac{PAKE}, \ac{2PAKE} is deemed more practical requiring only two participating servers.
In case of a server compromise, password change notifications can be sent to users.
Threshold \ac{PAKE} protocols are not necessarily \ac{2PAKE} protocols.
The threshold \ac{PAKE} from \citet{RaimondoG03} for example requires $t<n/3$ such that it can not be modified to a \ac{2PAKE} protocol.
The first real \ac{2PAKE} protocol is due to \citet{BrainardJKS03}, which was proven secure by \citet{SzydloK05} in a modified version.
The first and only \ac{2PAKE} with thorough security model based on the popular game-based \ac{BPR-M} model is due to \citet{Katz2012a}.

%********************************** %Other PAKE protocols  **************************************
\subsection{Other Password Authenticated Protocols} \label{sec:other-pake}
Besides the client-server authentication and key-exchange scenario, there exist several others in the password-based authentication setting we briefly discuss in the following.

\paragraph{Tag-based Password Authentication}
While \ac{PAKE} is the most popular password-based authentication protocol in cryptography research, it is often sufficient to perform authentication without key exchange.
To this end \citet{Manulis2014} introduced \ac{tPAuth} that essentially strips a \ac{PAKE} protocol of its key exchange phase and performs mutual authentication instead.
The additional tag allows to use \ac{tPAuth} protocols to be used in \ac{PACCE} protocols, which is useful when performing password-based authentication on top of an already confidential channel.
\ac{PACCE} allows to bind a confidential channel to a password-based authentication protocol and thus authenticate the confidential channel using the password.
This provides an alternative to using the session key output by a \ac{PAKE} protocol to create a confidential and authenticated channel.

\paragraph{Three-Party Password Authenticated Key Exchange}
The three-party setting (3\ac{PAKE}) considers two humans who want to securely communicate with each other.
Since sharing passwords with everyone else is not practical, a trusted server (the third party) comes into play.
Thus, the users have to share only one password with the trusted sever, which assists in the three-party protocol between the two users.
The first three-party security model is due to \citet{Abdalla2005}.
Subsequent works \cite{CliffTB06,Yoneyama08,TsaiC13} propose further protocols and improved security models.

\paragraph{Group Password Authenticated Key Exchange}
Password authenticated group key exchange is another popular protocol, extending two-party \ac{PAKE} to the group setting.
Authenticated group key exchange protocols allow a \emph{group} of parties to negotiate a session key.
One way to achieve group \ac{PAKE} is to use general group key exchange protocols and modify them for the password setting as proposed by \citet{Bresson02,BrChPo05}.
%However, this usually yields rather inefficient protocols.
Similar to \ac{PAKE}, group \ac{PAKE} enjoys a large body of research papers \cite{Kim2004,Abdalla2006,Bohli2006,Dutta2006,AbdallaP06,AbdallaBVS07,AbdallaCCP09,AbdallaCGP11,hao2015fairy}.

\paragraph{Multi-Factor Authenticated Key Exchange}
As mentioned before, using passwords is only one possible authentication mechanism for humans.
Combining several authentication techniques leads to \emph{multi-factor} authentication protocols.
The most commonly used reference for (multi-factor) authentication is the aforementioned \ac{NIST} standard \cite{Burr11} that defines four security levels for authentication.
Starting from level three at least two authentication factors are necessary.
Research in the area of multi-factor authentication \cite{PointchevalZ08,SUC10,LiuWM10,HaoC12} proposes protocols and security models for two-party and three-party scenarios.

\paragraph{Password Protected Secret Sharing}
The notion of \acl{PPSS} was recently introduced by \citet{Bagherzandi2011} (improved by \citet{JareckiKK14}).
It allows to share a secret such as a symmetric key, among multiple servers, protected by a password. 
A security model in the \ac{UC} framework was proposed later by \citet{Camenisch2012} (enhanced to resist malicious servers by \citet{CamenischLLN14} and transient corruptions by \citet{CamenischEN15}).
\ac{PPSS} has many interesting applications such as secure remote storage, an increasingly important use-case.
A similar notion called \emph{hidden credential retrieval} using only a single server has been introduced by \citet{Boyen09} to allow users with knowledge of a password to store high-entropy messages securely on a server.


% *****************************************************************************
% Section: Passwords and TLS
% *****************************************************************************
\section{Real World Architectures and Challenges}\label{sec:intro:real-world}
As discussed in the beginning, the scenario where cryptographic password-based authentication protocols are most needed is user login on the Internet.
However, due to the Internet's architecture the use of protocols like \ac{PAKE} on the internet involves several challenges.
To understand the challenges one first has to understand how \ac{HTTPS} and thus \ac{TLS} works.

\ac{TLS} is, in its current version $1.2$ \cite{rfc5246,rfc6176,rfc4492}, the successor of the \ac{SSL} protocol \cite{rfc6101}, a suite of cryptographic protocols for secure and authenticated communication.
It is standardised by the \ac{IETF} (\url{https://www.ietf.org/}) and, while called \emph{transport layer} security, is implemented on the presentation layer and is initialised on the session layer.
In order to secure network traffic however, it can be seen as the transport layer while all lower layers only transport the encrypted content.
When accessing a website via \ac{HTTPS} a \ac{TLS} session is first established between the client and the server (authenticated by the server's public key, usually wrapped in an X.509 certificate \cite{rfc5280}), which is then used to transport the content via \ac{HTTP}.
Thus, when the user is presented with a website to log on, the secure channel has been established already such that executing a \ac{PAKE} protocol for authentication and subsequent exchange of \ac{TLS} keys with the newly created key from the \ac{PAKE} protocol is rather impractical (and not supported by any common browser).
The place to use \ac{PAKE} is actually \emph{before} the \ac{TLS} channels is set up, such that it can be used as key exchange in the \ac{TLS} handshake protocol.
This approach has been followed by \citet{rfc5054}, which uses the Secure Remote Password (SRP) protocol by \citet{Wu98} and is implemented in major \ac{TLS} implementations such as OpenSSL (\url{https://www.openssl.org/}).
The problem with such an approach however is that it requires the user to login before the actual website is sent, besides other problems, including the logout problem.
Most problems are transferable from the scenario where clients use X.509 certificates for authentication to the case where the client uses a password for authentication.
See \citet{Parsovs14} for a discussion of these problems.

Real world implementations of multi-factor authentication protocols include the popular Google authenticator \cite{GAuthenticator} amongst others.
However, implementations usually combine only passwords with \acp{OTP} or push notifications.
Using biometric factors is rarely seen in practice so far.

Looking at the current state of the Internet and the used tools and protocols it is simply not reasonable to use \ac{PAKE} as \ac{TLS} authentication.
The challenge is therefore to deploy cryptographic password-based authentication on top of \ac{TLS}, \ie on the application level, in order to secure user logins on the Internet.
While this might sound straight-forward, one has to consider that executing for example \ac{PAKE} with mutual authentication via an \ac{HTTPS} channel does \emph{not} necessarily yield an authenticated and confidential channel between client and server, depending on the composition of the \ac{TLS} and \ac{PAKE} protocols.
In particular, the security guarantees in the case where the \ac{TLS} session keys are \emph{not} replaced with the \ac{PAKE} keys are not clear.
To achieve security in this case the password-based authentication protocol has to be bound to the \ac{TLS} channel by other means.
This has been recently achieved by \citet{MSD13} by introducing \ac{PACCE} on top of \ac{TLS}.


% *****************************************************************************
% Section: Outline & Summary
% *****************************************************************************
\section{Outline \& Summary of Results}\label{sec:intro:outline}
This thesis consists of four more chapters.
Chapter \ref{ch:prelims} gives prerequisites and building blocks used throughout this work.
The remainder of the work consists of the two main Chapters \ref{ch:vpake} and \ref{ch:2pake} before concluding the work in Chapter \ref{ch:conclusion}.

Chapter \ref{ch:vpake} describes a framework for password registration and authentication.
It comprises the first two password registration protocols with security models that allow to register passwords in a \emph{blind} way that does not reveal the password to the server but only transmits and stores a verifier.
While being blind, the registration protocols allow the server to impose rules on password strength.
In particular, the server can verify a password policy on the password that corresponds to the registered verifier.
To use the registered verifier a new password-based authentication protocol in the verifier-based setting is proposed.
The proposed protocols were implemented to compare performance of the protocols in addition to their security.
To demonstrate practicability of the framework, we further give a demo that shows how a real-world deployment of could look like.
The demo consists of a server necessary to perform registration and authentication, a corresponding client application implemented as Firefox extension, and an application that is accessed after logging in.

Chapter \ref{ch:2pake} describes a framework similar to the one from Chapter \ref{ch:vpake} but for the two-server setting.
In particular, it proposes a password registration protocol for the two-server setting with an according security model.
While being similar to the single-server setting, this involves additional challenges as no single server retrieves an element that is able to verify the client's password on its own.
The focus in this chapter however is on \ac{2PAKE}.
It proposes in particular a new framework for \ac{2PAKE} using the new notion of \ac{D-SPHF} that distributes computation of \acp{SPHF} between the two servers.
Building on \ac{D-SPHF} and the proposed \ac{2PAKE} framework allows us to propose a new \ac{2PAKE} protocol that is secure in the newly proposed security definition for \ac{2PAKE} in the \ac{UC} framework.
% Chapter \ref{ch:realworld} extends \cite{MSD13} and depicts solutions on how to bring cryptographic password authentication to the web on desktop and mobile browsers.
% Eventually, the thesis is concluded in Chapter \ref{ch:conclusion} summarising results described in the thesis and giving an outlook to potential future work.



% %********************************** %Related Work  **************************************
% \section{Related Work}
% 
% %********************************** %Multi-Server PAKE  **************************************
% \subsection{Multi-Party Password Authenticated Key Exchange}
% \mynote{literature review/related work section}
% 
% \subsubsection{Threshold PAKE}
% 
% \subsubsection{Two-Server PAKE}
