%*******************************************************************************
%*********************************** First Chapter *****************************
%*******************************************************************************

\chapter{Introduction}  %Title of the First Chapter

\ifpdf
    \graphicspath{{Chapters/Figs/Raster/}{Chapters/Figs/PDF/}{Chapters/Figs/}}
\else
    \graphicspath{{Chapters/Figs/Vector/}{Chapters/Figs/}}
\fi

% \section{Setting things into perspective}
This work is concerned with cryptography from low-entropy secrets, better known as \emph{passwords}.
In contrast to conventional cryptographic algorithms and protocols, secrets used here have low-entropy here, such that an adversary is able to iterate through all possible secrets in reasonable time.
This leads directly to the inherent threat to everything we are dealing with in this work: so-called dictionary attacks (cf. Section \ref{sec:introdictionaryattacks}).
So why do we want to perform cryptography with passwords at all, when they comprise intrinsic attack possibilities?

\begin{quote}
``Humans are incapable of securely storing high-quality cryptographic keys, and they have unacceptable speed and accuracy when performing cryptographic operations.''~\citet{Kaufmann02}
\end{quote}

\noindent
We do not care about humans lack of speed and accuracy in performing cryptographic operations in this work.
But their inability to remember high-quality cryptographic keys is a major problem.
Even though there exist several standardised authentication tokens for humans, we heavily rely on passwords.
In general we distinguish between three major categories of authentication data \cite{Burr11}:
\begin{itemize}
	\item Something you know (\eg password, \ac{PIN})
	\item Something you have (\eg mobile phone, cryptographic key)
	\item Something you are (\eg fingerprint)
\end{itemize}
But since everything someone has or is may be stolen or duplicated, knowledge (of a password) is a very important factor in authenticating a human (as long as he does not write down his passwords).
To perform cryptography with humans entering a secret, those have to be human-memorable.
This leads to the necessity of password-based cryptography as everything humans are able to remember correctly is rather short and has not much entropy.

% *****************************************************************************
% Password Based Cryptography
% *****************************************************************************

\section{Password Based Security}
Using passwords as means of authentication in a computer system allows users to log into the system without the need for any additional devices or tools.
This huge advantage over other ways of authenticating, i.e. with something you have or are, is responsible for passwords being the most popular authentication mechanism and is likely to stay such despite increasing efforts to changes this (cf. Section \ref{sec:enhanced-login}).
The most common place where passwords are used as user authentication mechanism is the Internet where personal content is protected with a username and password.
Only when providing a valid identifier (username, often e-mail address) and the according password that the server stored for this identifier the client is allowed to access data associated with this account.
The password and identifier are usually chosen by the client when registering the new account.
When people forget their passwords or want to change it, websites offer the possibility to change the password for an account after providing the old password or other means of authentication (often done by sending a one-time link to the registered e-mail address).

While passwords are also used in other contexts such as device logins, we focus on the online remote setting in this thesis.
We look in particular at the previously described scenario of registering user accounts that use password authentication for login purposes.
The used setting therefore contains a \emph{client} (controlled by the human user) that interacts with a remote \emph{server} controlling the client's account.

Password based protocols are usually classified as symmetric because both parties hold the same secret (password).
In contrast to other cryptographic mechanisms where \emph{keys} are chosen from a \emph{key space}, \emph{passwords} are chosen from a \emph{dictionary}.
Note that dictionaries in our case denote sets of characters rather than \emph{real} lexicon like dictionaries.
When talking about those we use the term \emph{lexicon}.
Even though password is the umbrella term, we distinguish between several types of passwords, we discuss in the following.

\paragraph{Password}
The term \emph{password} usually refers to character strings chosen from a dictionary consisting of alpha-numeric characters \texttt{a-z}, \texttt{A-Z}, \texttt{0-9} and special characters like \texttt{\$,\%,@} and so on.
While \acs{UTF-8} based passwords or passwords based on other character encodings are possible we focus on \acs{ASCII} based passwords in this thesis for convenience.
Despite the fact that many (online) services have password policies in place, humans tend to choose easily memorable and therefore mainly easy to guess passwords that can be found in a lexicon \cite{Florencio2007,Gaw2006}.
To encourage users to use stronger passwords, password-strength meters are used by many services.
A recent study \cite{Ur2012} on password-strength meters shows that this could have a significant impact on user's password-strength.
We define several other forms of user authentication that are similar to passwords in the following.
Note however that those terms are usually not used in cryptographic research and this thesis sticks with this definition of passwords as well.

\paragraph{Graphical Passwords}
Graphical passwords where first proposed by \citet{Blonder96} with Microsoft Window's picture passwords \cite{picturepwd1,picturepwd2} being the most well known implementation.
Instead of relying on entropy in a character password, graphical passwords require the user to recognise certain images or features in an image.
The security usually stems from the ability of humans to reliably recognise pictures and small features inside pictures whereas algorithms struggle to do so.

\paragraph{Passphrase}
Passphrases are very similar to passwords in the sense that they are character strings.
But instead of using relatively short words with characters from a big character set in order to reach security, passphrases are longer and generate their strength from length over a rather small character set.

\paragraph{\acl{PIN}}
\acp{PIN} are rather short passwords, chosen from the numeric dictionary containing numbers \texttt{0-9}.
They are mainly used to secure access to the actual authentication token like credit card or other smart cards.
Since the card is a second authentication factor (\emph{something you have}), a short \ac{PIN} is sufficient to reach reasonable security.
The smaller dictionary containing only numbers is most presumable due to practical restrictions on the input device, used to enter the \ac{PIN}.

\paragraph{\acl{OTP}}
While most passwords are meant to be memorised by humans, \acp{OTP} are used only once and therefore don not have to be memorised.
They are mainly chosen from the numeric dictionary \texttt{0-9}.
\acp{OTP} have become more popular recently as a second factor, in addition to the ``regular'' password, in two-factor authentication, \eg Google \cite{Google2Factor}, Facebook \cite{FB2Factor}, Twitter \cite{Twitter2Factor} and GitHub \cite{Github2Factor}.
The most popular standards for \ac{OTP} that are implemented in the Google Authenticator App \cite{GAuthenticator} for example, are the \acs{HMAC} based algorithm specified in RFC 4226 \cite{rfc4226} and the time based algorithm specified in RFC 6238 \cite{rfc6238}.

\paragraph{\acl{TAN}}
\acp{TAN} are special \acp{OTP} mainly used to authorise single financial transactions in online banking applications.
These, mainly short passwords, are usually drawn from the numeric dictionary containing numbers \texttt{0-9}.
They can be seen as transaction bound \acp{OTP}.

% *****************************************************************************
% The inherent Threat of Dictionary Attacks
% *****************************************************************************

\subsection{The inherent Threat of Dictionary Attacks}\label{sec:introdictionaryattacks}
As mentioned already, most cryptographic mechanisms use high-en-tropy secrets such that it is impossible for anyone (any algorithm) to traverse all possible secrets from the particular secret space in reasonable time.
Password based schemes in contrast assume low-entropy secrets that are drawn from a polynomial sized dictionary.
Therefore, it is feasible for a program to walk through the entire dictionary and just try every possible secret (password).
This kind of attack, \emph{dictionary attack}, is inherent to any password based algorithm and is therefore one of the main challenges in password-based cryptography compared to mechanisms on high-entropy secrets.

Due to poorly chosen passwords it is often sufficient to perform a lexicon attack that traverses only a relatively small dictionary containing for example words of the English language instead of a brute force dictionary attack that iterates the entire dictionary.

\paragraph{Poorly Chosen Passwords}
While dictionary attacks are unavoidable, poorly chosen passwords worsen the situation.
By choosing passwords that are available in lexicons or easy to derive from other parameters like the public e-mail address, the search space for brute-force attacks gets significantly smaller.
Password cracking programs like \emph{John the Ripper} \cite{JohnTheRipper} gather lexicons of different languages in password lists \cite{JohnTheRipperWordlist}.
Not only language lexicons can be used for brute-force attacks on passwords, but password lists of often used passwords that got somehow leaked.
Using for example a list with the most used passwords (\eg \cite{XatoPwds}), brute-force attacks on online accounts may be performed very efficiently.

% *****************************************************************************
% The Real World
% *****************************************************************************

\subsection{Passwords in The Real World}
Systems currently deployed on the Internet use the approach of \emph{password-over-HTML} --- sending the password over an encrypted channel (TLS) to the server for verification or registration --- which is risky due to the threat of disclosing user credentials to malicious parties via a plethora of attacks, \eg phishing attacks or \ac{MitM} attacks.
Even though a confidential \ac{HTTPS} connection --- \ac{HTTP} over a \ac{TLS}-encrypted connection --- is often used to transport sensitive data such as passwords, the server authentication of the underlying \ac{TLS} protocol depends on the user actually validating the server's certificate, the accessed \ac{URL}, and trust in a properly working \ac{PKI}.
(This includes sophisticated and government aided attacks.)

\subsubsection{Enhanced User Login} \label{sec:enhanced-login}
As discussed previously humans are hardly able to remember high-entropy secrets.
But even remembering short passwords seems complicated in many cases such that users re-use their passwords and choose them from lexicons to simplify the process of recalling.
To simplify the user login process many technical solutions are in use of which some require passwords and others do not.
This work is not primarily concerned with these technical aspects but as we reassemble them in some cases we give a brief overview on what is out there.
Those mechanisms either avoid the process of logging onto a website at all, automate it as far as possible, or enhance security by adding additional authentication factors to the password.
The former is achieved by \ac{SSO} services such as Kerberos \cite{rfc4120} OpenID \cite{OpenID} or OAuth \cite{rfc6749}.
The latter is done by using password managers in combination with auto completion implementations that store login information for websites and fill the forms automatically.
Enhancements to password-based logins such as multi-factor authentication \cite{FleischhackerMA14} exist where multiple authentication mechanisms are combined.
Popular implementations of this paradigm use the two factors \ac{OTP} and password \cite{Google2Factor,FB2Factor,Twitter2Factor,Github2Factor}.


\subsection{On Password Security Research}
Security research on passwords looking at topics such as how to measure password strength, how to securely hash and store passwords, or how to encrypt using a password, holds an excessive body of works.
Since this thesis is primarily concerned with cryptographic treatment of passwords and therefore uses idealised assumptions we give only a brief introduction into these research fields and give links to our research.

\paragraph{Password Strength}
One of the most difficult topics in password research is the question of how to measure the strength of a password.
While cryptography research usually assumes uniform or some other idealised distribution of passwords, this is clearly not the case in reality with humans choosing them.
Measuring password strength is a rather non technical research are and focuses on user studies and analysis of password database leaks \cite{ShayKKLMBCC10,KomanduriSKMBCCE11,MazurekKVBCCKSU13} in order to come up with a good model to predict min-entropy of passwords.
Entropy can capture many realistic password creation models and definitions of password entropy have been standardised by NIST \cite{nist800}.
However, although min-entropy seems a reasonable measure for modelling dictionary attack resistance of we stress that min-entropy alone might not be sufficient to estimate the real password strength. 
As shown in \cite{MazurekKVBCCKSU13}, password strength is a complex matter (due to a variety of real-world attacks) and can hardly be captured through a single metric like min-entropy.

\paragraph{Password Hashing and Storage}
In order to securely store passwords or use them for encryption hashing them in some form is essential to make brute-force attacks on them more costly.
The current state of the art password hashing schemes are the \ac{PBKDF2} \cite{rfc2898}, bcrypt \cite{ProvosM99}, and scrypt \cite{rfcScrypt}.
This very limited number of possible password hashing schemes should be resolved by the currently running password hashing competition (\url{https://password-hashing.net}).
Other more technical means to avoid stealing stored passwords is to hide them in a huge amount of data that makes it impossible to steal without being detected (a recent new implementation is given by Taplink \url{https://taplink.co/technology/}).


\subsection{Password based Cryptography}
Cryptography research in the area of passwords focuses mainly only \ac{PAKE} protocols and recently \ac{PPSS}.
\ac{PAKE} allows to exchange an authenticated session key between two parties holding a common password for authentication.
In contrast to other authenticated key exchange protocols \ac{PAKE} has to consider dictionary attacks, \ie that an attacker is always able to run the protocol often enough with the server in order to eventually successfully authenticate.
The recent development of \ac{PPSS} moves away from key exchange and tackles the problem of secure online storage that is secured with the users password.
In order to achieve high security, data stored online should be encrypted with common mechanisms such as \ac{AES}.
However, to access the data, users would have to store that key.
The solution proposed by \ac{PPSS} allows to split the key in shares that are stored at different servers and can only be retrieved if the user successfully authenticates itself to the two servers with the correct password.

\mynote{comprehensible overview of references can be found at \url{https://franziskuskiefer.github.io/CryptoPapers/passwords.html}}

\paragraph{Strong Cryptography from Low-Entropy Secrets}
Despite authentication and key exchange, passwords are used in other contexts such as general strong cryptography.
Due to the low-entropy of passwords this obviously introduces additional challenges.
\citet{AbdallaBCP09} show how to build strong cryptography from weak secrets.
In particular, they propose a method to perform distributed public key cryptography when each party holds only a password, based on the \acl{DDH} assumption.
\citet{BoyenCFP10} extend the notion to the pairing world.


% *****************************************************************************
% Section: On Provable Security
% *****************************************************************************

\section{On Provable Security}
We briefly discuss general security models used in the field of provable security as well as other means of establishing confidence in the security of an algorithm.
More specialised methods used in password-based cryptography are analysed later.

To prove a cryptographic primitive secure, reductionist arguments are used.
Thereby, the attempt is made to reduce the security of the algorithm/protocol under consideration to a problem that is believed to be hard.\footnote{Note that this work is not concerned with the question whether specific problems are actually hard. We consider only well investigated problems, which the cryptography community beliefs to be hard.}
Thus, given a (tight) reduction from the primitive to an underlying problem, one could be confident that the primitive is secure as long as the underlying problem is actually hard to solve.
For an insightful and sceptical discussion on this kind of security verification we refer to the ``Another Look'' series by \citet{AnotherLook}.

Cryptographic primitives can only be proven secure considering the abilities of a certain adversary.
Therefore, before being able to proof anything about a cryptographic primitive it has to be modelled considering an appropriate (hostile) environment.
It always has to be kept in mind that the resulting proof is only valid within the used model.
Before further discussion we give a brief introduction to another approach to analyse security: \emph{The Formal World}.
A formal view on modelling security goes back to work throughout the 1980's \cite{DeMillo82,Dolev83,Millen87,Meadows91,Kemmerer1988,Burrows90}.
While they explore different approaches of formal modelling, the so called Dolev-Yao model \cite{Dolev83} may be the best known one.
In the formal world, everything is modelled by formal expressions rather than bit strings.
The adversary controls the entire communication channel between participating parties and can replay, modify or drop messages.
While the formal world is relatively simple, it allows only all-or-nothing  and no probability or computational statements.

\paragraph{The Computational World}
In this work at hand however we deal with a somewhat more realistic approach of modelling, the computational modelling.
The foundation of today's computational models were laid in the 1980's \cite{Goldwasser82,Goldwasser84,Yao82,Blum82}.
The computational world consists of bit-string messages and cryptographic primitives performing computations on them.
It is therefore based on complexity theory.
In this world the attacker is modelled as a \ac{PPT} Turing machine \cite{Turing37} that must not have significant success probability.
We give necessary formal definitions in Chapter \ref{ch:prelims}.

\paragraph{Reconciling the Two Worlds}
Even though efforts have been made to reconcile the two completely different approaches \cite{Abadi2002,Herzog2005}, there remain big differences in the theory as well as in their communities.
For more discussion on these two worlds we refer the interested reader to \cite{cortier2011survey}.

%********************************** %Game-based Security  **************************************
\subsection{Game-Based Security}
Game-based security models allow the (\ac{PPT}) adversaries to play a game against a challenger.
During this game (or experiment) he is allowed to query a set of \emph{oracles} to simulate and interact with the primitive or protocol under consideration.
Eventually, the adversary outputs his answer to the challenger who decides whether the adversary wins the game or not.

Oracles are black-box functions simulating parts of the protocols behaviour, the adversary can query.
On (possibly empty) input they return the result of their computation to the caller.
Thereby, oracles define an interface for the adversary to interact with the primitive.
The actual security definition and strength of the adversary therefore depends on the available oracle.

Since simple reduction proofs from a protocol to a hard problem are rare, techniques have been developed to do this step by step.
An example on game-based security proof using so called ``sequences of games'' is given by \citet{Shoup2004}.

%********************************** %Simulation-based Security  **************************************
\subsection{Simulation-Based Security}
The idea of simulation-based security proofs is due to \citet{Goldreich87}.
In contrast to the previously described game-based approach simulation-based security does not define a challenger and oracles the adversary interacts with, but an ideal functionality the actual protocol should mimic in the real world.
The adversaries goal is to distinguish between the execution in the ideal world with a perfectly secure algorithm/protocol, and the real world with the actual algorithm/protocol.
Security reasoning is then done as follows: since the ideal primitive does not leak any information other than publicly observable and its behaviour is indistinguishable from the real world, the real world primitive is secure.

\mynote{add formal stuff from \cite{Goldreich2004} (not sure where though)}

\paragraph{\acl{UC}}
The \ac{UC} framework proposed by \citet{Canetti2001a} is a popular general purpose simulation-based security model.
It overcomes an inherent shortcoming of most security models as it allows for secure arbitrary composition with other primitives once a primitive is proven secure.
Most security models only allow to derive statements about the algorithm in a shielded environment.
As soon as the algorithm is used with other primitives, and thus sharing \ac{IO} channels and data, the security can not be guaranteed anymore.
The \ac{UC} framework introduces another adversary \UCZ, the environment, that generates all inputs for all parties, and reads their outputs.
A protocol is secure in \ac{UC} when it realizes a given ideal functionality \UCF, such that for any real-world adversary \A, interacting with the protocol, there exists an ideal-world adversary \UCS, such that no environment \UCZ can decide whether it interacts with \A and the real-world protocol, or with \UCS and the ideal functionality \UCF.

% *****************************************************************************
% Section: Password Registration
% *****************************************************************************

\section{Cryptographic Password Registration}
Another important part that is often overlooked in cryptographic research is the handling of password registration.
While registration of symmetric keys is not an interesting cryptographic problem since security there has to be guaranteed by other means, password registration is more involved.
This is due to two different reasons;
First, passwords are not necessarily symmetric secrets.
In the verifier-based setting (cf. Section \ref{sec:intro:verifier-basedPAKE}) the server stores only a randomised function of the password and the randomness.
Second, passwords are not chosen uniformly at random in practice and require additional attention.
In particular, systems commonly impose password policies on passwords in order to ensure a certain entropy in the password.
This should guarantee strong passwords that withstand dictionary and brute-force attacks.

In order to offer better protection against compromised password databases servers are supposed to store only the randomised password hash and the random salt that was used.
In later sessions the client authenticates itself with the password whereas the server uses stored password hash and salt to perform the check.
This resembles the concept of \ac{VPAKE} (cf. Section \ref{sec:intro:verifier-basedPAKE}).
As mentioned previously however, the increasing number of successful password leaks suggest that many servers fail to protect passwords, which nullifies the potential of \ac{VPAKE}.
For this reason, remote password registration should ideally be performed without the need for the client to send its password to the server; in other words, without trusting the server to securely process and store client passwords.
The ultimate goal, therefore, is to avoid trusting servers with secure processing and storage of user passwords.
This goal imposes two main challenges:
(1) in the registration phase users must be able to choose passwords and prove their policy compliance to a remote server without actually transmitting their passwords, and 
(2) after the registration phase users must be able to authenticate themselves to the server using their passwords without transmitting them.
While the second challenge has been solved using \ac{VPAKE} or can be achieved using regular \ac{PAKE} as discussed in Section \ref{sec:intro:vpake-discusion}, the first challenge of registering passwords verifiers while maintaining the server's ability to check their policy compliance has not been solved yet.



% *****************************************************************************
% Section: Password Based Authentication and Key Exchange
% *****************************************************************************

\section{Cryptographic Password Authentication \& Key Exchange}
In this section we give a broad overview on password based authentication and key exchange protocols found in literature.
We start with the most popular protocol \emph{\ac{PAKE}} before investigating more specialized protocol classes like threshold \ac{PAKE} or group \ac{PAKE}.

%********************************** %PAKE  **************************************
\subsection{Password Based Authenticated Key Exchange}
The notion of \emph{\ac{PAKE}} was introduced by \citet{bellovin92} and corresponding security models were initially developed by \citet{Bellare2000}, \citet{Boyko2000}, and \citet{Goldreich01}.
The first and maybe best known \ac{PAKE} protocols include SPEKE by \citet{Jablon96} and EKE by \citet{bellovin92,Bellare2000}.
Until now, numerous subsequent work explored the notion of \acl{PAKE} in depth.
\ac{PAKE} allows two parties, holding low-entropy keys, to negotiate a common session key.
Despite the key exchange functionality it authenticates the two parties explicitly or implicitly.
They aim to protect against offline dictionary attacks but require restriction on the number of failed password trials as all password based protocols.
One of the most promising applications of \ac{PAKE} protocols is the online authentication of users.
It is considered as a more secure alternative to the nowadays mainly deployed approach of transmitting the password over a secure channel (\ac{HTTPS}) and let the server perform a check against his stored credential.
The standard model of \ac{PAKE} does not require any \ac{PKI}, which is necessary for the secure channel, and assumes that only a low-entropy secret, \ie a human memorable password, is shared between both parties.
\footnote{Please note that this applies only for the authentication process \emph{not} for the registration process.
There is no mechanism to store the password on the server without sending it there in a secure way.
This is the key distribution problem, implicit to all symmetric key protocols.}
Thereby, \ac{PAKE} protocols solve the problem of potential password leakage, inherent to the approach based on secure channels.

In general, all PAKE models (see~\citet{Pointcheval2012} for a recent overview) take into account unavoidable online dictionary attacks and aim to guarantee security against offline dictionary attacks.
While many PAKE constructions require a constant number of communication rounds (\citet{KatzOY01,Gennaro2003,Abdalla2005,Gennaro2008,Katz2009a,Katz2011}); recent frameworks by \citet{Katz2011} and \citet{Benhamouda2013} offer optimal one-round \ac{PAKE}.

In addition to the aforementioned approaches that are tailored to the password-based setting there exist several more general authentication and key exchange frameworks such as \citet{Camenisch2010} and \citet{Blazy2012} that also lend themselves to the constructions of (somewhat less practical) \ac{PAKE} protocols.
In the field of \acl{PAKE}, security models aim at \ac{AKE}-security \citet{Bellare1993} and \citet{Bellare1995} like ``common'' key exchange protocols that may be seen in one of the following general settings.

\paragraph{Game-Based \ac{PAKE}-Security}
The original game-based \ac{PAKE} models in \citet{Bellare2000} and \citet{Boyko2000} incorporate the \ac{FtG} approach where the semantic security of the session key is considered with respect to one particular session, referred to as a \emph{test session}, determined by the adversary through one call to a \Test oracle.
The adversary has furthermore access to oracles that allow him to eavesdrop on protocol executions, take actively part in executions and corrupt protocol participants.
\citet{Abdalla2005} proposed a \ac{RoR} approach to model semantic security of PAKE protocols by allowing polynomially-many queries to a \Test oracle.
They showed not only that their \ac{RoR} approach leads to stronger security but were also able to simplify the model.
The models in~\citet{Bellare2000} and \citet{Abdalla2005} remain the most popular game-based PAKE models, adopted in the analysis of many protocols, including the random oracle-based protocols by \citet{Abdalla2006} and \citet{Abdalla2005b} and protocols requiring a \ac{CRS} (\citet{KatzOY01,Gennaro2003,Gennaro2008,Katz2009a}).

%TODO move
% by removing the \Reveal oracle that provides the adversary with established session keys.
%The adversary in~\cite{Abdalla2005} is thus left with access to the \Test oracle, the \Execute oracle that models passive attacks, and the \Send oracle accounting for active attacks.

\paragraph{\acl{FtG}}
The term \acl{FtG} goes back to \citet{Bellare97} \cite{Bellare97} whose definition of \ac{FtG}-security for symmetric encryption is based on \cite{Goldwasser84} \cite{Micali86}.
In our research focus of password-based cryptography one of the first formal models for \ac{PAKE}, proposed by \citet{Bellare2000} in \cite{Bellare2000}, employs the \ac{FtG} approach.
The security requirement there is that an adversary must not be able to decide whether a given bit-string is the real key computed by honest parties performing the protocol, or a random element from the key space.
But the adversary has only one change to retrieve such a test key.

\paragraph{\acl{RoR}}
The term \acl{RoR} has been introduced by \citet{Bellare97} in \cite{Bellare97} in a different context and a different meaning.
The notion of \ac{RoR} in the context of \acl{AKE} protocols has been introduced by \citet{Abdalla2005} to strengthen and simplify the \ac{FtG} approach used in the original model from \cite{Bellare2000} towards the \ac{RoR} approach.
In the \ac{AKE} context \ac{RoR} allows the adversary to query \emph{multiple} keys before deciding whether all of them have been computed by honest parties performing the protocol, or all of tem  have been randomly chosen from the key space.

\paragraph{Simulation-Based \ac{PAKE}-Security}
Simultaneously with the first game-based models in \cite{Bellare2000,Boyko2000}, the first simulation-based \ac{PAKE} model has been proposed by \citet{Goldreich01}.
Their work also comprises the first (and until now the only, but fairly inefficient) protocol that is built from general secure multi-party computation techniques but does not require any setup assumptions nor random oracles.\footnote{The work in \cite{Goldreich01} is concerned with the general possibility of such a protocol rather than building a practical one.}
The protocol has been subsequently simplified at the cost of weakened security in~\cite{NguyenV04}.
While the model from \cite{Goldreich01} is hardly used in the analysis of \ac{PAKE} protocols, a stronger simulation-based model in the framework of \acl{UC}~\cite{Canetti2001a} has been proposed by \citet{Canetti2005} later.
In contrast to game-based \ac{PAKE} protocols, \ac{UC}-secure protocols require setup assumptions, with \ac{CRS} being the most popular one~\cite{Katz2011}, albeit ideal ciphers / random oracles~\cite{Abdalla2008} and stronger hardware-based assumptions~\cite{cryptoeprint:2012:537} have also been used.
The most recent and most efficient \ac{PAKE} protocol, secure in the \ac{UC}-framework, is due to \citet{Benhamouda2013}.

\paragraph{The Problem of Server Compromise}
A problem intrinsic to all \ac{PAKE} protocols is the issue of \emph{server compromise}.
Servers store passwords in databases to retrieve them when necessary.
Even though salted hashing of passwords is more or less standard, leakage of password databases is a big security problem.
Different approaches have been proposed to mitigate the impact of server compromises.
The server is not working with the password as input, but some other long-term secret related to the client's password \cite{Wu1998,Boyen2009a}.
\citet{Gentry2006} propose the first general technique, proven in the \ac{UC} framework, to make arbitrary \ac{PAKE} protocols secure resilient to server compromise.
Two-server \ac{PAKE} protocols are another possibility to tackle server compromise and malicious servers.

%********************************** %VPAKE  **************************************
\subsection{Verifier-based Password Authenticated Key Exchange}\label{sec:intro:verifier-basedPAKE}
The problem of server compromise has been mentioned from the first PAKE protocols by \citet{BellovinM93} (augmented EKE) describing the threats arising from stolen password databases.
\citet{BellovinM93} describe how password authenticated key-exchange can be performed while the server stores only a verifier of the actual password.
While this might sound compelling, the research community never picked up on \ac{VPAKE} as we will call it here.
The fact that passwords require protection on the server that stores them is unquestionable.
In order to offer better protection against password databases compromise servers are supposed to store only the randomised password hash and the random salt that was used.

A large number of break-ins into server databases makes \ac{VPAKE} a particularly valuable concept for remote password-based authentication since in order to recover the actual client password the attacker must perform a costly dictionary attack on its password hash.
Increasing number of successful password leaks~\cite{rockyouBreach,cupidBreach,adobeBreach} suggests however that many servers do not apply randomised password hashing at all. 

\subsubsection{On Rainbow Tables}
The reason for protecting passwords on a server are rather simple.
Computing a verifier from a password using only a one-way function allows an attacker to precompute a list of verifiers such that inverting the one-way function can be performed rather efficiently considering human password choices.
Those lists can further be shared and re-used are commonly called \emph{rainbow tables}.
Note that actual rainbow tables usually build hash chains to reduce their size.
We refrain from further description of rainbow table as they are out of scope of this thesis.
Adding a small amount of true randomness to the input of the one-way function alleviates these attacks as rainbow tables for all possible random values would have to be created, which leads to a time/memory trade-off up to a point where storing rainbow tables becomes inefficient.
This additional randomness is commonly referred to as \emph{salt}.

\subsubsection{Verifier-based PAKE --- Protocols and Models}
In \ac{VPAKE} protocols the client authenticates itself with the password whereas the server uses stored password hash and salt to perform the check.
This concept is also known as asymmetric \cite{Bellare2000} or augmented \ac{PAKE} \cite{BellovinM93}.
As mentioned before, \citet{Gentry2006} propose a way of transforming \ac{PAKE} protocols into \ac{UC}-secure \ac{VPAKE} protocols.
\citet{BenhamoudaP13} recently proposed the first game-based security model, based on the well known BPR model for \ac{PAKE} protocols.

\subsubsection{Discussion}\label{sec:intro:vpake-discusion}
One reason for the relatively limited interest in \acl{VPAKE} might be the somewhat artificial security benefits and models.
Security models for \ac{PAKE} protocols consider security of a key-exchange protocol using a password as authentication mechanism.
They however do \emph{not} consider any malicious server or attacker that tries to steal the authentication information, i.e. the password.
\ac{VPAKE} security models try to capture whether the protocol is secure (in the sense of \acl{PAKE}) \emph{and} if the server securely handles and stores the passwords/verifiers.
Since those security goals are significantly different and unrelated, it is difficult to find a meaningful security model for it.

Another reason for low adoption rate of \ac{VPAKE} in the research community is its questionable benefit.
While it is arguably that secure handling and storage of passwords is important, \ac{VPAKE} offers little benefit compared to \ac{PAKE}.
Since necessary randomness has to be stored on the server (recall that the client is stateless and can only handle human memorable secrets), it has to be transferred to the client at some point in the protocol.
However, when the randomness has to be transmitted from the server to the client, there is no reason not to do this as early in the protocol as possible and then use the verifier for authentication rather than the password in a common \ac{PAKE} protocol.


%********************************** %TPAKE and 2PAKE  **************************************
\subsection{Threshold and Two-Server PAKE}
Two-server PAKE protocols \cite{Abdalla2005} and general threshold \ac{PAKE} protocols \cite{MacKenzieSJ02,RaimondoG03,Abdalla2005b} tackle the problem of server compromise and malicious servers.
They share the client's password amongst two (or possibly more) servers that then jointly authenticate the client.
By splitting the password a malicious or compromised server can only recover a password share that does not allow to recover the password.
In contrast to \ac{PAKE} protocols two-server and threshold \ac{PAKE} protocols are less well studied.

\subsubsection{Threshold PAKE}
\citet{FordK00} first proposed to split the client's password among multiple servers to protect against server compromise.
\citet{RaimondoG03} and \citet{MacKenzieSJ02} were among the firsts to propose t-out-of-n \ac{PAKE} protocols.
The protocol from \citet{MacKenzieSJ02} requires a PKI in addition to the password and is therefore not password-only.

\subsubsection{Two-Server PAKE}
Two-server \ac{PAKE} can be seen as a special case of threshold PAKE for $t=n=2$ where $t$ out of $n$ servers, participating in the protocol and holding a password share, must be honest.
Compared to  general threshold \ac{PAKE}, two-server \ac{PAKE} is deemed more practical requiring only two participating servers.
In case of a server compromise, password change notifications can be sent to users.
Threshold \ac{PAKE} protocols are not automatically two-server \ac{PAKE} protocols.
The threshold \ac{PAKE} from \citet{RaimondoG03} for example requires $t<n/3$ such that it can not be modified to a two-server \ac{PAKE} protocol.
The first real two-server PAKE protocol is due to \citet{BrainardJKS03}, which was proven secure by \citet{SzydloK05} in a modified version.
The first two server PAKE with thorough security model based on the classical game-based BPR model is due to \citet{Katz2012a}.


%********************************** %Other PAKE protocols  **************************************
\subsection{Other Password Authenticated Protocols} \label{sec:other-pake}
Besides the straight-forward case where a single client-sever pair uses a common password to authenticate each other and establish a secure channel, there exist several other scenarios we discuss in the following.

\paragraph{Three-Party Password Authenticated Key Exchange}
The three-party setting (3\ac{PAKE}) considers two humans who want to securely communicate with each other.
Since sharing passwords with everyone else is not practical, a trusted server (the third party) come into play.
Thus, the users have to share only one password with the trusted sever, which assists then in the three-party protocol between the two users.
The initial three-party security model is due to \citet{Abdalla2005}.
Subsequent work \cite{CliffTB06,Yoneyama08,TsaiC13} propose new protocols and improved security models.

\paragraph{Group Password Authenticated Key Exchange}
Password authenticated group key exchange is another popular protocol, extending two-party \ac{PAKE} to the group setting.
Authenticated group key exchange protocols allow a \emph{group} of parties, not only two, to negotioate a session key.
One way to achieve group \ac{PAKE} is to use general group key exchange protocols and modify them for the password setting, \eg \cite{Bresson02,BrChPo05}.
%However, this usually yields rather inefficient protocols.
Similar to the classical \ac{PAKE}, group \ac{PAKE} enjoys a large body of research papers \cite{Kim2004,Abdalla2006,Bohli2006,Dutta2006,AbdallaP06,AbdallaBVS07,AbdallaCCP09,AbdallaCGP11}.

\paragraph{Password Protected Secret Sharing}
The notion of \ac{PPSS} was introduced by \citet{Bagherzandi2011}.
It allows to share a secret, \eg a symmetric key, among several servers, protected by a password. 
A security definition in the \acl{UC} framwork was proposed a year later by \citet{Camenisch2012}.
\ac{PPSS} has many interesing applications such as secure remote storage, an increasingly important use-case.
A similar notion called \emph{hidden credential retrieval} using only one server has been introduced by \citet{Boyen09} to allow users with knowledge of a password to store high-entropy messages securely on a server.


%TODO:
%\paragraph{Security against Malicious Servers}
%\fk[inline]{todo\\
%* HPAKE\\
%* SRP?\\
%* Two-Server PAKE}

\paragraph{Multi-Factor Authenticated Key Exchange}
As mentioned before, using passwords is only one possible authentication mechanism (for humans).
Combining several authentication techniques leads to \emph{multi-factor} authentication protocols.
The most commonly used reference for (multi-factor) authentication is the aforementioned \ac{NIST} standard \cite{Burr11} that defines four security levels for authentication.
Starting from level three at least two authentication factors are necessary.
Research in the area of multi-factor authentication \cite{PointchevalZ08,SUC10,LiuWM10,HaoC12} propose protocols and security models for two-party and three-party scenarios.
Real world implementations include for example Google authenticator \cite{GAuthenticator}.
However, implementations so far only combine traditional passwords with \aclp{OTP}.
Using biometric factors is rarely seen in practice so far.


% *****************************************************************************
% Section: Passwords and TLS
% *****************************************************************************
\section{Real World Architectures and Challenges}
As discussed in the beginning of the introduction, the scenario where cryptographic password-based authentication protocols are most needed is user login on the Internet.
However, due to the Internet's architecture the use of such protocols like \ac{PAKE} on the internet involves several challenges.
To understand the challenges one first has to understand how \ac{HTTPS} and thus \ac{TLS} works.

\acl{TLS} is, in it's current version $1.2$ \cite{rfc5246,rfc6176,rfc4492}, the successor of \ac{SSL}, a suite of cryptographic protocols for secure and authenticated communication.
It is standardised by the \ac{IETF} (\url{https://www.ietf.org/}) and, while called \emph{transport layer} security, is implemented on the presentation layer (it is initialised on the session layer).
In order to secure network traffic however, it can be seen as the transport layer while all lower layers only transport the encrypted content.
When accessing a website via \ac{HTTPS} a \ac{TLS} session is first established between the client and the server, which is then used to transport the content via \ac{HTTP}.
Thus, when the user is presented with a website to log on, the secure channel has been established already such that executing a \ac{PAKE} protocol and exchanging the \ac{TLS} keys with this newly created key is rather impractical (and not supported by any common browser).
The place to use \ac{PAKE} is actually \emph{before} the \ac{TLS} channels is set up, such that it can be used as key exchange in the \ac{TLS} handshake protocol.
This approach has been followed in \cite{rfc5054}, which uses the Secure Remote Password (SRP) by \cite{Wu98} and is implement in major \ac{TLS} implementations such as OpenSSL (\url{https://www.openssl.org/}).
The problem with such an approach however is that it requires the user to login before the actual website is sent, besides other problems, including the logout problem.
See \citet{Parsovs14} for a discussion on problems of client authentication using certificates.
Most problems are transferable to the case where the client uses a password for authentication instead of a client certificate.

Looking at the current state of the Internet and the used tools and protocols it is simply not reasonable to use \ac{PAKE} as \ac{TLS} authentication.
The challenge is therefore to deploy cryptographic password-based authentication on top of \ac{TLS}, \ie on the the application level, in order to secure user logins on the Internet.
While this might sound straight-forward, one has to consider that executing for example \ac{PAKE} with mutual authentication via an \ac{HTTPS} channel does \emph{not} necessarily yield an authenticated and confidential channel between client and server.
To achieve this the password-based authentication protocol has to be bound to the \ac{TLS} channel.
This has been recently achieved by \citet{MSD13} by introducing \ac{PACCE} on top of \ac{TLS}.


% *****************************************************************************
% Section: Outline & Summary
% *****************************************************************************
\section{Outline of this Thesis \& Summary of Results}
This thesis consists of five more chapters.
It starts in Chapter \ref{ch:prelims} with prerequisites and building blocks used throughout this work.
After defining the foundations, Chapter \ref{ch:vpake} describes the first major contribution of this thesis, a framework for password registration (Section \ref{sec:vpake-registration}) and password authenticated key-exchange (Section \ref{sec:vpake-pake}) in the verifier-based setting where the server stores only a verifier of the password.
The description of the implementation and demonstration can be found in Section \ref{sec:vpake-registration}.
Chapter \ref{ch:2pake} transfers the results from Chapter \ref{ch:vpake} to the two-server setting for the second contribution by proposing a framework for password registration and authentication in the two-server \ac{PAKE} setting.
To this end we describe a secure registration process for two-server \ac{PAKE} protocols in Section \ref{sec:2pake-registration} and the first \ac{UC} secure two-server \ac{PAKE} protocol in Section \ref{sec:2pake-uc}.



% %********************************** %Related Work  **************************************
% \section{Related Work}
% 
% %********************************** %Multi-Server PAKE  **************************************
% \subsection{Multi-Party Password Authenticated Key Exchange}
% \mynote{literature review/related work section}
% 
% \subsubsection{Threshold PAKE}
% 
% \subsubsection{Two-Server PAKE}
