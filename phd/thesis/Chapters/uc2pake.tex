\section{UC Security for Two-Server PAKE} \label{sec:uc2pake}

Using \acl{D-SPHF} allows to construct efficient \ac{2PAKE} protocols that are secure in the \ac{UC}-framework.
This follows the same approach as \ac{PAKE} protocols from \ac{SPHF} protocols, which use the properties of \acp{SPHF} to construct efficient \ac{PAKE} protocols in the \ac{UC}-framework.
In this section we propose a \ac{UC} functionality for \ac{2PAKE} protocols and give an efficient instantiation using a variant of \ac{D-SPHF} proposed in the previous section.

Before diving into technicalities we want to discuss \ac{2PAKE} and security guarantees it should provide.
We discuss informally several security requirements for \ac{2PAKE} protocols, which is then the basis for the ideal functionality \FTWOPAKE defined later.
% Depending on the \ac{2PAKE} protocol not all of them can be achieved.
First, note that the adversary has full control over the communication channel between the client and the servers as usual but communication between the two servers is confidential.
% \emph{Security against offline dictionary attacks}
The first and foremost security requirement of password protocols is security against \emph{offline dictionary attacks} and therefore has to be fulfilled by \ac{2PAKE} protocols as well.
In particular, no eavesdropping adversary must be able to perform an offline dictionary attack on the exchanged messages.
% \emph{Security against impersonation attacks}
Further, a malicious server must not be able to \emph{impersonate a registered client} in a \ac{2PAKE} execution.
An attacker, even with knowledge and capabilities of one of the two servers, must have success probability that is not significantly better than the success probability of a brute-force attacker when running a \ac{2PAKE} protocol on behalf of a registered client.
% \emph{Security against malicious server}
The \ac{BPR-M} game-based security notion for \ac{PAKE} and \ac{2PAKE}, which is derived from the AKE security notion, captures security by testing whether an attacker is able to distinguish between a real session key generated by a (two-server) \ac{PAKE} protocol, and a randomly chosen session key.
This implies in particular that the client agrees on two independent session keys with the two servers in the \ac{2PAKE} setting.
\ac{UC}-security in contrast requires simulatability of a (two-server) \ac{PAKE} protocol and is therefore harder to instantiate because the protocol has to be simulated even in case the adversary is able to guess the correct password (in which case the game-based model simply aborts the protocol execution and declares the adversary won the game).

% The strongest requirement on a \ac{2PAKE} protocol is the security against a malicious server.
% Here, a malicious server, or attacker controlling the server, must not be able to distinguish the session key between the client and the other server.
% The malicious server may be active or passive in its activities.
% Note again that not all server necessarily compute keys.

We want to further elaborate the difference between \ac{2PAKE} protocols where both servers compute the same key, compared to a \ac{2PAKE} protocol where the servers compute different keys.
Note that asymmetric key generation may also imply that only one server calculates a key while the second server only assists in the computation.
In the symmetric setting both servers calculate the same session key as result of the \ac{2PAKE} protocol.
Even though it is the first natural extension to the single server \ac{PAKE} scenario, to the best of our knowledge no such protocol has been proposed yet.
This may be due to the fact that corruption of a single server compromises the session key of any execution of a \ac{2PAKE} protocol that involves this server.
In the asymmetric setting both servers generate different session keys as result of the \ac{2PAKE} protocol, possibly none.
\citet{Katz2012a} proposed the first password-only \ac{2PAKE} protocol provably secure in the standard model, based on the Katz-Ostrovsky-Yung (KOY) protocol \cite{KatzOY01}.
While their protocol as well as the \ac{2PAKE} framework from the previous section is symmetric in its execution the client computes two independent session keys, one with each server.
Other asymmetric \ac{2PAKE} protocols have been proposed \cite{Yang_Deng_Bao_2006,Jin_Wong_Xu_2007} where the server interacts with only one server.
% In this setting the second server may not even interact with the client or compute a session key.
% Before discussing these possible \ac{2PAKE} classes and their security properties we give an informal overview on security requirements on \ac{2PAKE} protocols.
% \emph{Symmetric Key Generation}
% Key generation in \ac{2PAKE} protocols however can have different forms.
% We distinguish here between \emph{symmetric} and \emph{asymmetric} key generation.
% In this case \ac{2PAKE} offers resistance against offline dictionary attacks by the server and server compromise attacks of a single server that leak the server's password database.
% However, an attacker controlling one of the two servers calculates the same session key as the honest server and the client.
% A \ac{2PAKE} protocol secure in this setting can only protect against impersonation attacks, and password database leaks while they can not prevent malicious servers from attacking it.
% \emph{Asymmetric Key Generation}

In this section we stick to the asymmetric setting where only one server computes a session key.
This however can be easily extended to a \ac{2PAKE} protocol that computes an independent session keys for each server.
% However, instead of using a game-based model such as the BPR derivatives, we propose an ideal functionality for the \ac{UC} framework to show security of our \ac{2PAKE} protocol.
To this end we propose the first \ac{UC} functionality for \ac{2PAKE} protocols, which brings all benefits \ac{UC}-security carries in the \ac{PAKE} setting such as universal composability, security with arbitrary (related) password choices, security on execution with non-matching password (shares), and so on.
For a comprehensible overview of advantages using \ac{UC} in the \ac{PAKE} setting we refer to \citet{Canetti2005}.
To this end we extend \ac{D-SPHF} again to \ac{TD-SPHF} first.

%==============================================================================
% Trapdoor D-SPHF
%==============================================================================

\subsection{Trapdoor D-SPHF}\label{sec:tdsphf}
The \ac{2PAKE} protocol proposed in the following section makes use of \ac{TD-SPHF} in order to allow efficient instantiation.
\acp{TD-SPHF} enable single round \ac{PAKE} protocols because they achieve simulatability even in the case where the attacker guessed the correct password.
To use \ac{T-SPHF} in the two-server setting we extend the notion of \acp{T-SPHF} (cf. Section \ref{sec:tsphf}) to the distributed setting of \acp{D-SPHF} (cf. Section \ref{sec:dsphf}).
While our description is specific to the \ac{2PAKE} setting with languages over Cramer-Shoup ciphertexts an extension to more servers and other languages is straightforward along the lines of \ac{D-SPHF}.

\begin{definition}[TD-SPHF]\label{def:tdsphf}
Let $L_{\widehat{\pwd}}$ denote a language such that $C=(C_0,C_1,C_2)\in L_{\widehat{\pwd}}$ if there exists a witness $r=(r_0,r_1,r_2)$ proving so, $\pwd=\share_1+\share_2$ and there exists a function $\Dec'$ such that $\Dec'(C_1 C_2)=\Dec'(C_0)$.
% and $g:\GG^l\mapsto\GG^{l'}$ as described above.
A \ac{TD-SPHF} for language $L_{\widehat{\pwd}}$ consists of the following ten algorithms:

\begin{itemize}
	\item $(\crs',\tau')\ralgout\TSetup(\crs)$ generates $\crs'$ with trapdoor $\tau'$ from \crs

	\item \HKGen, \PKGen, $\Hash_x$, $\PHash_x$, $\Hash_0$, $\PHash_0$ behave as for \ac{D-SPHF}
	
	\item $b\algout\VerHp(\hp,L_{\widehat{\pwd}})$ returns $b=1$ iff \hp is a valid projection key, $b=0$ otherwise
	
	\item $h_x\algout\THash_x(\hp_0,L_{\widehat{\pwd}},C_1,C_2,\tau')$ computes hash value $h_x$ of ciphertexts $C_1$ and $C_2$ using projection key $\hp_0$ and trapdoor $\tau'$
	
	\item $h_0\algout\THash_0(\hp_1,\hp_2,L_{\widehat{\pwd}},C_0,\tau')$ computes hash value $h_0$ of $C_0$ using projection keys $\hp_1$ and $\hp_2$, and trapdoor $\tau'$
\end{itemize}
\end{definition}


% \subsubsection{TD-SPHF Security}\label{sec:tdsphf-security}
\noindent
Security of \ac{TD-SPHF} can be derived from \ac{D-SPHF} security and the extensions made on \acp{SPHF} for \acp{T-SPHF}.
However, we do not consider security of \ac{TD-SPHF} on its own but rather incorporate it in the security proof of the \ac{2PAKE} protocol in the following subsection.
This is due to the fact that description of \ac{TD-SPHF} is done only for this specific application such that a separate security definition is more distracting than giving any benefit.
However, we define correctness and soundness of \ac{TD-SPHF} since they differ from that of \ac{D-SPHF}.
In particular, \emph{correctness} of TD-SPHFs extends correctness of D-SPHFs by the statement that for every  valid ciphertext triple $(C_0,C_1,C_2)$, generated by \cL, and honestly generated keys $(\hk_0,\hk_1,\hk_2)$ and $(\hp_0,\hp_1,\hp_2)$, it holds not only that 

\begin{align*}  
&\Hash_0(\hk_1, \hk_2, L_{\widehat{\pwd}}, C_0)=\PHash_0(\hp_1, \hp_2, L_{\pwd, \share_1, \share_2}, C_0, r_0) \text{ and} \\
&\Hash_x(\hk_0, L_{\widehat{\pwd}}, C_1, C_2)=\PHash_x(\hp_0, L_{\pwd, \share_1, \share_2}, C_1, C_2, r_1, r_2)
\end{align*}
but also that $\VerHp(\hp_i, L_{\widehat{\pwd}})=1$ for $i\in\{0,1,2\}$ as well as 
\begin{align*}
&\Hash_0(\hk_1, \hk_2, L_{\widehat{\pwd}}, C_0)=\THash_0(\hp_1, \hp_2, L_{\pwd, \share_1, \share_2}, C_0, \tau') \text{ and} \\
&\Hash_x(\hk_0, L_{\widehat{\pwd}}, C_1, C_2)=\THash_x(\hp_0, L_{\pwd, \share_1, \share_2}, C_1, C_2, \tau').
\end{align*}
To capture soundness of TD-SPHFs we define \emph{$(t,\varepsilon)$-soundness}, complementing the previous correctness extension as follows.

\begin{definition}[TD-SPHF $(t,\varepsilon)$-soundness]\label{def:tdsphf-soundness}
Given \crs, $\crs'$ and $\tau$, no adversary running in time at most $t$ can produce a projection key \hp, a password \pwd with shares $\share_1$ and $\share_2$, a word $(C_0,C_1,C_2)$, and valid witness $(r_0,r_1,r_2)$, such that $(\hp_0,\hp_1,\hp_2)$ are valid, \ie $\VerHp(\hp_i,L_{\widehat{\pwd}})=1$ for $i\in\{0,1,2\}$, but 
\begin{align*}
&\THash_x(\hp_0,L_{\widehat{\pwd}},C_1, C_2, \tau')\not=\PHash_x(\hp_0,L_{\widehat{\pwd}}, C_1, C_2, r_1, r_2) \text{ or} \\
&\THash_0(\hp_1, \hp_2, L_{\widehat{\pwd}}, C_0, \tau')\not=\PHash_0(\hp_1, \hp_2, L_{\widehat{\pwd}}, C_0, r_0)
\end{align*}
with probability at least $\varepsilon(\secpar)$.
The perfect soundness states that the property holds for any $t$ and any $\varepsilon(\secpar)>0$.
\end{definition} 

\subsubsection{Cramer-Shoup TD-SPHF}\label{sec:cs-tdsphf}
Extending the Cramer-Shoup \ac{D-SPHF} from the previous section to a \ac{TD-SPHF} is straight-forward combining it with the Cramer-Shoup \ac{T-SPHF}.
This \ac{TD-SPHF} is, like the Cramer-Shoup \ac{T-SPHF}, defined over groups with bilinear pairings.
Let $C=(\ell, u_1, u_2, e, v)$ denote a Carmer-Shoup ciphertext as defined in Section \ref{sec:csencryption}.
% We only describe the differences to the previous CS \ac{D-SPHF}.
% $\pk=(p,\GG_1,\GG_2,\GG_T,e,g_{11},g_{12},c,f,h,H_k)$ and $c=g_{11}^{x_1}g_{12}^{x_2}, d=g_{11}^{y_1}g_{12}^{y_2}, h=g_{11}^z$ s.t. $dk=(x_1,x_2,y_1,y_2,z)$

\begin{itemize}
	\item $\TSetup(\crs)$ draws a random $\tau'\rin\ZZ_p$ and computes $\crs'=\zeta=g_2^{\tau'}$
	
	\item $\HKGen(L_{\widehat{\pwd}})$ returns $\hk_i=(\eta_{1,i},\eta_{2,i},\theta_i,\mu_i,\nu_i)\rin\ZZ_p^{1\times 5}$ for $i\in\{0,1,2\}$
	
  \item $\PKGen(\hk_i, L_{\widehat{\pwd}})$ generates 
      $\hp_i=(\hp_{1,i}=g_{1,1}^{\eta_{1,i}} g_{1,2}^{\theta_i} h^{\mu_i} c^{\nu_i}, \hp_{2,i}=g_{1,1}^{\eta_{2,i}} d^{\nu_i}, \hp_{3,i})$ with
      $\hp_{3,i}=(\chi_{1,1,i}, \chi_{1,2,i}, \chi_{2,i}$, $\chi_{3,i}, \chi_{4,i})$ and 
      $\chi_{1,1,i}={\zeta}^{\eta_{1,i}}, \chi_{1,2,i}={\zeta}^{\eta_{2,i}}, \chi_{2,i}={\zeta}^{\theta_i}, \chi_{3,i}={\zeta}^{\mu_i}, \chi_{4,i}={\zeta}^{\nu_i}$ for $i\in\{0,1,2\}$
  
  \item $\Hash_x(\hk_0, L_{\widehat{\pwd}}, C_1, C_2)$ computes 
      \[h'_x=(u_{1,1}\cdot u_{1,2})^{\eta_{1,0}+(\xi_1+\xi_2)\eta_{2,0}} (u_{2,1}\cdot u_{2,2})^{\theta_0} ((e_1\cdot e_2)/g_{1,1}^{\pwd})^{\mu_0} (v_1\cdot v_2)^{\nu_0}\]
      and returns $h_x=e(h'_x,g_2)$
  \item $\PHash_x(\hp_0, L_{\widehat{\pwd}}, C_1, C_2, r_1, r_2)$ computes 
      \[h'_x=\hp_{1,0}^{r_1+r_2} \hp_{2,0}^{\xi_1 r_1+\xi_2 r_2}\]
      and outputs $h_x=e(h'_x,g_2)$
  \item $\Hash_0(\hk_1, \hk_2, L_{\widehat{\pwd}}, C_0)$ computes 
      \[h'_0=u_{1,0}^{\eta_{1,1}+\eta_{1,2}+\xi_0(\eta_{2,1}+\eta_{2,2})} u_{2,0}^{\theta_1+\theta_2} (e_0/g_{1,1}^{\pwd})^{\mu_1+\mu_2} v_0^{\nu_1+\nu_2}\]
      and outputs $h_0=e(h'_0,g_2)$
  \item $\PHash_0(\hp_1, \hp_2, L_{\widehat{\pwd}}, C_0, r_0)$ computes 
      \[h'_0=(\hp_{1,1}\hp_{1,2})^{r_0} (\hp_{2,1}\hp_{2,2})^{r_0\xi_0}\]
      and outputs $h_0=e(h'_0,g_2)$
	
  \item $\VerHp(\hp_i, L_{\widehat{\pwd}})$ verifies that 
      \[e(\hp_{1,i}, \crs')\stackrel{?}{=} e(g_{1,1}, \chi_{1,1,i})\cdot e(g_{1,2}, \chi_{2,i})\cdot e(h, \chi_{3,i})\cdot e(c, \chi_{4,i})\]
      and
      \[e(\hp_{2,i}, \crs') \stackrel{?}{=} e(g_{1,1}, \chi_{1,2,i})\cdot e(d, \chi_{4,i}) for i\in\{0,1,2\}\]

  \item $\THash_0(\hp_1, \hp_2, L_{\widehat{\pwd}}, C_0, \tau')$ computes 
      \begin{align*}        
        h_0 = \Big[ & e(u_{1,0}, \chi_{1,1,1}\chi_{1,1,2}(\chi_{1,2,1}\chi_{1,2,2})^{\xi_0})\cdot \\
        & e(u_{2,0}, \chi_{2,1}\chi_{2,2})\cdot e(e_0/g_{1,1}^{\pwd}, \chi_{3,1}\chi_{3,2})\cdot e(v_0, \chi_{4,1}\chi_{4,2}) \Big]^{1/\tau'}
      \end{align*}
			
	\item $\THash_x(\hp_0, L_{\widehat{\pwd}}, C_1, C_2,\tau')$ computes 
    	\[h_x=\left[ e(u_{1,1} u_{1,2}, \chi_{1,1,0}\chi_{1,2,0}^{\xi_1+\xi_2}) \cdot e(u_{2,1} u_{2,2}, \chi_{2,0}) \cdot e( (e_1 e_2) / g_{1,1}^{\pwd}, \chi_{3,0}) \cdot e( v_{1} v_2, \chi_{4,0})\right]^{1/\tau'}\]
\end{itemize}

\noindent
Distributed computation of $\PHash_x$ and $\Hash_0$ is done as in \ac{D-SPHF} with additional proofs for correctness and adding the pairing computation at the end to lift the hash value into $\GG_T$.
We formalise execution of the Cramer-Shoup \ac{TD-SPHF} in the following paragraph.
Necessary zero-knowledge proofs are described in the following two paragraphs and only referenced in the Cramer-Shoup \ac{TD-SPHF} description.
While the zero-knowledge proofs are $\Sigma$ proofs (and therefore honest verifier zero-knowledge proofs of knowledge) we regard them as zero-knowledge proofs (without knowledge extractor) in order to avoid the necessity of rewinding the prover, and use them in committed form to ensure security against malicious verifiers.
% Note that we merge \crs and $\crs'$ here for readability.
Protocol participants are denoted \Client, $\Server_1$ and $\Server_2$ if their role is specified, or $P$, $Q$ and $R$ otherwise.
Let further $0$ denote the client's index and $1$, respectively $2$, denote the indices of server $\Server_1$, $\Server_2$ respectively.
The session ID is given by $\sid=\Client||\Server_1||\Server_2$ and the unique query identifier \qid is agreed upon start using \Finit.

All \ac{TD-SPHF} participants have $\crs=(p,g_{1,1},g_{1,2},h,c,d,\GG_1,g_{2},\zeta,\GG_2,\GG_T,e,H_k)$ as common input where $\tau=(x_1,x_2,y_1,y_2,z)$ is the \crs trapdoor, \ie the according Cramer-Shoup secret key, and $\tau'$ the trapdoor, \ie discrete logarithm to base $g_2$, of $\crs'=\zeta$.
Each server holds an ElGamal key pair $(\pk_1, \sk_1)$ and $(\pk_2, \sk_2)$ respectively such that $\pk_1$ is registered with the \CA for $\Server_1$ and $\pk_2$ for $\Server_2$ and thus available to all parties (using \Fca).
An otherwise unspecified protocol participant $P$ is initiated with $(\NS, \sid, \qid, P, x)$.
We further define $\share_0=\pwd$.
%use $P_i$ for party $i\in[1,2,3]$ and
% When $P$ is activated with a NewSession query $(\NS, \sid, \qid, P, x)$ it proceeds as follows.

\paragraph{Cramer-Shoup TD-SPHF}
% \begin{figure}[htbp]
% \begin{mdframed}[innertopmargin=10pt]
% \begin{center}
% \caption{Cramer-Shoup \TDSPHF}
% \label{fig:cs-tdsphf}
% % {\bf Cramer-Shoup \TDSPHF}\smallskip
% \end{center}

% \begin{description}\itemsep5pt
	
% 	\item[NewSession:] When $P_i$ is activated with $(\NS, \sid, \qid, P_i, x, \role)$ it proceeds as follows.\smallskip
	  \begin{enumerate}
	    \item Generate \ac{TD-SPHF} keys $\hk_i\rin\ZZ_p^{5}$ and 
	      $\hp_i=(\hp_{1,i}=g_{1,1}^{\eta_{1,i}} g_{1,2}^{\theta_i} h^{\mu_i} c^{\nu_i}, \hp_{2,i}=g_{1,1}^{\eta_{2,i}} d^{\nu_i}, \chi_{1,1,i}={\zeta}^{\eta_{1,i}}, \chi_{1,2,i}={\zeta}^{\eta_{2,i}}, \chi_{2,i}={\zeta}^{\theta_i}, \chi_{3,i}={\zeta}^{\mu_i}, \chi_{4,i}={\zeta}^{\nu_i})$. 
	    Encrypt $\share_i$ to $C=(\ell_i,u_{1,i},u_{2,i},e_i,v_i)\gets(\ell, g_{1,1}^{r_i}, g_{1,2}^{r_i}, h^{r_r} g_{1,1}^{\share_i}, (cd^{\xi_i})^{r_i})$ with $\xi_i=H_k(\ell_i, u_{1,i}, u_{2,i}, e_i)$ for $\ell_i=\sid || \qid || \hp_i$ and $r_i\rin\ZZ_p$.
	    If $P=\Server_1$, set $h_0=h_x=\NULL$.
	    Output $(\sid,\qid,0,P,C_i,\hp_i)$ to $Q$ and $R$.
	    
	    \item When $P$, waiting for the initial messages, is receiving a message $(\sid$, $\qid$, $0$, $Q$, $C_1$, $\hp_1)$ and $(\sid$, $\qid$, $0$, $R$, $C_2$ ,$\hp_2)$ it proceeds as follows.
	      $P$ proceeds only if the projection keys $\hp_1$ and $\hp_2$ are correct, \ie $\VerHp(\hp_1, L_{\widehat{\pwd}})=1$ and $\VerHp(\hp_2, L_{\widehat{\pwd}})=1$.
	          If the verification fails, $P$ outputs $(\sid, \qid, \bot, \bot)$ and aborts the protocol.
	      \begin{enumerate}
	        \item If $P=\Client$, compute \\
	          \[h_x=e\left((u_{1,1}\cdot u_{1,2})^{\eta_{1,0}+(\xi_1+\xi_2)\eta_{2,0}} (u_{2,1}\cdot u_{2,2})^{\theta_0} ((e_1\cdot e_2)/g_{1,1}^{\pwd})^{\mu_0} (v_1\cdot v_2)^{\nu_0}, g_2\right) \] 
	          and \\
	          \[ h_0=e\left( (\hp_{1,1}\hp_{1,2})^{r_0} (\hp_{2,1}\hp_{2,2})^{r_0\xi_0}, g_2 \right),\]
	          and output $(\sid, \qid, h_0, h_x)$.
	        \item If $P=\Server_2$, compute
	          $h_{x,2} = (\hp_{1,0} \cdot \hp_{2,0}^{\xi_2})^{r_2}$ and 
	          $C_{h_{x,2}}=g_{1,1}^{H(h_{x,2}, \Comm_{1})} h^{r_{c1}}$ with $r_{c1}\rin\ZZ_p$
% 	          $t_1=(\hp_{0,1}\hp_{0,2}^{\xi_2})^{k_1}$ and
% 	          $t_2=(cd^{\xi_2})^{k_1}$,
	          and send $(\sid,\qid,\PHash_x,0,\Server_2,C_{h_{x,2}})$ to $\Server_1$.
	        \item If $P=\Server_1$, compute
	          $m_{0} = \Enc_{\pk_1}^\EG(g_{1,1}^{-\mu_1}; r)$ and
	          $c_{0} = \Enc_{\pk_1}^\EG(g_{1,1}^{\share_1}; r')$
	          with $r,r'\rin\ZZ_p$, and send $(\sid,\qid,\Hash_0,0,\Server_1,m_0,c_0)$ to $\Server_2$.
	      \end{enumerate}
	      
% 	  \end{enumerate}
%   \item[\hspace*{1em}] {\it Computation of $\PHash_x$ between $\Server_1$ and $\Server_2$.}\smallskip
%     \begin{enumerate} \setcounter{enumi}{2}
    
	    \item On input $(\sid,\qid,\PHash_x,0,\Server_2,C_{h_{x,2}})$ $\Server_1$ in the correct state draws challenge $\fc\rin\ZZ_p$ and returns $(\sid,\qid,\PHash_x,1,\Server_1,\fc)$ to $\Server_2$.
	    
	    \item On input $(\sid,\qid,\PHash_x,1,\Server_1,\fc)$ $\Server_2$ in the correct state computes
	    $C_{s_{h_{x,2}}}=g_{1,1}^{H(\Res_{1})} h^{r_{c2}}$ with $r_{c2}\rin\ZZ_p$
% 	    $s_{h_{x,2}}=k_1-c r_{2}$ 
	    and sends $(\sid,\qid,\PHash_x,2,\Server_2,C_{s_{h_{x,2}}})$ to $\Server_1$.
	    Subsequently, it sends $(\sid,\qid,\PHash_x,3,\Server_2,h_{x,2}, \Comm_1, \Res_1, r_{c1}, r_{c2})$ to $\Server_1$.
	    %t_1, t_2, s_{h_{x,2}}
	    
	    \item On input $(\sid,\qid,\PHash_x,2,\Server_2,C_{s_{h_{x,2}}})$ $\Server_1$ in the correct state stores it and waits for the final $\PHash_x$ message.
	    
	    \item On input $(\sid,\qid,\PHash_x,3,\Server_2,h_{x,2}, \Comm_1, \Res_1, r_{c1}, r_{c2})$ $\Server_1$ in the correct state parses $\Comm_1$ as $(t_1,t_2)$ and $\Res_2$ as $s_{h_{x,2}}$ and verifies correctness of commitments and the \ac{ZKP}
% 	    $C_{h_{x,2}}\stackrel{?}{=}g_{1,1}^{H(h_{x,2}, t_1, t_2)} h^{r_{c1}}$,
% 	    $C_{s_{h_{x,2}}}\stackrel{?}{=}g_{1,1}^{H(s_{h_{x,2}})} h^{r_{c2}}$,
% 	    $t_1\stackrel{?}{=}h_{x,2}^{c} (\hp_{0,1}\hp_{0,2}^{\xi_2})^{s_{h_{x,2}}}$, and
% 	    $t_2\stackrel{?}{=}v_2^{c} (cd^{\xi_2})^{s_{h_{x,2}}}$,
	     and computes
 	    $h_x = e\left( h_{x,2}\cdot (\hp_{0,1} \cdot \hp_{0,2}^{\xi_1})^{r_1}, g_2 \right)$
 	    if the verifications are successful, $h_x\not=\bot$ and $h_0\not=\bot$, or sets $h_0=\bot$ and $h_x=\bot$ otherwise.
	    
% 	  \end{enumerate}
%   \item[\hspace*{1em}] {\it Computation of $\Hash_0$ between $\Server_1$ and $\Server_2$.}\smallskip
%     \begin{enumerate} \setcounter{enumi}{6}
	    
	    \item On input $(\sid,\qid,\Hash_0,0,\Server_1,m_0,c_0)$ $\Server_2$ in the correct state retrieves $\pk_1$ from \Fca and computes
	      $C_{\Hash_{0,1}}=g_{1,1}^{H(m_{1},m_{2},\Comm_2)} h^{r_{c3}}$
	      with $r_{c3}\rin\ZZ_p$,
	      $m_{1}\gets m_0^{\share_2} \times c_0^{-\mu_2} \times \Enc_{\pk_1}^\EG(g_{1,1}^{-\mu_2\cdot {\share_2}} \cdot u_{1,0}^{\eta_{1,2}+\xi_0\eta_{2,2}} \cdot u_{2,0}^{\theta_2} \cdot e_0^{\mu_2} \cdot v_0^{\nu_2}; r'')$, and $m_{2}\gets \Enc_{\pk_1}^\EG(g_{1,1}^{-\mu_2}; r''')$ with $r'',r'''\in\ZZ_p$,
	      and sends $(\sid,\qid,\Hash_{0,1},\Server_2,C_{\Hash_{0,1}})$ back to $\Server_1$.
	      
	    \item On input $(\sid,\qid,\Hash_{0,1},\Server_2,C_{\Hash_{0,1}})$ $\Server_1$ in the correct state draws challenge $\fc\rin\ZZ_p$ and returns $(\sid,\qid,\Hash_{0,2},\Server_1,\fc)$ to $\Server_2$. 
	    
	    \item On input $(\sid,\qid,\Hash_{0,2},\Server_1,\fc)$ $\Server_2$ in the correct state computes
	    $C_{\Res2}=g_{1,1}^{H(\Res_{2})} h^{r_{c4}}$ with $r_{c4}\rin\ZZ_p$
	    and sends $(\sid,\qid,\Hash_{0,3},\Server_2,C_{\Res2})$ to $\Server_1$.
	    Subsequently, it sends $(\sid,\qid,\Hash_{0,4},\Server_2, m_1, m_2, \Comm_2, \Res_2, r_{c3}, r_{c4})$ to $\Server_1$.
	    
	    \item On input $(\sid,\qid,\Hash_{0,4},\Server_2, m_1, m_2, \Comm_2, \Res_2, r_{c3}, r_{c4})$ $\Server_1$ in the correct state parses $\Comm_{2}$ as $(t_{\overline{m}1}, t_{\overline{m}2}, t_{e2}, t_{v2}, t_{\hp12}, t_{\hp22})$ and $\Res_{2}$ as $(s_{\share_2}, s_{\mu2}, s_{\eta12}, s_{\eta22}, s_{\theta2}, s_{\nu2}, s_{r2})$, verifies correctness of commitments and \ac{ZKP} , and computes
	      \[h_0 = e\left( g_{1,1}^{-\mu_1\cdot \share_1} \cdot \Dec_{\sk_1}^\EG(m_1) \cdot u_{1,0}^{\eta_{1,1}+\xi_0\eta_{2,1}} \cdot u_{2,0}^{\theta_1} \cdot e_0^{\mu_1} \cdot v_0^{\nu_1}, g_2 \right)\] 
	      if the verifications are successful, $h_x\not=\bot$ and $h_0\not=\bot$, or sets $h_0=\bot$ and $h_x=\bot$.
	    
	    \item Eventually $\Server_1$ outputs $(\sid, \qid, h_0, h_x)$ if $h_0\not=\NULL$ and $h_x\not=\NULL$.
	  \end{enumerate}
	  	
% % \end{description}
% \end{mdframed}
% \end{figure}

\paragraph{ZK Proof for $\PHash_x$ Correctness}
In order to ensure correct computation of $h_x$ on $\Server_1$ server $\Server_2$ has to prove correctness of his computations.
To this end $\Server_2$ sends, in addition to the $\PHash_x$ message $h_{x,2}$ the following zero-knowledge proof.
\begin{equation}
    \ZKP\big\{ r_2:~~ h_{x,2} = (\hp_{1,0} \hp_{2,0}^{\xi_2})^{r_2} ~ \wedge ~ v_2=(cd^{\xi_2})^{r_2} \big\}
\end{equation}
where $r_2$ is the randomness used to create $C_2$, $\xi_2$ and $v_2$ are part of $C_2$, $\hp_{1,0},\hp_{2,0}$ are part of \Client's projection key, and $c,d$ are from the \crs.
The construction of the according zero-knowledge proof is straight-forward. 
The prover computes commitments
\[ t_{hx2} = (\hp_{1,0} \hp_{2,0}^{\xi_2})^{k_{hx2}}; ~~ t_{v2} = (cd^{\xi_2})^{k_{hx2}} \]
with fresh randomness $k_{hx2}\rin\ZZ_p$, and response $s_{r2} = k_{hx2} - \fc r_2$ for verifier provided challenge $\fc$.
This allows the verifier to check
\[ t_{hx2} \stackrel{?}{=} h_{x,2}^\fc (\hp_{1,0} \hp_{2,0}^{\xi_2})^{s_{hx2}}; ~~ t_{v2} \stackrel{?}{=} v_2^\fc (cd^{\xi_2})^{s_{hx2}}. \]
It is easy to see that this zero-knowledge proof is correct, sound and (honest-verifier) simulatable.
We refer to the messages as $\Comm_{1}=(t_{hx2}, t_{v2})$, $\Res_{1}=s_{r2}$, and $\Ch_{1}=\fc$.

\paragraph{ZK Proof for $\Hash_0$ Correctness}
Let $\overline{m}_1$ and $\overline{m}_2$ denote the messages encrypted in $m_1$ and $m_2$ respectively and $m_{0,1}$ and $c_{0,1}$ the second part ($e$) of the ElGamal ciphertext $m_0$, $c_1$ respectively.
In order to ensure correct computation of $h_0$ on $\Server_1$ server $\Server_2$ has to prove correctness of his computations.
To this end $\Server_2$ sends, in addition to the $\Hash_0$ messages $\overline{m}_1$ and $\overline{m}_2$ the following zero-knowledge proof 
\begin{equation}
\begin{split}
    \ZKP\big\{ (x, \eta_{1,2}, \eta_{2,2}, \theta_2, \mu_2, \nu_2, r_2): ~ &  
      \overline{m}_1 = m_{0,1}^{\share_2} c_{0,1}^{-\mu_2} g_{1,1}^{-\mu_2 x} u_{1,0}^{\eta_{1,2} + \xi_0 \eta_{2,2}} u_{2,0}^{\theta_2} e_0^{\mu_2} v_0^{\nu_2} \\
      % ~ \wedge ~ m_2 = g_{1,1}^x
      & \wedge ~ \overline{m}_2 = g_{1,1}^{-\mu_2} ~ \wedge ~ e_2 = h^{r_2}g_{1,1}^{\share_2} ~ \wedge ~ v_2 = (cd^{\xi_2})^{r_2} \\
      & \wedge ~ \hp_{1,2} = g_{1,1}^{\eta_{1,2}} g_{1,2}^{\theta_2} h^{\mu_2} c^{\nu_2} ~ \wedge ~ \hp_{2,2} = g_{1,1}^{\eta_{2,2}} d^{\nu_2}
      \big\},
\end{split}
\end{equation}
where $r_2$ is the randomness used to create $C_2$, $\xi_2$ and $v_2$ are part of $C_2$, $\xi_0$ is part of $C_0$, $(\mu_2, \eta_{1,2}, \eta_{2,2}, \theta_2, \nu_2)$ is $\Server_2$'s hashing key, $\share_2$ $\Server_2$'s password share, and $c,d$ are from the \crs.
%variables as defined in Figure \ref{fig:cs-tdsphf}.
The construction of the according $\Sigma$ proof is straight-forward.
The prover computes commitments
\begin{align*}
  & t_{\overline{m}1} = m_{0,1}^{{\share_2}} c_{0,1}^{k_{\mu2}} \overline{m}_{2}^{k_{x}} u_{1,0}^{k_{\eta12} + \xi_0 k_{\eta22}} u_{2,0}^{k_{\theta2}} e_0^{-k_{\mu2}} v_0^{k_{\nu2}}; ~~~
    t_{\overline{m}2} = g_{1,1}^{k_{\mu2}}; ~~~  t_{e2} = h^{k_{r2}}g_{1,1}^{{\share_2}}; ~~~ t_{v2} = (cd^{\xi_2})^{k_{r2}}; \\
  & t_{\hp12} = g_{1,1}^{k_{\eta12}} g_{1,2}^{k_{\theta2}} h^{k_{\mu2}} c^{k_{\nu2}}; ~~~ t_{\hp22} = g_{1,1}^{k_{\eta22}} d^{k_{\nu2}}
    \text{ ~for~ } k_{\share_2}, k_{\mu2}, k_{\eta12}, k_{\eta22}, k_{\theta2}, k_{\nu2} \rin \ZZ_p
\end{align*}
and responses
\begin{align*}
  & s_{\share_2} = k_{\share_2} - \fc\share_2; ~~~ s_{\mu2} = k_{\mu2} + \fc\mu_2; ~~~ s_{\eta12} = k_{\eta12} - \fc\eta_{1,2}; ~~~ s_{\eta22} = k_{\eta22} - \fc\eta_{2,2}; \\
  & s_{\theta2} = k_{\theta2} - \fc\theta_2; ~~~ s_{\nu2} = k_{\nu2} - \fc\nu_2; ~~~ s_{r2} = k_{r2} - \fc r_2
\end{align*}
for verifier provided challenge $\fc$.
This allows the verifier to check
\begin{align*}
  & t_{\overline{m}1} \stackrel{?}{=} \overline{m}_1^\fc m_{0,1}^{s_{\share_2}} c_{0,1}^{s_{\mu2}} \overline{m}_{2}^{s_{\share_2}} u_{1,0}^{s_{\eta12} + \xi_0 s_{\eta22}} u_{2,0}^{s_{\theta2}} e_0^{s_{\mu2}} v_0^{s_{\nu2}}; ~~~ 
    t_{\overline{m}2} \stackrel{?}{=} \overline{m}_2^\fc g_{1,1}^{s_{\mu2}}; ~~~  t_{e2} \stackrel{?}{=} e_2^\fc h^{s_{r2}}g_{1,1}^{s_{\share_2}}; \\
  & t_{v2} \stackrel{?}{=} v_2^\fc (cd^{\xi_2})^{s_{r2}}; ~~~
    t_{\hp12} \stackrel{?}{=} \hp_{1,2}^\fc g_{1,1}^{s_{\eta12}} g_{1,2}^{s_{\theta2}} h^{s_{\mu2}} c^{s_{\nu2}}; ~~~ 
    t_{\hp22} \stackrel{?}{=} \hp_{2,2}^\fc g_{1,1}^{s_{\eta22}} d^{s_{\nu2}} .
\end{align*}
While this is mainly a standard zero-knowledge proof $t_{\overline{m}1}$ uses $\overline{m}_2$ instead of $g_{1,1}$ as base for the third factor and $k_{\share_2}$ as exponent ($s_{\share_2}$ in the verification).
This is necessary due to the fact that the exponent $-\mu_2 {\share_2}$ of the third factor in $\overline{m}_1$ is a product of two values that have to be proven correct.
The \ac{ZK} proof uses the auxiliary message $\overline{m}_2$ to prove that $\log_{g_{1,1}}(\overline{m}_2)=-\mu_2$ such that it is sufficient to prove $\log_{\overline{m}_2}(\overline{m}_2^{{\share_2}})={\share_2}$.
We refer to the messages as $\Comm_{2}=(t_{\overline{m}1}, t_{\overline{m}2}, t_{e2}, t_{v2}, t_{\hp12}, t_{\hp22})$, $\Res_{2}=(s_{\share_2}, s_{\mu2}, s_{\eta12}, s_{\eta22}, s_{\theta2}, s_{\nu2}, s_{r2})$, and $\Ch_{2}=\fc$.


%==============================================================================
% 2-Server PAKE in UC
%==============================================================================
\subsection{UC-secure Two Server PAKE (\FTWOPAKE)}\label{sec:2pake}
With \ac{TD-SPHF} it is straight forward to build a \ac{2PAKE} protocol.
We follow the general framework described in the previous section to build \ac{2PAKE} protocols from \acp{D-SPHF}.
However, instead of aiming for key generation where the client establishes a key with each of the two servers, we focus on a protocol that establishes a single key with one server, w.l.o.g. the first server.
By running the protocol twice, keys can be exchanged between the client and the second sever.
Note that \ac{UC} security allows concurrent execution of the protocol such that round complexity is not increased by establishing two keys.

\subsubsection{The Protocol}\label{sec:2pakeprotocol}
The idea behind this \ac{2PAKE} protocol is rather simple.
Other ways to build \ac{2PAKE} protocols, \eg from \ac{D-SPHF} directly, are certainly possible, but less efficient than the proposed protocol based on \ac{TD-SPHF}.
Client \Client, Server $\Server_1$ and Server $\Server_2$ execute a \ac{TD-SPHF} protocol as described in Section \ref{sec:tdsphf}.
This provides \Client and $\Server_1$ with two hash values $h_0$ and $h_x$ each (if all protocol participants execute the protocol honestly and all messages reach their destination unaltered).
A session key can then be derived by simply multiplying $h_0$ and $h_x$ to $\sk=h_0\cdot h_x$.
If the protocol is not terminated prematurely and a session key is computed on \Client and $\Server_1$, this ensures that \Client and $\Server_1$ share a unique random session key $\sk$ after finishing an honest and correct protocol run and two independent random session keys $\sk$ in case one of the parties inputs a wrong password (share) or the traffic is altered during transport.


% \begin{tikzpicture}
% \matrix (m)[matrix of nodes, column  sep=1cm,row  sep=4mm, nodes={draw=none, anchor=center,text depth=0pt} ]{
% Client & & Server 1 & & Server 2\\ %[-4mm]
% a) & & a) && a) \\
%  & $(C_0,\hp_0)$ & & $(C_1,\hp_1)$ &  \\ [-4mm]
%  & $(C_1,\hp_1)$ & & $(C_2,\hp_2)$ &  \\ [-4mm]
%  & \hfill & $(C_0,\hp_0)$ & \hfill &  \\ [-4mm]
%  & \hfill & $(C_2,\hp_2)$ & \hfill &  \\
% b) i) & & b) iii) & & b) ii) \\
%  & & & $C_{h_{x,2}}$ &  \\
%  & & & $(m_0, c_0)$ &  \\
%  & & c) & & g)\\
%  & & & $c$ &  \\
%  & & & $C_{\Hash_{0,1}}$ &  \\
%  & & h) & & d)\\
%  & & & $c$ &  \\
%  & & & $C_{s_{h_{x,2}}}$ &  \\
% };
% 
% \draw ($(m-2-1.south west)-(0.1,0.2)$) rectangle ($(m-2-1.north east)+(0,0.1)$);
% \draw ($(m-2-3.south west)-(0.1,0.2)$) rectangle ($(m-2-3.north east)+(0,0.1)$);
% \draw ($(m-2-5.south west)-(0.1,0.2)$) rectangle ($(m-2-5.north east)+(0,0.1)$);
% % \draw[shorten <=-1.5cm,shorten >=-1.5cm] (m-1-1.south east)--(m-1-1.south west);
% % \draw[shorten <=-1.5cm,shorten >=-1.5cm] (m-1-3.south east)--(m-1-3.south west);
% % \draw[shorten <=-1.5cm,shorten >=-1.5cm] (m-1-5.south east)--(m-1-5.south west);
% \draw[shorten <=-1cm,shorten >=-1cm,-latex] (m-3-2.south west)--(m-3-2.south east);
% \draw[shorten <=-1cm,shorten >=-1cm,-latex] (m-3-4.south west)--(m-3-4.south east);
% \draw[shorten <=-1cm,shorten >=-1cm,-latex] (m-4-2.south east)--(m-4-2.south west);
% \draw[shorten <=-1cm,shorten >=-1cm,-latex] (m-4-4.south east)--(m-4-4.south west);
% \draw[shorten <=-1cm,shorten >=-1cm,-latex] ($(m-5-2.south west)-(0.7,0.12)$)--($(m-5-4.south east)-(-0.7,0.12)$);
% \draw[shorten <=-1cm,shorten >=-1cm,-latex] ($(m-6-4.south east)-(-0.7,0.12)$)--($(m-6-2.south west)-(0.7,0.12)$);
% \draw[shorten <=-1cm,shorten >=-1cm,-latex] (m-8-4.south east)--(m-8-4.south west);
% \draw[shorten <=-1cm,shorten >=-1cm,-latex] (m-9-4.south west)--(m-9-4.south east);
% \draw[shorten <=-1cm,shorten >=-1cm,-latex] (m-11-4.south west)--(m-11-4.south east);
% \draw[shorten <=-1cm,shorten >=-1cm,-latex] (m-12-4.south east)--(m-12-4.south west);
% \draw[shorten <=-1cm,shorten >=-1cm,-latex] (m-14-4.south west)--(m-14-4.south east);
% \draw[shorten <=-1cm,shorten >=-1cm,-latex] (m-15-4.south east)--(m-15-4.south west);
% 
% % \draw[shorten <=-1cm,shorten >=-1cm,-latex] (m-5-2.south east)--(m-5-2.south west);
% \end{tikzpicture}

\subsubsection{UC Security Model for Two Server PAKE}\label{sec:2pakesecurity}
We describe the ideal functionality for \ac{2PAKE} in the following, which can be seen as an extension of the known ideal functionality for \ac{PAKE} protocols from Canetti et al. \cite{Canetti2005}.
The ideal functionality \FTWOPAKE is given in Figure \ref{fig:2pakef}.
\FTWOPAKE is very similar to the original \ac{2PAKE} functionality but requires some additional functionality.
The \ac{PAKE} functionality is recalled in Chapter \ref{ch:prelims} Section \ref{sec:uc-prelims} for convenience.
In contrast to other password-related ideal functionalities such as \ac{VPAKE} \cite{Gentry2006} and \ac{PPSS} \cite{Camenisch2012} we consider only the key-exchange functionality without explicit client authentication.
While it is compelling to model \ac{2PAKE} (as well as \ac{PAKE}) similar to \cite{Camenisch2012} and allow for throttling on wrong password guesses,\footnotemark\ this is only possible if the servers are able to verify validity of the client's password, \ie explicit authentication of the client.
We want to keep the \ac{2PAKE} functionality simple and it is known that implicit authentication is sufficient for secure channels \cite{CanettiK01} and therefore stick with implicit authentication.

\footnotetext{Servers often lock accounts or require additional authentication after a certain number of failed log-in attempts. This prevents automated online dictionary attacks, which are always possible in the password authenticated key exchange setting.}

\paragraph{A Note on Corruption}
We consider static corruption, such that the corrupted parties are chosen by the adversary in advance.
If a server $\Server_b$ is corrupted, the adversary only learns $S_b$'s password share. 
The password stays secret as long as the attacker does not corrupt both servers.
While there exist \ac{2PAKE} protocols in literature that are \ac{UC}-secure with adaptive corruptions \cite{AbdallaBBCP13,AbdallaBP14a,AbdallaCCP09,AbdallaCP09}, we consider only static corruptions in this work.
Static corruption in the \ac{UC} model implies security in the \ac{BPR-M} model with adaptive corruptions for \ac{PAKE} protocols according to \citet{Canetti2005}.
However, adaptive corruptions are obviously a stronger security notion that allow an attacker not only to execute a protocol on behalf of an honest participant but interfere with the execution of an honest party while executing the protocol.
The only \ac{PAKE} constructions known today that are secure against adaptive corruptions in the \ac{UC} model require complex \ac{SPHF} constructions that are not translatable to the \ac{D-SPHF} approach.
It therefore seems reasonable to settle with static corruptions for \ac{2PAKE} \ac{UC} security for now.
We discuss the relation between the proposed \ac{UC} formalisation of \ac{2PAKE} and the known BPR-based security model in Section \ref{sec:relations}.

\paragraph{2PAKE Functionality}

\begin{figure}[tbp]
\begin{mdframed}[innertopmargin=10pt]
\begin{center}
{\bf Functionality $\cF_{\mathrm{2PAKE}}$}
\end{center}
The functionality $\cF_{\mathrm{2PAKE}}$ is parameterised with security parameter $\secpar$.
It interacts with an adversary \SIM, a client \Client and two servers $\Server_1$ and $\Server_2$ via the following interfaces.
Without loss of generality the key is exchanged between \Client and $\Server_1$.

\begin{description}

  \item[KEX Init$_\Client$:] Upon input $(\KEXinit, \sid, \qid, \pwd)$ from client \Client, check that \sid is $(\Client, \Server_1, \Server_2)$ and that \qid is unique (entries $(\KEX, \sid, \qid, S_{1}, \share_{1})$ or $(\KEX, \sid, \qid, S_{2}, \share_{2})$ may exist) and send $(\KEX, \sid, \qid, C)$ to \SIM.
      If this is a valid request, create a \emph{fresh} record $(\KEX, \sid, \qid, C, \pwd)$.
  
  \item[KEX Init$_\Server$:] Upon input $(\KEXinit, \sid, \qid, \share_b)$ from server $S_b$, $b\in\{1,2\}$, check that \sid is $(\Client, \Server_1, \Server_2)$ and that \qid is unique (entries $(\KEX, \sid, \qid, C, \pwd)$ or $(\KEX, \sid, \qid, S_{3-b}, \share_{3-b})$ may exist) and send $(\KEX, \sid, \qid, S_b)$ to \SIM.
      If this is a valid request, create a fresh record $(\KEX, \sid, \qid, S_b, \share_b)$.
    
  \item[TestPwd:] Upon input $(\TP, \sid, \qid, \pwd')$ from \SIM check that a fresh record $(\KEX, \sid, \qid, C, \pwd)$ exists. 
      If this is the case, mark $(\KEX, \sid, \qid, \Server_1, \share_1)$ as \compromised and reply with ``correct guess'' if $\pwd=\pwd'$, and mark it as \interrupted and reply with ``wrong guess'' if $\pwd\not=\pwd'$.
    
%   \item[TestShares:] Upon input $(\TS, \sid, \qid, \share'_1, \share'_2)$ from \SIM check that a fresh records $(\KEX, \sid, \qid, \Server_1, \share_1)$, $(\KEX, \sid, \qid, \Server_2, \share_2)$ and $(\KEX, \sid, \qid, C, \pwd)$ exist. 
%       If this is the case, mark  $(\KEX, \sid, \qid, C, \pwd)$ as \compromised and reply with ``correct guess'' if $\share'_1=\share_1 ~ \wedge ~ \share'_2=\share_2$ and as \interrupted and reply with ``wrong guess'' if $\share'_1\not=\share_1 ~ \vee ~ \share'_2\not=\share_2$.
      
  \item[Failed:] Upon input $(\FA, \sid, \qid)$ from \SIM check that records $(\KEX, \sid, \qid, C, \pwd)$ and $(\KEX, \sid, \qid, \Server_1, \share_1)$ exist that are not marked \completed. 
      If this is the case, mark both as \failed.
	
	\item[NewKey:] Upon input $(\NK, \sid,\qid, P, \sk')$ from \SIM with $P\in\{\Client,\Server_1\}$, check that a respective $(\KEX, \sid, \qid, C, \pwd)$ or $(\KEX, \sid, \qid, S, \share_1)$ record exists, $\sid=(\Client, \Server_1, \Server_2)$, $|\sk'|=\secpar$, then: %and the session is not marked for $P$ yet,
	\begin{itemize}
		\item If the session is \compromised, or either \Client or $\Server_1$ and $\Server_2$ are corrupted, then output $(\NK, \sid,\qid,\sk')$ to $P$; else
		
		\item if the session is \emph{fresh} and a key $\sk$ was sent to $P'$ with $\sid=(P, P', \Server_2)$ or $\sid=(P', P, \Server_2)$ while $(\KEX, \sid, \qid, P', \cdot)$ was fresh, then output $(\NK, \sid, \qid, \sk)$ to $P$.
		
		\item In any other case, pick a new random key $\sk$ of length $\secpar$, and send $(\NK, \sid, \qid, \sk)$ to $P$.
	\end{itemize}
	In any case, mark \qid as \completed for $P$.
	
\end{description}
\end{mdframed}
\caption{Ideal Functionality $\cF_{\mathrm{2PAKE}}$}
\label{fig:2pakef}
\end{figure}

The ideal functionality for \ac{2PAKE} is very similar to the \ac{PAKE} functionality but considers two servers from which only one generates a session key.
The main difference is therefore the explicit modelling of participants (in contrast to symmetric parties in the two-party case).
We specify two initialisation interfaces \textbf{KEX Init}, one for the client and one for the servers.
A client is initialised with a password \pwd while a server gets a password share $\share_b$.
The \textbf{TestPwd} interface allows the ideal world adversary to test client passwords.
A tested session is marked \interrupted if the guess is wrong, \ie client and server in this session receive randomly chosen, independent session keys, or marked as \compromised if the password guess is correct, \ie the attacker is now allowed to set the session key.
The attacker can only test client passwords but not password shares of the servers.
Without knowledge of the password or any password share, a share is a uniformly at random chosen element and therefore not efficiently guessable.
If the adversary corrupted server $\Server_2$, retrieving the second password share $\share_1$ from $\Server_1$ is equivalent to guessing the password.
Complementing the TestPwd interface is a \textbf{Failed} interface that allows the adversary to let sessions fail.
This allows the attacker to prevent protocol participants from computing any session, \ie failed parties do not compute a session key.
Eventually the \textbf{NewKey} interface generates session keys for client \Client and server $\Server_1$.
NewKey calls for $\Server_2$ are ignored.
If client \Client or server $\Server_1$ and $\Server_2$ are corrupted, or the attacker guessed the correct password, the adversary chooses the session key.
If a session key was chosen for the partnered party and the session was fresh at that time, \ie not \compromised or \interrupted, the same session key is used again.
In any other case a new random session key is drawn.

Instead of using a single session identifier \sid we use \sid and \qid.
%(as done in \cite{Camenisch_Lysyanskaya_Neven_2012})
The session identifier \sid is composed of the three participants $(\Client, \Server_1, \Server_2)$ (note that we use the client \Client also as ``username'' that identifies its account on the servers) and therefore human memorable and unique.
To handle multiple, concurrent \ac{2PAKE} executions of one \sid, we use a query identifier \qid that is unique within \sid and can be established with \Finit.
In the multi-session extension \FTWOPAKEM the \sid becomes \ssid and \sid is a globally unique identifier for the used universe, \ie server public keys (\ac{CA}) and \crs.


\subsubsection{Security Analysis}\label{sec:2pakeproof}
The following theorem formalises the security of the previously defined \ac{2PAKE} protocol.
Note that we do not rely on any security of the used \ac{TD-SPHF}.
Instead we reduce the security of our \ac{2PAKE} protocol directly to the underlying problem (\ac{SXDH}).
Thereby we give an indirect security proof of the proposed \ac{TD-SPHF}.
% For details on the security of the \ac{TD-SPHF} we refer to the full version.
 
\begin{theorem}\label{theo:uc2pake}
  The \ac{2PAKE} protocol from Section \ref{sec:2pakeprotocol} securely realises \FTWOPAKEM with static corruptions in the \Fcrs-\Fca-hybrid model if the \ac{DDH} assumption holds in $\GG_1$ and $\GG_2$ and $H_k$ is a universal one-way hash function, \ie Cramer-Shoup encryption is secure in $\GG_1$ and the \ac{DDH} assumption holds in $\GG_2$.
\end{theorem}

\paragraph{Sequence of Games}
We start the proof of Theorem \ref{theo:uc2pake} by giving a sequence of games with \G{1} equal to the real-world execution with honest participants following the protocol description and the real-world adversary \cA that may have control over a set of participants, and \G{17} equal to the ideal-world execution where the protocol is replaced with the ideal functionality \FTWOPAKE acting on behalf of all honest protocol participants and the ideal-world adversary \SIM, detailed later.
Let $\view_i$ denote the view of environment \cZ when interacting with game \G{i}.
Note that \view is implicitly parametrised with \sid and security parameter \secpar.
Security then follows from showing that each $\view_i$ is computationally indistinguishable from the subsequent $\view_{i+1}$, such that we can eventually follow by an hybrid argument that $\view_1$ and $\view_{17}$ are computationally indistinguishable and the protocol therefore securely realises the ideal functionality \FTWOPAKE.
All participants in the games are operated by challenger \Challenger (receiving the participants input from environment \cZ), which we modify from game to game.
Every session for an $\sid=(\Client, \Server_1, \Server_2)$ is started with a KexInit call for each participant, defining secrets, roles, and the used query identifier.
Invalid messages, \ie messages that do not pass the usual tests such as group membership, are discarded by the challenger.
Note that we usually only give the actual payload of messages and omit additional parts such as \sid, \qid etc.

\Gh Game $1$ is the real-world experiment in which \cZ interacts with real participants that follow, if honest, the protocol description, and the real-world adversary \cA controlling the corrupted parties.
All participants are honestly simulated by challenger \Challenger that knows all their inputs.

\Gh This game is identical to \G{\theoldgame}, except that \crs is generated by \Challenger such that it knows the according trapdoor $\tau$.
Note that the second trapdoor $\tau'$ for $\zeta$ is \emph{not} controlled by \Challenger yet as this would destroy any security.
Knowledge of $\tau$ allows \Challenger to decrypt ciphertexts $C_i$ to retrieve the used password (share).
This does not change anything and is therefore perfectly indistinguishable from \G{\theoldgame}.

\Gh When \Challenger, on behalf of $\Server_1$, receives first messages $(C_0, \hp_0)$ and $(C_2, \hp_2)$, it decrypts $C_0$ to $\pwd'$ and checks if this is the correct password, \ie $\pwd'=\pwd$.
If this is not the case, $\pwd'\not=\pwd$, \Challenger chooses a random $h'_0\rin\GG_T$ if the subsequent $\Hash_0$ computation with $\Server_2$ is successful, \ie all zero-knowledge proofs can be verified, and aborts $\Server_1$ otherwise.
We claim that $\view_{\theoldgame}$ is computationally indistinguishable from $\view_{\thegame}$.
The probability to distinguish the two games is bounded by the negligible probability to notice that $h_0$ is now chosen uniformly at random.
Since $C=(C_0, C_1, C_2)$ is not in $L_{\pwd, \share_1, \share_2}$ the computation of $\Hash_0$ between $\Server_1$ and $\Server_2$ yields a uniformly at random distributed hash value $h_0$.
This can be deduced by the following simplified argument.
% The hash value for $\Server_1$ is computed as
% \begin{align*}
%   h_0 &= e\left( g_{1,1}^{-\mu_1 \share_1} \cdot \left( g_{1,1}^{-\mu_1 \share_2} \cdot g_{1,1}^{-\mu_2 \share_1} \cdot g_{1,1}^{-\mu_2 \share_2} \cdot u_{1,0}^{\eta_{1,2}+\xi_0 \eta_{2,2}} \cdot u_{2,0}^{\theta_2} \cdot e_0^{\mu_2} \cdot v_0^{\nu_2} \right) \cdot u_{1,0}^{\eta_{1,1}+\xi_0\eta_{2,1}} \cdot u_{2,0}^{\theta_1} \cdot e_0^{\mu_1} \cdot v_0^{\nu_1}, g_2 \right) \\
% %   &= e\left( g_{1,1}^{-\mu_1 \share_1 -\mu_1 \share_2 -\mu_2 \share_1 -\mu_2 \share_2} \cdot u_{1,0}^{\eta_{1,2}+\xi_0 \eta_{2,2} + \eta_{1,1}+\xi_0\eta_{2,1}} \cdot u_{2,0}^{\theta_2 + \theta_1} \cdot e_0^{\mu_1 + \mu_2} \cdot v_0^{\nu_1 + \nu_2}, g_2 \right) \\
%   &= e\left( g_{1,1}^{(\pwd - \pwd')(\mu_1 + \mu_2)} \cdot u_{1,0}^{\eta_{1,2}+\xi_0 \eta_{2,2} + \eta_{1,1}+\xi_0\eta_{2,1}} \cdot u_{2,0}^{\theta_2 + \theta_1} \cdot h^{r_0(\mu_1 + \mu_2)} \cdot v_0^{\nu_1 + \nu_2}, g_2 \right).
% \end{align*}
As long as $C\not\in L_{\pwd, \share_1, \share_2}$ the same argument as used for \ac{SPHF} and \ac{D-SPHF} can be used, namely that $h_0$ is linearly independent from the adversarially known values and therefore indistinguishable from a random one.
However, this is not sufficient in this case as the attacker has the possibility to distinguish real $h_0$ values from random ones with use of the third projection keys $\hp_{3,i}$.
To show that this is not possible we show how to break the \ac{DDH} assumption in $\GG_2$ if there exists a distinguisher that can distinguish real $h_0$ from random ones.
To this end we build a \ac{DDH} triple $(\zeta, \fa, \fb)$ with $\crs'=\zeta=g_2^{\tau'}$ as follows.
% The first triple, $(\zeta, \fa, \fb)$, is \emph{not} a \ac{DDH} triple with random elements in $\GG_2$, $\fa,\fb\rin\GG_2$.
% We construct $(\zeta, \fa, \fb)$ as \ac{DDH} triple as follows.
Let $\fa=\zeta^\alpha$ and $\fb=g_2^\alpha$, then $(\zeta, \fa, \fb)$ is obviously a \ac{DDH} triple.
To link this to the \ac{TD-SPHF} we set $\alpha=\hk_{i,j}$, then $\fa=\hp_{3,i,j}=\zeta^{\hk_{i,j}}$ such that $\fb=g_2^{\hk_{i,j}}$. 
To build a non-DDH triple $(\zeta, \fa, \fb)$ we choose random $\bm \alpha$ and set $\fa=\hp_{3,i,j}=\zeta^{\hk_{i,j}}$ and $\fb=g_2^{\alpha_{j}}$.
To guarantee correctness we have to choose $\alpha$ such that $\alpha_j=\hk_{j,i}+\beta_j$ for $\beta\in\ker\begin{pmatrix}
  g_{1,1} & 1 & g_{1,2} & h & c \\
  1 & g_{1,1} & 1 & 1 & d
\end{pmatrix}$ for $j\in[1,5]$.
Note that this is possible because $\tau$ is known, which contains the secret Cramer-Shoup key.
If we can build a distinguisher on $h_0$, the distinguisher can now decide whether $(\zeta, \fa, \fb)$ is a valid \ac{DDH} triple or not.

% The idea here is to build a second hashing key $\widehat{\hk}_i$ that produces the same projection key $\hp_{1,i}, \hp_{2,i}$ but a different $\widehat{\hp}_{3,i}\not=\hp_{3,i}$.
% This is possible because we know $\tau$, which contains the secret Cramer-Shoup key $(x_1, x_2, y_1, y_2, z)$ for public key $(c=g_{1,1}^{x_1}g_{1,2}^{x_2}, d=g_{1,1}^{y_1}g_{1,2}^{y_2}, h=g_{1,1}^z)$ in the \crs such that we are able to compute $\widehat{\hp}_{3,i}=(g_2^{\alpha_1}, g_2^{\alpha_2}, g_2^{\alpha_3}, g_2^{\alpha_4}, g_2^{\alpha_5})$ with $\alpha_j=\hk_{j,i}+\beta_j$ for $\beta\in\ker\begin{pmatrix}
%   g_{1,1} & 1 & g_{1,2} & h & c \\
%   1 & g_{1,1} & 1 & 1 & d
% \end{pmatrix}$ for $j\in[1,5]$.

% We therefore build $\widehat{\hk}_i=(\widehat{\eta}_{1,i}, \widehat{\eta}_{2,i}, \widehat{\theta}_{i}, \widehat{\mu}_{i}, \widehat{\nu}_{i})$ such that 
% $\hp_{1,i}=g_{1,1}^{\widehat{\eta}_{1,i}} g_{1,2}^{\widehat{\theta}_{i}} h^{\widehat{\mu}_{i}} c^{\widehat{\nu}_{i}}$ and 
% $\hp_{2,i}=g_{1,1}^{\widehat{\eta}_{2,i}} d^{\widehat{\nu}_{i}}$.

% \smallskip
% In order to solve this with our attacker we have to define $\widehat{\hk}_i=()$ .
% We can build $(\zeta, \hp_{1,0}, \hp_{2,0}, \hp_{3,0}, \Gamma)$ with $\Gamma=(e(g_{1,1}, g_2^{\eta_{1,0} + \xi_0\eta_{2,0}}), e(g_{1,1}, g_2^{\theta_0}), e(g_{1,1}, g_2^{\mu_0}), e(g_{1,1}, g_2^{\nu_0}))$.

\Gh In this game we choose $\sk\rin\GG_T$ at random in case we choose $h_0$ at random (the setting described in \G{\theoldgame}) and computation of \sk on $\Server_1$ is successful.
% In case \theoldgame\xspace the password is not the correct one, and the session key computed on $\Server_1$ (if computed) is therefore supposed to be uniformly at random distributed.
Since $h_0$ on $\Server_1$ is uniformly at random already and $\sk=h_0h_x$, $\view_{\thegame}$ is perfectly indistinguishable from $\view_{\theoldgame}$.

\Gh Receiving an adversarially generated or modified $C_1$ or $C_2$ on behalf of client \Client, challenger \Challenger chooses $h_x\rin\GG_T$ uniformly at random instead of computing it with $\Hash_x$ if $C_1$ or $C_2$ do not encrypt the correct password share $\share_1$ or $\share_2$ respectively.
% Let this denote case \thegame.
We claim that $\view_{\thegame}$ is computationally indistinguishable from $\view_{\theoldgame}$.
In this case we have $(C_0,C_1,C_1)\not\in L_{\widehat{\pwd}}$ with overwhelming probability.
The claim therefore follows by a similar argument as in Game 3, \ie from the \ac{DDH} assumption in $\GG_2$.

\Gh In this game we choose $\sk\rin\GG_T$ at random in case we choose $h_x$ at random (the setting described in \G{\theoldgame}) and computation of \sk on \Client is successful (projection keys $\hp_1$ and $\hp_2$ are correct).
% In case \theoldgame\xspace the password shares encrypted in $C_1$ and $C_2$ do not reconstruct to \pwd, and the session key computed on \Client (if computed) is therefore supposed to be uniformly at random distributed.
Since $h_x$ on \Client is uniformly at random already and $\sk=h_0h_x$, $\view_{\thegame}$ is perfectly indistinguishable from $\view_{\theoldgame}$.

\Gh In this game we replace computation of hash values $h_0$ and $h_x$ 
with a lookup table with index $(\hk_1, \hk_2, L_{\pwd, \share_2, \share_2}, C_0)$ for $h_0$ and $(\hk_0, L_{\pwd, \share_2, \share_2}, C_1, C_2)$ for $h_x$.
If no such value exists, it is computed with the appropriate \Hash or \PHash function and stored in the lookup table.
Due to the correctness of the used Cramer-Shoup \ac{TD-SPHF} $\view_{\thegame}$ is perfectly indistinguishable from $\view_{\theoldgame}$.

\Gh Instead of computing $\Hash_0$ for $\Server_1$ in case $\pwd'$ decrypted from $C_0$ is the same as $\pwd$, \Challenger draws a random $h_0\rin\GG_T$.
% We denote this case 2.
That is, in this game $h_0$ for $\Server_1$ is always chosen uniformly at random instead of computing it with $\Hash_0$.
We claim that $\view_{\thegame}$ is computationally indistinguishable from $\view_{\theoldgame}$.
The claim follows from the \ac{CCA}-security of the labelled Cramer-Shoup encryption and the same argument as in Game 3, \ie from SXDH.
In particular, we define $\G{\theoldgame}'$ and $\G{\theoldgame}''$ with computationally indistinguishable views from \G{\theoldgame} as intermediate games before \G{\thegame} such that the claim follows.
Note that the following games modify the experiment only in the previously defined case.
In $\G{\theoldgame}'$ challenger \Challenger computes $C_1$ for $\Server_1$ on a random value $\share'_1\rin\ZZ_p$, $\share'_1\not=\share_1$.
The \ac{CCA}-security of the encryption scheme ensure that $\view_{\theoldgame'}$ is computationally indistinguishable from $\view_{\theoldgame}$.
In $\G{\theoldgame}''$ we choose a random $h_0\rin\GG_T$ instead of using the distributed $\Hash_0$ computation (the protocol is still performed but the values are not used).
Using the same argument as in \G{3}, $\view_{\theoldgame''}$ is computationally indistinguishable from $\view_{\theoldgame'}$.
The only difference between $\G{\theoldgame}''$ and \G{\thegame} now is that \Challenger encrypts a random value instead of $\share_1$ in $C_1$ in $\G{\theoldgame}''$.
The claim now follows by observing again that $\view_{\theoldgame''}$ and $\view_{\thegame}$ are computationally indistinguishable considering the \ac{CCA}-security of the labelled Cramer-Shoup encryption scheme.

\Gh In this game we choose $\sk\rin\GG_T$ at random in case we choose $h_0$ at random (the setting described in \G{\theoldgame}) and computation of \sk on $\Server_1$ is successful.
Since $h_0$ on $\Server_1$ is uniformly at random and $\sk=h_0h_x$, $\view_{\thegame}$ is perfectly indistinguishable from $\view_{\theoldgame}$.

\Gh Receiving correct $C_1$ or $C_2$, \ie encrypting $\share_1$ and $\share_2$ respectively, on behalf of client \Client, challenger \Challenger chooses $h_x\rin\GG_T$ uniformly at random instead of computing it with $\Hash_x$.
We claim that $\view_{\thegame}$ is computationally indistinguishable from $\view_{\theoldgame}$.
Since we have $(C_0,C_1,C_1)\in L_{\widehat{\pwd}}$ in this case, the claim follows by a similar argument as in Game 8, \ie from the SXDH assumption.

\Gh In this game we choose $\sk\rin\GG_T$ at random in case we choose $h_0$ at random (the setting described in \G{\theoldgame}) and computation of \sk on \Client is successful (projection keys $\hp_1$ and $\hp_2$ are correct).
% In case \theoldgame\xspace the password shares encrypted in $C_1$ and $C_2$ do not reconstruct to \pwd, and the session key computed on \Client (if computed) is therefore supposed to be uniformly at random distributed.
Since $h_x$ on \Client is uniformly at random already and $\sk=h_0h_x$, $\view_{\thegame}$ is perfectly indistinguishable from $\view_{\theoldgame}$.

% \Gh In this game we choose $\sk\rin\GG_T$ at random if $\Dec(C_0)=\Dec(C_1)+\Dec(C_2)$, computation of \sk is successful and no session key has been chosen for this session yet.
% If a session key $\sk$ has been chosen for this session already, this key is used.
% In game 9 and 10 $h_x$ for client \Client and $h_0$ are chosen uniformly at random such that $\view_{\thegame}$ is perfectly indistinguishable from $\view_{\theoldgame}$.

\Gh The entire \crs including $\zeta$ is chosen by challenger \Challenger in this experiment.
The $\view_{\thegame}$ is perfectly indistinguishable from $\view_{\theoldgame}$ since this does not change anything else.

\Gh Upon receiving $C_1$ and $C_2$, encrypting correct password shares, \Challenger uses $\THash_0$ to compute $h_0$ on client \Client instead of $\PHash_0$.
This is possible because \Challenger now knows trapdoor $\tau'$.
Due to \ac{TD-SPHF} soundness, $\view_{\thegame}$ is perfectly indistinguishable from $\view_{\theoldgame}$.

\Gh Upon receiving $C_0$, encrypting correct password, \Challenger uses $\THash_x$ to compute $h_x$ on server $\Server_1$ instead of $\PHash_x$.
This is again possible because \Challenger now knows trapdoor $\tau'$.
Due to \ac{TD-SPHF} soundness, $\view_{\thegame}$ is perfectly indistinguishable from $\view_{\theoldgame}$.

\Gh Instead of encrypting the correct password \pwd in $C_0$ on behalf of client \Client, \Challenger encrypts $0$ (which is not a valid password).
We claim that $\view_{\thegame}$ is computationally indistinguishable from $\view_{\theoldgame}$ under the \ac{DDH} assumption in $\GG_1$, \ie the \ac{CCA}-security of the Cramer-Shoup encryption.
Note that encryption randomness $r$ is not used in the computation of $h_0$ anymore such that the claim follows from the Cramer-Shoup \ac{CCA}-security.

\Gh Instead of encrypting the correct password share $\share_i$ in $C_i$ on behalf of server $S_i$ with $i\in[1,2]$, \Challenger encrypts a random element $\share'_i\rin\ZZ_p$.
We claim that $\view_{\thegame}$ is computationally indistinguishable from $\view_{\theoldgame}$ under the \ac{DDH} assumption in $\GG_1$, \ie the \ac{CCA}-security of the Cramer-Shoup encryption.
Note that the probability for $\share'_i=\share_i$ is negligible such that the claim follows from the Cramer-Shoup \ac{CCA}-security.

\Gh Instead of the challenger \Challenger simulating the protocol execution the ideal functionality \FTWOPAKE is used to interact with the ideal-world adversary \SIM.
While this game is structurally different from \G{\theoldgame} its execution is indistinguishable from the latter.
This combined with the following description of the ideal world adversary \SIM concludes the proof.


\paragraph{Simulator}
We now describe the simulator \SIM that is used in the last experiment and acts as an attacker in the ideal world against the ideal functionality \FTWOPAKE.
It uses a real-world adversary \cA in a way that the environment \cZ cannot  distinguish whether it is interacting with \cA and honest protocol participants in the real world, or with \SIM and dummy protocol participants (simulated by \FTWOPAKE) in the ideal world.
We describe \SIM for a single session $\sid=(\Client, \Server_1, \Server_2)$.
The security then follows from the \ac{UC} composition theorem \cite{Canetti2001a}, covering multiple sessions of the protocol, and joint-state \ac{UC} composition theorem \cite{CanettiR03}, covering the fact that \Fca and \Fcrs create a joint state for all sessions and participants.
As before, we assume that $0$ is not a valid password.

First, \SIM generates $\crs=(p,g_{1,1},g_{1,2},h,c,d,\GG_1,g_{2},\zeta,\GG_2,\GG_T,e,H_k)$ with Cramer-Shoup secret key as trapdoor $\tau=(x_1,x_2,y_1,y_2,z)$ and second trapdoor $\tau'$ for $\zeta=g_2^{\tau'}$ to answer all \Fcrs queries with \crs.
Further, \SIM generates ElGamal key pairs $(g^{z_1},z_1)$ and $(g^{z_2},z_2)$, and responds to $\Retrieve(S_i)$ queries to \Fca from $S_i$ with $(\Retrieve, S_i, (g^{z_i},z_i))$ for $i\in\{1,2\}$ and with $(\Retrieve, S_i, g^{z_i})$ to all other request.
We describe different scenarios in which the simulator operates.
First we describe simulation of the initial KEXInit call before showing the way \SIM handles different input messages and the key generation.
The simulator essentially has to ensure that the functionality chooses random, correct session keys if the execution is correct and random, independent ones in case of an error during the execution.

% \hfill\\\noindent
% {\bf A) Honest Client:}
% Consider that client \Client is honest.
% We describe the four possible cases with i) two honest servers, ii) server $\Server_2$ is corrupted, iii) server $\Server_1$ is corrupted and iv) both servers are corrupted.
% The first case describes the entire default simulation while for all other cases we give only differences to the first case.
% 
% \begin{enumerate}[i)]
%   \item In this setting all parties $C, \Server_1, \Server_2$ are honest such that the entire protocol is simulated by \SIM and the attacker \cA has control over the network in between.
        When receiving $(\KEX, \sid, \qid, P)$ with $\sid=(\Client, \Server_1, \Server_2)$ and $P\in\{\Client, \Server_1, \Server_2\}$ from \FTWOPAKE, \SIM starts simulation of the protocol for protocol participant $P$ by computing ciphertext, projection key pair $M_i=(C_i, \hp_i)$ for $i\in\{0,1,2\}$, encrypting a dummy value ($0$ for $P=\Client$ and a random value $\share'_i\rin\ZZ_p$ for $P=\Server_i$, $i\in\{1,2\}$).
        \SIM outputs the computed $(C_i, \hp_i)$ to \cA.
        The first round of messages is handled as follows.
        
\begin{enumerate}
  \item When any party receives an adversarially generated but well formed first message $M_i$, $i\in\{1,2\}$ from uncorrupted $S_i$, \ie $\VerHp$ on the projection key $\hp_i$ is $1$, \SIM queries $(\FA, \sid, \qid)$, which marks the session \failed for the receiving party and thus ensures that the party receives an independent, random session key (if any) on a NewKey query.
        
  \item When any party receives an adversarially generated but well formed first message $M_2$ from a corrupted $\Server_2$ while $\Server_1$ is not corrupted, \SIM decrypts $C_2$ to $\share'_2$.
        If this value is not correct, $\share'_2\not=\share_2$ (the party is corrupted such that \SIM knows the correct value), \SIM queries $(\FA, \sid, \qid)$ to ensure independent session keys on NewKey queries.    
        
  \item When client \Client receives an adversarially generated but well formed first message $M_1$ from a corrupted $\Server_1$ while $\Server_2$ is not corrupted, \SIM decrypts $C_1$ to $\share'_1$.
        If this value is \emph{not} correct, $\share'_1\not=\share_1$, \SIM queries $(\FA, \sid, \qid)$ to ensure independent session keys on NewKey queries.    
        
  \item When any party receives adversarially generated but well formed first messages $M_1, M_2$ from corrupted $\Server_1, \Server_2$, \SIM decrypts $C_1$ and $C_2$ to $\share'_1$, $\share'_2$ respectively, and verifies their correctness against $\share_1$ and $\share_2$.
        If they are correct, \SIM computes $h_0\gets\THash_0(\hp_1, \hp_2,  L_{\pwd, \share_1, \share_2}, C_0, \tau')$, $h_x\gets\Hash_x(\hp_0, L_{\widehat{\pwd}}$, $C_1, C_2)$, and $\sk_\Client=h_0\cdot h_x$.
        Otherwise choose a random $\sk_\Client\in\GG_T$.
         
  \item When an honest $\Server_1$ or $\Server_2$ receives an adversarially generated but well formed first message $M_0$, \ie $\VerHp$ on $\hp_0$ is $\true$, \SIM extracts $\pwd'$ from $C_0$ and sends $(\TP, \sid, \qid, C, \pwd')$ to \FTWOPAKE.
        If the functionality replies with ``correct guess'', \SIM uses $\pwd'$, \crs and $\tau'$ to compute $h_x\gets\THash_x(\hp_0, L_{\widehat{\pwd}}, C_1, C_2, \tau')$, $h_0\gets\Hash_0(\hk_1, \hk_2, L_{\pwd, \share_1, \share_2}, C_0)$, and $\sk_\Server=h_0\cdot h_x$.
        
  \item If verification of any $\hp_i$ fails at a recipient, \SIM aborts the session for the receiving participant.
\end{enumerate}  

\noindent              
        If a party does not abort, it proceeds as follows.
        After \Client received all ciphertext, projection key pair messages and the previously described checks were performed \SIM sends $(\NK, \sid, \qid, C, \sk_\Client)$ to \FTWOPAKE if an $\sk_\Client$ for this session exists, or $(\NK, \sid, \qid, C, \bot)$ otherwise.
        %, which triggers \FTWOPAKE to either choose a random session key $\sk$, or use $\sk$ if $M_1$ and $M_2$ are unchanged and $sk$ was sent to $\Server_1$ earlier, and output $(\NK, \sid, \qid, \sk)$ to \Client.       $(\sid, \qid, 0, \Server_1, C_1, \hp_1)$ and $(\sid, \qid, 0, \Server_2, C_2, \hp_2)$
        After $\Server_1$ and $\Server_2$ received all ciphertext, projection key pair messages and the previously described checks were performed, \SIM simulates all further messages for honest parties, \ie $\PHash_x$ and $\Hash_0$ computation between $\Server_1$ and $\Server_2$, with random elements and simulated zero-knowledge proofs.
        If all messages received by $\Server_1$ are oracle generated, send $(\NK, \sid, \qid, \Server_1, \sk_\Server)$ to \FTWOPAKE if this session is \compromised and $(\NK, \sid, \qid, \Server_1, \bot)$ if not.
        %, which triggers \FTWOPAKE to either choose a random session key $\sk$, or uses $\sk$, sent to \Client earlier, and output $(\NK, \sid, \qid, \sk)$ to $\Server_1$.
        If any $\PHash_x$ or $\Hash_0$ message received by $\Server_1$ can not be verified, \ie validation of the zero-knowledge proof fails, \SIM does nothing and aborts the session for $\Server_1$.
        
        

\subsection{\FTWOPAKE Discussion}\label{sec:relations}
In this section we discuss some additional points of the \FTWOPAKE functionality and investigate relations to other \ac{2PAKE} security models and \ac{UC} models in the password setting.

\subsubsection{\FTWOPAKE and the BPR \ac{2PAKE} Model}
While other security models for \ac{2PAKE} protocols where proposed, \eg by \citet{SzydloK05}, the \ac{BPR-M}-like security model from \citet{Katz2012a} is the most comprehensible and (in its two-party version) established model.
We therefore discuss relation between the proposed \ac{2PAKE} \ac{UC}-security using \FTWOPAKE and the \ac{BPR-M}-like security model by \citet{Katz2012a}.
To compare security of a \ac{2PAKE} protocol $\Pi$ in a game-based and \ac{UC} setting we have to ensure that it supports session ids (necessary in the \ac{UC} framework).
We therefore assume that $\Pi$ already uses \ac{UC} compliant session ids.
Note that it is easy to transform any \ac{2PAKE} protocol into a \ac{2PAKE} protocol with such session ids.
Before looking into relation between the full game-based model for \ac{2PAKE} and \FTWOPAKE we want to point out that a protocol $\Pi$ that securely realises \FTWOPAKE offers ``forward secrecy'', \ie even an adversary that knows the correct password is not able to attack an execution of $\Pi$ without actively taking part in the execution.
With this in mind we argue that $\Pi$, securely realising \FTWOPAKE, is secure in the BPR-like model by \citet{Katz2012a}.
This is because the attacker is either passive, which is covered by the previous observation, or is active and is therefore able tests one password.
Those password tests (\TestPwd in \FTWOPAKE and \Send in the game based model) give the attacker a success probability of $q/|\cD|$, with $q$ the number of active sessions and $|\cD|$ the dictionary size, when considering a uniform distribution of password dictionary \cD.
Note that while the attacker may have knowledge of a password share, this does not increase this probability.
Security of the model from \citet{Katz2012a} follows.

\subsubsection{\FTWOPAKE and \FPAKE}
While \FPAKE and \FTWOPAKE are very similar they contain some significant difference we want to point out here.
First, the key-exchange is performed between all three participants, but only \Client and, w.l.o.g., $\Server_1$ agree on a common session key.
The \role is a technical necessity in \FPAKE for correct execution.
Since we have explicit roles in \FTWOPAKE this is not necessary here.
% Due to the asymmetry in \FTWOPAKE (a client negotiates with two servers) we assume that the client is always the invoking party.
% While this is the case in \FPAKE as well when considering a real world scenario, the roles might be different there such that any of the two participating parties can start the protocol execution.
The asymmetric setting in \FTWOPAKE restricts \TestPwd queries to the client since the servers hold high entropy password shares.
While it is enough for the attacker to corrupt one party in \FPAKE to control the session key, in \FTWOPAKE \SIM has to either corrupt or compromise the client, or corrupt both servers.
As long as only one server is corrupted, the adversary has no control over the session 	keys and the parties receive uniformly at random chosen session keys.
In \FTWOPAKE session ids are human memorisable, consisting of all three involved parties $(\Client, \Server_1, \Server_2)$, and a unique query identifier is used to distinguish between different (possibly concurrent) protocol runs of one account (\sid).
This is a rather technical difference to \FPAKE that uses only session identifiers.

% This allows both servers to negotiate a session key with \Client by running the protocol twice with swapped roles.
	
% 	\item \FPAKE does not allow for any throttling mechanisms to avoid online dictionary attacks. 
% 	  This is an inherent shortcoming of the current \FPAKE definition and should be fixed, but is out of scope of this work.
% 	  However, we design our \FTWOPAKE functionality such that servers can refuse authentication queries from client according to a policy we do not further describe.
% 	  A general policy could be for example to refuse login attempts after three failed attempts and require additional out of band authentication thereafter to reset this counter.
% 	  Note that this does not require the protocol to provide mutual authentication as the success of a protocol can be established by the servers using other means, \eg subsequent traffic.


\subsubsection{Corruptions}
The two-server extension of the \ac{BPR-M} \ac{2PAKE} model proposed by \citet{Katz2012a} does not consider corruptions.
While parties can be malicious in the model (static corruption), the attacker is not allowed to query a corrupt oracle to retrieve passwords or internal state of participants.
In our model the attacker is allowed to corrupt parties before execution as well.
This however implies security in the model by \citet{Katz2012a} even if the attacker is allowed to corrupt clients to retrieve their passwords.
This is because the environment can provide the BPR attacker with the password.
However, this does not increase his success probability.
Dynamic corruptions in \FTWOPAKE on the other hand are much more intricate.
While \ac{UC}-secure \ac{2PAKE} protocols with dynamic corruptions exist \cite{AbdallaBP14a} their approaches are not translatable to the \ac{2PAKE} setting.
The challenge of dynamic corruptions is that the simulation has to be correct even if the attacker corrupts one party \emph{after} the protocol execution has started.
This is left open for future work.
