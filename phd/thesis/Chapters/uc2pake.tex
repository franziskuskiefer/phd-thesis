\section{UC Security for Two-Server PAKE}
\mynote{move this to the beginning of 2PAKE stuff and leave only UC stuff here (maybe)}
Password Authenticated Key Exchange (PAKE) protocols have been extensively researched over the last twenty years.
They allow two protocol participants, holding a low-entropy secret (password) each, to negotiate an authenticated session key.
Several security models have been developed including the well-known game-based notion from Bellare, Pointcheval and Rogaway \cite{Bellare2000,Abdalla2005a} and a notion in the universal composability (UC) framework \cite{Canetti2005}.
While PAKE protocols can be executed between two humans holding the same password, they are usually considered in a client, server scenario where the client registers with a server that then stores the password and uses it in subsequent sessions to authenticate the client.
This approach however leads to an intrinsic weakness regarding server compromise.
As soon as a server, storing client passwords is compromised the attacker learns the passwords.
This allows the attacker to log into the client's account on the server and most likely also on others if the client re-used the password across multiple servers.
Mechanisms have been proposed to solve the problem of server compromise.
In particular verifier-based PAKE \cite{Gentry2006,rfc2945,BenhamoudaP13}, also known as augmented PAKE \cite{BellovinM93}, considers an asymmetric setting in which the server uses a function of the password (verifier) to verify a client holding the corresponding password.
However, as long as only one server is used, PAKE protocols are prone to offline dictionary attacks on the server side, i.e. server attacks still leak password verifiers that allow to recover the password, which is rather efficiently with current methods \cite{hashcat,johntheripper}.

Two-server PAKE (2PAKE) protocols solve this problem by splitting the password in two parts such that a malicious or compromised server can only recover a password share that does not allow to recover the password.
In contrast to PAKE protocols 2PAKE protocols are less well studied.
2PAKE can be seen as a special case for $t=n=2$ of threshold PAKE where $t$ out of $n$ servers, participating in the protocol and holding a password share, must be honest.
Raimondo and Gennaro \cite{Raimondo_Gennaro_2003} and MacKenzie, Shrimpton and Jakobson \cite{MacKenzie_Shrimpton_Jakobsson_2002} were among the firsts to propose t-out-of-n password authenticated key exchange protocols.
The former is not suitable for 2PAKE as it needs $t<n/3$ while the latter requires a PKI in addition to the password.
The first real two-server PAKE protocol is due to Brainard and Jules \cite{Brainard_Juels_2003}, which was proven secure by Szydlo and Kaliski \cite{SzydloK05} in a modified version.
The first two server PAKE with thorough security model based on the classical game-based BPR model is due to Katz, MacKenzie,  Taban and Gligor \cite{KatzMTB05}, which was recently generalised to a two-server PAKE framework by Kiefer and Manulis \cite{KieferM14a}.
Threshold and two-server password authenticated key exchange is closely related to password authenticated secret sharing (PASS).
Password authenticated secret sharing was first proposed as password protected secret sharing by Bagherzandi, Jarecki, Saxena and Lu in 2011 \cite{Bagherzandi2011} and gained a lot of attention since then \cite{Camenisch_Lysyanskaya_Neven_2012,JareckiKK14,CamenishEN15}.
As shown in \cite{JareckiKK14} PASS can also be used to implement efficient threshold PAKE protocols.
While using the universally composability framework to prove security of the PASS primitive, none of these papers give a threshold or two-server PAKE protocol secure in UC.

In this work we propose the first notion of UC security for two-server PAKE protocols and give an efficient protocol in the standard model with common reference string and static corruptions.
To this end we leverage recent advancements of smooth projective hashing in the two-server setting from \cite{KieferM14a} and in efficiency from \cite{Benhamouda2013}.

%==============================================================================
% Trapdoor D-SPHF
%==============================================================================


\subsection{Trapdoor D-SPHF}\label{sec:tdsphf}
The 2PAKE protocol we propose in the following section makes use of trapdoor smooth projective hashing in order to allow efficient instantiation.
Trapdoor SPHFs enable single round PAKE protocols because they achieve simulatability even in the case where the attacker guessed the correct password.
To use \TSPHF in the two-server setting we extend the notion of trapdoor SPHFs (cf. Section \ref{sec:tsphf}) to the distributed setting of D-SPHFs (cf. Section \ref{sec:dsphf}).
While our description is specific to the two-server PAKE setting with languages over Cramer-Shoup ciphertexts an extension to more servers and other languages is straightforward along the lines of \DSPHF.

\begin{definition}[TD-SPHF]\label{def:tdsphf}
Let $L_{\widehat{\pwd}}$ denote a language such that $C=(C_0,C_1,C_2)\in L_{\widehat{\pwd}}$ if there exists a witness $r=(r_0,r_1,r_2)$ proving so, $\pwd=\pwd_1+\pwd_2$ and there exists a function $\Dec'$ such that $\Dec'(C_1 C_2)=\Dec'(C_0)$.
% and $g:\GG^l\mapsto\GG^{l'}$ as described above.
A trapdoor distributed smooth projective hash function for language $L_{\widehat{\pwd}}$ consists of the following ten algorithms:

\begin{itemize}
	\item $(\crs',\tau')\ralgout\TSetup(\crs)$ generates $\crs'$ with trapdoor $\tau'$ from \crs

	\item \HKGen, \PKGen, $\Hash_x$, $\PHash_x$, $\Hash_0$, $\PHash_0$ behave as for D-SPHF
	
	\item $b\algout\VerHp(\hp,L_{\widehat{\pwd}})$ returns $b=1$ iff \hp is a valid projection key and $b=0$ otherwise
	
	\item $h_x\algout\THash_x(\hp_0,L_{\widehat{\pwd}},C_1,C_2,\tau')$ computes hash value $h_x$ of ciphertexts $C_1$ and $C_2$ using projection key $\hp_0$ and trapdoor $\tau'$
	
	\item $h_0\algout\THash_0(\hp_1,\hp_2,L_{\widehat{\pwd}},C_0,\tau')$ computes hash value $h_0$ of $C_0$ using projection keys $\hp_1$ and $\hp_2$, and trapdoor $\tau'$
\end{itemize}
\end{definition}


% \subsubsection{TD-SPHF Security}\label{sec:tdsphf-security}
\noindent
Security of \TDSPHF can be derived from \DSPHF security and the extensions made on SPHFs for T-SPHFs.
However, we do not consider security of \TDSPHF on its own but rather incorporate it in the security proof of the 2PAKE protocol in the following section.
This is due to the fact that description of \TDSPHF is done only for this specific application such that a separate security definition is more distracting than giving any benefit.
However, we define correctness and soundness of \TDSPHF since they differ from that of \DSPHF.
In particular, \emph{correctness} of TD-SPHFs extends correctness of D-SPHFs by the statement that for every  valid ciphertext triple $(C_0,C_1,C_2)$, generated by \cL, and honestly generated keys $(\hk_0,\hk_1,\hk_2)$ and $(\hp_0,\hp_1,\hp_2)$, it holds not only that 
\begin{align*}  
&\Hash_0(\hk_1, \hk_2, L_{\widehat{\pwd}}, C_0)=\PHash_0(\hp_1, \hp_2, L_{\pwd, \pwd_1, \pwd_2}, C_0, r_0) \text{ and} \\
&\Hash_x(\hk_0, L_{\widehat{\pwd}}, C_1, C_2)=\PHash_x(\hp_0, L_{\pwd, \pwd_1, \pwd_2}, C_1, C_2, r_1, r_2)
\end{align*}
but also that $\VerHp(\hp_i, L_{\widehat{\pwd}})=1$ for $i\in\{0,1,2\}$ and 
\begin{align*}
&\Hash_0(\hk_1, \hk_2, L_{\widehat{\pwd}}, C_0)=\THash_0(\hp_1, \hp_2, L_{\pwd, \pwd_1, \pwd_2}, C_0, \tau') \text{ and} \\
&\Hash_x(\hk_0, L_{\widehat{\pwd}}, C_1, C_2)=\THash_x(\hp_0, L_{\pwd, \pwd_1, \pwd_2}, C_1, C_2, \tau').
\end{align*}
To capture soundness of TD-SPHFs we define \emph{$(t,\varepsilon)$-soundness}, complementing the previous correctness extension, as follows.

\begin{definition}[TD-SPHF $(t,\varepsilon)$-soundness]\label{def:tdsphf-soundness}
Given \crs, $\crs'$ and $\tau$, no adversary running in time at most $t$ can produce a projection key \hp, a password \pwd with shares $\pwd_1$ and $\pwd_2$, a word $(C_0,C_1,C_2)$, and valid witness $(r_0,r_1,r_2)$, such that $(\hp_0,\hp_1,\hp_2)$ are valid, i.e. $\VerHp(\hp_i,L_{\widehat{\pwd}})=1$ for $i\in\{0,1,2\}$, but 
\begin{align*}
&\THash_x(\hp_0,L_{\widehat{\pwd}},C_1, C_2, \tau')\not=\PHash_x(\hp_0,L_{\widehat{\pwd}}, C_1, C_2, r_1, r_2) \text{ or} \\
&\THash_0(\hp_1, \hp_2, L_{\widehat{\pwd}}, C_0, \tau')\not=\PHash_0(\hp_1, \hp_2, L_{\widehat{\pwd}}, C_0, r_0)
\end{align*}
with probability at least $\varepsilon(\secpar)$.
The perfect soundness states that the property holds for any $t$ and any $\varepsilon(\secpar)>0$.
\end{definition} 

\subsubsection{Cramer-Shoup TD-SPHF}\label{sec:cs-tdsphf}
Extending the Cramer-Shoup \DSPHF (cf. Appendix \ref{app:dsphf}) to a \TDSPHF is straight-forward combining it with the Cramer-Shoup \TSPHF.
This \TDSPHF is, like the Cramer-Shoup \TSPHF (cf. Appendix \ref{app:tsphf}), defined over groups with bilinear pairings (cf. Section \ref{sec:preliminaries}).
Let $C=(\ell, u_1, u_2, e, v)$ denote a Carmer-Shoup ciphertext as defined in Section \ref{sec:csencryption}.
% We only describe the differences to the previous CS \DSPHF.
% $\pk=(p,\GG_1,\GG_2,\GG_T,e,g_{11},g_{12},c,f,h,H_k)$ and $c=g_{11}^{x_1}g_{12}^{x_2}, d=g_{11}^{y_1}g_{12}^{y_2}, h=g_{11}^z$ s.t. $dk=(x_1,x_2,y_1,y_2,z)$

\begin{itemize}
	\item $\TSetup(\crs)$ draws a random $\tau'\rin\ZZ_q$ and computes $\crs'=\zeta=g_2^{\tau'}$
	
	\item $\HKGen(L_{\widehat{\pwd}})$ returns $\hk_i=(\eta_{1,i},\eta_{2,i},\theta_i,\mu_i,\nu_i)\rin\ZZ_p^{1\times 5}$ for $i\in\{0,1,2\}$
	
  \item $\PKGen(\hk_i, L_{\widehat{\pwd}})$ generates 
      $\hp_i=(\hp_{1,i}=g_{1,1}^{\eta_{1,i}} g_{1,2}^{\theta_i} h^{\mu_i} c^{\nu_i}, \hp_{2,i}=g_{1,1}^{\eta_{2,i}} d^{\nu_i}, \hp_{3,i})$ with
      $\hp_{3,i}=(\chi_{1,1,i}, \chi_{1,2,i}, \chi_{2,i}$, $\chi_{3,i}, \chi_{4,i})$ and 
      $\chi_{1,1,i}={\zeta}^{\eta_{1,i}}, \chi_{1,2,i}={\zeta}^{\eta_{2,i}}, \chi_{2,i}={\zeta}^{\theta_i}, \chi_{3,i}={\zeta}^{\mu_i}, \chi_{4,i}={\zeta}^{\nu_i}$ for $i\in\{0,1,2\}$
  
  \item $\Hash_x(\hk_0, L_{\widehat{\pwd}}, C_1, C_2)$ computes 
      $h'_x=(u_{1,1}\cdot u_{1,2})^{\eta_{1,0}+(\xi_1+\xi_2)\eta_{2,0}} (u_{2,1}\cdot u_{2,2})^{\theta_0} ((e_1\cdot e_2)/g_{1,1}^{\pwd})^{\mu_0} (v_1\cdot v_2)^{\nu_0}$
      and returns $h_x=e(h'_x,g_2)$
  \item $\PHash_x(\hp_0, L_{\widehat{\pwd}}, C_1, C_2, r_1, r_2)$ computes 
      $h'_x=\hp_{1,0}^{r_1+r_2} \hp_{2,0}^{\xi_1 r_1+\xi_2 r_2}$
      and outputs $h_x=e(h'_x,g_2)$
  \item $\Hash_0(\hk_1, \hk_2, L_{\widehat{\pwd}}, C_0)$ computes 
      $h'_0=u_{1,0}^{\eta_{1,1}+\eta_{1,2}+\xi_0(\eta_{2,1}+\eta_{2,2})} u_{2,0}^{\theta_1+\theta_2} (e_0/g_{1,1}^{\pwd})^{\mu_1+\mu_2} v_0^{\nu_1+\nu_2}$
      and outputs $h_0=e(h'_0,g_2)$
  \item $\PHash_0(\hp_1, \hp_2, L_{\widehat{\pwd}}, C_0, r_0)$ computes $h'_0=(\hp_{1,1}\hp_{1,2})^{r_0} (\hp_{2,1}\hp_{2,2})^{r_0\xi_0}$
      and outputs $h_0=e(h'_0,g_2)$
	
  \item $\VerHp(\hp_i, L_{\widehat{\pwd}})$ verifies that 
      $e(\hp_{1,i}, \crs')\stackrel{?}{=} e(g_{1,1}, \chi_{1,1,i})\cdot e(g_{1,2}, \chi_{2,i})\cdot e(h, \chi_{3,i})\cdot e(c, \chi_{4,i})$ and
      $e(\hp_{2,i}, \crs')$ $\stackrel{?}{=}$ $e(g_{1,1}$, $\chi_{1,2,i})\cdot e(d, \chi_{4,i})$ for $i\in\{0,1,2\}$

  \item $\THash_0(\hp_1, \hp_2, L_{\widehat{\pwd}}, C_0, \tau')$ computes 
      \[h_0=\left[ e(u_{1,0}, \chi_{1,1,1}\chi_{1,1,2}(\chi_{1,2,1}\chi_{1,2,2})^{\xi_0})\cdot e(u_{2,0}, \chi_{2,1}\chi_{2,2})\cdot e(e_0/g_{1,1}^{\pwd}, \chi_{3,1}\chi_{3,2})\cdot e(v_0, \chi_{4,1}\chi_{4,2}) \right]^{1/\tau'}\]
			
	\item $\THash_x(\hp_0, L_{\widehat{\pwd}}, C_1, C_2,\tau')$ computes 
    	\[h_x=\left[ e(u_{1,1} u_{1,2}, \chi_{1,1,0}\chi_{1,2,0}^{\xi_1+\xi_2}) \cdot e(u_{2,1} u_{2,2}, \chi_{2,0}) \cdot e( (e_1 e_2) / g_{1,1}^{\pwd}, \chi_{3,0}) \cdot e( v_{1} v_2, \chi_{4,0})\right]^{1/\tau'}\]
\end{itemize}

\noindent
Distributed computation of $\PHash_x$ and $\Hash_0$ is done as in \DSPHF with additional proofs for correctness and adding the pairing computation at the end to lift the hash value into $\GG_T$.
We formalise execution of the Cramer-Shoup \TDSPHF in Figure \ref{fig:cs-tdsphf}.
Necessary zero-knowledge proofs are described in the following two paragraphs and only referenced in Figure \ref{fig:cs-tdsphf}.
We describe the $\Sigma$ protocol here, which is then used in the committed version (cf. Section \ref{sec:zk}).
While the constructions are $\Sigma$ proofs (and therefore honest verifier zero-knowledge proofs of knowledge) we regard them as zero-knowledge proofs (without knowledge extractor) in order to avoid the necessity of rewinding the prover.
% Note that we merge \crs and $\crs'$ here for readability.
Protocol participants are denoted $C$, $S_1$ and $S_2$ if their role is specified, or $P$, $Q$ and $R$ otherwise.
Let further $0$ denote the client's index and $1$, respectively $2$, denote the indices of server $S_1$, $S_2$ respectively.
The session ID is given by $\sid=C||S_1||S_2$ and the unique query identifier \qid is agreed upon start using \Finit.

All \TDSPHF participants have $\crs=(q,g_{1,1},g_{1,2},h,c,d,\GG_1,g_{2},\zeta,\GG_2,\GG_T,e,H_k)$ as common input where $\tau=(x_1,x_2,y_1,y_2,z)$ is the \crs trapdoor, i.e. the according Cramer-Shoup secret key, and $\tau'$ the trapdoor, i.e. discrete logarithm to base $g_2$, of $\crs'=\zeta$.
Each server holds an ElGamal key pair $(\pk_1, \sk_1)$ and $(\pk_2, \sk_2)$ respectively such that $\pk_1$ is registered with the \CA for $S_1$ and $\pk_2$ for $S_2$ and thus available to all parties (using \Fca).
An, otherwise unspecified, protocol participant $P$ is initiated with $(\NS, \sid, \qid, P, x)$.
We further define $\pwd_0=\pwd$.
%use $P_i$ for party $i\in[1,2,3]$ and
% When $P$ is activated with a NewSession query $(\NS, \sid, \qid, P, x)$ it proceeds as follows.


\begin{figure}[htbp]
\begin{mdframed}[innertopmargin=10pt]
\begin{center}
\caption{Cramer-Shoup \TDSPHF}
\label{fig:cs-tdsphf}
% {\bf Cramer-Shoup \TDSPHF}\smallskip
\end{center}

% \begin{description}\itemsep5pt
	
% 	\item[NewSession:] When $P_i$ is activated with $(\NS, \sid, \qid, P_i, x, \role)$ it proceeds as follows.\smallskip
	  \begin{enumerate}
	    \item Generate \TDSPHF keys $\hk_i\rin\ZZ_q^{5}$ and 
	      $\hp_i=(\hp_{1,i}=g_{1,1}^{\eta_{1,i}} g_{1,2}^{\theta_i} h^{\mu_i} c^{\nu_i}, \hp_{2,i}=g_{1,1}^{\eta_{2,i}} d^{\nu_i}, \chi_{1,1,i}={\zeta}^{\eta_{1,i}}, \chi_{1,2,i}={\zeta}^{\eta_{2,i}}, \chi_{2,i}={\zeta}^{\theta_i}, \chi_{3,i}={\zeta}^{\mu_i}, \chi_{4,i}={\zeta}^{\nu_i})$. 
	    Encrypt $\pwd_i$ to $C=(\ell_i,u_{1,i},u_{2,i},e_i,v_i)\gets(\ell, g_{1,1}^{r_i}, g_{1,2}^{r_i}, h^{r_r} g_{1,1}^{\pwd_i}, (cd^{\xi_i})^{r_i})$ with $\xi_i=H_k(\ell_i, u_{1,i}, u_{2,i}, e_i)$ for $\ell_i=\sid || \qid || \hp_i$ and $r_i\rin\ZZ_q$.
	    If $P=S_1$, set $h_0=h_x=\NULL$.
	    Output $(\sid,\qid,0,P,C_i,\hp_i)$ to $Q$ and $R$.
	    
	    \item When $P$, waiting for the initial messages, is receiving a message $(\sid,\qid,0,Q,C_1,\hp_1)$ and $(\sid,\qid,0,R,C_2,\hp_2)$ it proceeds as follows.
	      $P$ proceeds only if the projection keys $\hp_1$ and $\hp_2$ are correct, i.e. $\VerHp(\hp_1, L_{\widehat{\pwd}})=1$ and $\VerHp(\hp_2, L_{\widehat{\pwd}})=1$.
	          If the verification fails, $P$ outputs $(\sid, \qid, \bot, \bot)$ and aborts the protocol.
	      \begin{enumerate}
	        \item If $P=C$, compute \\
	          $ h_x=e\left((u_{1,1}\cdot u_{1,2})^{\eta_{1,0}+(\xi_1+\xi_2)\eta_{2,0}} (u_{2,1}\cdot u_{2,2})^{\theta_0} ((e_1\cdot e_2)/g_{1,1}^{\pwd})^{\mu_0} (v_1\cdot v_2)^{\nu_0}, g_2\right) $ and \\
	          $ h_0=e\left( (\hp_{1,1}\hp_{1,2})^{r_0} (\hp_{2,1}\hp_{2,2})^{r_0\xi_0}, g_2 \right)$,
	          and outputs $(\sid, \qid, h_0, h_x)$.\\
	        \item If $P=S_2$, compute
	          $h_{x,2} = (\hp_{1,0} \cdot \hp_{2,0}^{\xi_2})^{r_2}$ and 
	          $C_{h_{x,2}}=g_{1,1}^{H(h_{x,2}, \Comm_{1})} h^{r_{c1}}$ with $r_{c1}\rin\ZZ_q$
% 	          $t_1=(\hp_{0,1}\hp_{0,2}^{\xi_2})^{k_1}$ and
% 	          $t_2=(cd^{\xi_2})^{k_1}$,
	          and send $(\sid,\qid,\PHash_x,0,S_2,C_{h_{x,2}})$ to $S_1$.
	        \item If $P=S_1$, compute
	          $m_{0} = \Enc_{\pk_1}^\EG(g_{1,1}^{-\mu_1}; r)$ and
	          $c_{0} = \Enc_{\pk_1}^\EG(g_{1,1}^{\pwd_1}; r')$
	          with $r,r'\rin\ZZ_q$, and send $(\sid,\qid,\Hash_0,0,S_1,m_0,c_0)$ to $S_2$.
	      \end{enumerate}
	      
% 	  \end{enumerate}
%   \item[\hspace*{1em}] {\it Computation of $\PHash_x$ between $S_1$ and $S_2$.}\smallskip
%     \begin{enumerate} \setcounter{enumi}{2}
    
	    \item On input $(\sid,\qid,\PHash_x,0,S_2,C_{h_{x,2}})$ $S_1$ in the correct state draws challenge $\fc\rin\ZZ_q$ and returns $(\sid,\qid,\PHash_x,1,S_1,\fc)$ to $S_2$.
	    
	    \item On input $(\sid,\qid,\PHash_x,1,S_1,\fc)$ $S_2$ in the correct state computes
	    $C_{s_{h_{x,2}}}=g_{1,1}^{H(\Res_{1})} h^{r_{c2}}$ with $r_{c2}\rin\ZZ_q$
% 	    $s_{h_{x,2}}=k_1-c r_{2}$ 
	    and sends $(\sid,\qid,\PHash_x,2,S_2,C_{s_{h_{x,2}}})$ to $S_1$.
	    Subsequently, it sends $(\sid,\qid,\PHash_x,3,S_2,h_{x,2}, \Comm_1, \Res_1, r_{c1}, r_{c2})$ to $S_1$.
	    %t_1, t_2, s_{h_{x,2}}
	    
	    \item On input $(\sid,\qid,\PHash_x,2,S_2,C_{s_{h_{x,2}}})$ $S_1$ in the correct state stores it and waits for the final $\PHash_x$ message.
	    
	    \item On input $(\sid,\qid,\PHash_x,3,S_2,h_{x,2}, \Comm_1, \Res_1, r_{c1}, r_{c2})$ $S_1$ in the correct state parses $\Comm_1$ as $(t_1,t_2)$ and $\Res_2$ as $s_{h_{x,2}}$ and verifies correctness of commitments and the \ZKP
% 	    $C_{h_{x,2}}\stackrel{?}{=}g_{1,1}^{H(h_{x,2}, t_1, t_2)} h^{r_{c1}}$,
% 	    $C_{s_{h_{x,2}}}\stackrel{?}{=}g_{1,1}^{H(s_{h_{x,2}})} h^{r_{c2}}$,
% 	    $t_1\stackrel{?}{=}h_{x,2}^{c} (\hp_{0,1}\hp_{0,2}^{\xi_2})^{s_{h_{x,2}}}$, and
% 	    $t_2\stackrel{?}{=}v_2^{c} (cd^{\xi_2})^{s_{h_{x,2}}}$,
	     and computes
 	    $h_x = e\left( h_{x,2}\cdot (\hp_{0,1} \cdot \hp_{0,2}^{\xi_1})^{r_1}, g_2 \right)$
 	    if the verifications are successful, $h_x\not=\bot$ and $h_0\not=\bot$, or sets $h_0=\bot$ and $h_x=\bot$ otherwise.
	    
% 	  \end{enumerate}
%   \item[\hspace*{1em}] {\it Computation of $\Hash_0$ between $S_1$ and $S_2$.}\smallskip
%     \begin{enumerate} \setcounter{enumi}{6}
	    
	    \item On input $(\sid,\qid,\Hash_0,0,S_1,m_0,c_0)$ $S_2$ in the correct state retrieves $\pk_1$ from \Fca and computes
	      $C_{\Hash_{0,1}}=g_{1,1}^{H(m_{1},m_{2},\Comm_2)} h^{r_{c3}}$
	      with $r_{c3}\rin\ZZ_q$,
	      $m_{1}\gets m_0^{\pwd_2} \times c_0^{-\mu_2} \times \Enc_{\pk_1}^\EG(g_{1,1}^{-\mu_2\cdot {\pwd_2}} \cdot u_{1,0}^{\eta_{1,2}+\xi_0\eta_{2,2}} \cdot u_{2,0}^{\theta_2} \cdot e_0^{\mu_2} \cdot v_0^{\nu_2}; r'')$, and $m_{2}\gets \Enc_{\pk_1}^\EG(g_{1,1}^{-\mu_2}; r''')$ with $r'',r'''\in\ZZ_q$,
	      and sends $(\sid,\qid,\Hash_{0,1},S_2,C_{\Hash_{0,1}})$ back to $S_1$.
	      
	    \item On input $(\sid,\qid,\Hash_{0,1},S_2,C_{\Hash_{0,1}})$ $S_1$ in the correct state draws challenge $\fc\rin\ZZ_q$ and returns $(\sid,\qid,\Hash_{0,2},S_1,\fc)$ to $S_2$. 
	    
	    \item On input $(\sid,\qid,\Hash_{0,2},S_1,\fc)$ $S_2$ in the correct state computes
	    $C_{\Res2}=g_{1,1}^{H(\Res_{2})} h^{r_{c4}}$ with $r_{c4}\rin\ZZ_q$
	    and sends $(\sid,\qid,\Hash_{0,3},S_2,C_{\Res2})$ to $S_1$.
	    Subsequently, it sends $(\sid,\qid,\Hash_{0,4},S_2, m_1, m_2, \Comm_2, \Res_2, r_{c3}, r_{c4})$ to $S_1$.
	    
	    \item On input $(\sid,\qid,\Hash_{0,4},S_2, m_1, m_2, \Comm_2, \Res_2, r_{c3}, r_{c4})$ $S_1$ in the correct state parses $\Comm_{2}$ as $(t_{\overline{m}1}, t_{\overline{m}2}, t_{e2}, t_{v2}, t_{\hp12}, t_{\hp22})$ and $\Res_{2}$ as $(s_{\pwd_2}, s_{\mu2}, s_{\eta12}, s_{\eta22}, s_{\theta2}, s_{\nu2}, s_{r2})$, verifies correctness of commitments and \ZKP , and computes
	      $h_0 = e\left( g_{1,1}^{-\mu_1\cdot \pwd_1} \cdot \Dec_{\sk_1}^\EG(m_1) \cdot u_{1,0}^{\eta_{1,1}+\xi_0\eta_{2,1}} \cdot u_{2,0}^{\theta_1} \cdot e_0^{\mu_1} \cdot v_0^{\nu_1}, g_2 \right)$ if the verifications are successful, $h_x\not=\bot$ and $h_0\not=\bot$, or sets $h_0=\bot$ and $h_x=\bot$.
	    
	    \item Eventually $S_1$ outputs $(\sid, \qid, h_0, h_x)$ if $h_0\not=\NULL$ and $h_x\not=\NULL$.
	  \end{enumerate}
	  	
% \end{description}
\end{mdframed}
\end{figure}

\paragraph{ZK Proof for $\PHash_x$ Correctness}
In order to ensure correct computation of $h_x$ on $S_1$ server $S_2$ has to prove correctness of his computations.
To this end $S_2$ sends, in addition to the $\PHash_x$ message $h_{x,2}$ the following zero-knowledge proof.
\begin{equation}
    \ZKP\big\{ (r_2):~~ h_{x,2} = (\hp_{1,0} \hp_{2,0}^{\xi_2})^{r_2} ~ \wedge ~ v_2=(cd^{\xi_2})^{r_2} \big\}
\end{equation}
where $r_2$ is the randomness used to create $C_2$, $\xi_2$ and $v_2$ are part of $C_2$, $\hp_{1,0},\hp_{2,0}$ are part of $C$'s projection key, and $c,d$ are from the \crs.
The construction of the according zero-knowledge proof is straight-forward. 
The prover computes commitments
\[ t_{hx2} = (\hp_{1,0} \hp_{2,0}^{\xi_2})^{k_{hx2}}; ~~ t_{v2} = (cd^{\xi_2})^{k_{hx2}} \]
with fresh randomness $k_{hx2}\rin\ZZ_q$, and response $s_{r2} = k_{hx2} - \fc r_2$ for verifier provided challenge $\fc$.
This allows the verifier to check
\[ t_{hx2} \stackrel{?}{=} h_{x,2}^\fc (\hp_{1,0} \hp_{2,0}^{\xi_2})^{s_{hx2}}; ~~ t_{v2} \stackrel{?}{=} v_2^\fc (cd^{\xi_2})^{s_{hx2}}. \]
It is easy to see that this zero-knowledge proof is correct, sound and (honest-verifier) simulatable.
In Figure \ref{fig:cs-tdsphf} we refer to the messages as $\Comm_{1}=(t_{hx2}, t_{v2})$, $\Res_{1}=s_{r2}$, and $\Ch_{1}=\fc$.

\paragraph{ZK Proof for $\Hash_0$ Correctness}
Let $\overline{m}_1$ and $\overline{m}_2$ denote the messages encrypted in $m_1$ and $m_2$ respectively and $m_{0,1}$ and $c_{0,1}$ the second part ($e$) of the ElGamal ciphertext $m_0$, $c_1$ respectively.
In order to ensure correct computation of $h_0$ on $S_1$ server $S_2$ has to prove correctness of his computations.
To this end $S_2$ sends, additionally to the $\Hash_0$ messages $\overline{m}_1$ and $\overline{m}_2$ the following zero-knowledge proof 
\begin{equation}
\begin{split}
    \ZKP\big\{ (x, \eta_{1,2}, \eta_{2,2}, \theta_2, \mu_2, \nu_2, r_2): ~ &  
      \overline{m}_1 = m_{0,1}^{\pwd_2} c_{0,1}^{-\mu_2} g_{1,1}^{-\mu_2 x} u_{1,0}^{\eta_{1,2} + \xi_0 \eta_{2,2}} u_{2,0}^{\theta_2} e_0^{\mu_2} v_0^{\nu_2} \\
      % ~ \wedge ~ m_2 = g_{1,1}^x
      & \wedge ~ \overline{m}_2 = g_{1,1}^{-\mu_2} ~ \wedge ~ e_2 = h^{r_2}g_{1,1}^{\pwd_2} ~ \wedge ~ v_2 = (cd^{\xi_2})^{r_2} \\
      & \wedge ~ \hp_{1,2} = g_{1,1}^{\eta_{1,2}} g_{1,2}^{\theta_2} h^{\mu_2} c^{\nu_2} ~ \wedge ~ \hp_{2,2} = g_{1,1}^{\eta_{2,2}} d^{\nu_2}
      \big\},
\end{split}
\end{equation}
where $r_2$ is the randomness used to create $C_2$, $\xi_2$ and $v_2$ are part of $C_2$, $\xi_0$ is part of $C_0$, $(\mu_2, \eta_{1,2}, \eta_{2,2}, \theta_2, \nu_2)$ is $S_2$'s hashing key, $\pwd_2$ $S_2$'s password share, and $c,d$ are from the \crs.
%variables as defined in Figure \ref{fig:cs-tdsphf}.
The construction of the according $\Sigma$ proof is straight-forward.
The prover computes commitments
\begin{align*}
  & t_{\overline{m}1} = m_{0,1}^{{\pwd_2}} c_{0,1}^{k_{\mu2}} \overline{m}_{2}^{k_{x}} u_{1,0}^{k_{\eta12} + \xi_0 k_{\eta22}} u_{2,0}^{k_{\theta2}} e_0^{-k_{\mu2}} v_0^{k_{\nu2}}; ~~
    t_{\overline{m}2} = g_{1,1}^{k_{\mu2}}; ~~  t_{e2} = h^{k_{r2}}g_{1,1}^{{\pwd_2}}; ~~ t_{v2} = (cd^{\xi_2})^{k_{r2}}; \\
  & t_{\hp12} = g_{1,1}^{k_{\eta12}} g_{1,2}^{k_{\theta2}} h^{k_{\mu2}} c^{k_{\nu2}}; ~~ t_{\hp22} = g_{1,1}^{k_{\eta22}} d^{k_{\nu2}}
    \text{ ~for~ } k_{\pwd_2}, k_{\mu2}, k_{\eta12}, k_{\eta22}, k_{\theta2}, k_{\nu2} \rin \ZZ_q
\end{align*}
and responses
\begin{align*}
  & s_{\pwd_2} = k_{\pwd_2} - \fc\pwd_2; ~~ s_{\mu2} = k_{\mu2} + \fc\mu_2; ~~ s_{\eta12} = k_{\eta12} - \fc\eta_{1,2}; ~~ s_{\eta22} = k_{\eta22} - \fc\eta_{2,2}; \\
  & s_{\theta2} = k_{\theta2} - \fc\theta_2; ~~ s_{\nu2} = k_{\nu2} - \fc\nu_2; ~~ s_{r2} = k_{r2} - \fc r_2
\end{align*}
for verifier provided challenge $\fc$.
This allows the verifier to check
\begin{align*}
  & t_{\overline{m}1} \stackrel{?}{=} \overline{m}_1^\fc m_{0,1}^{s_{\pwd_2}} c_{0,1}^{s_{\mu2}} \overline{m}_{2}^{s_{\pwd_2}} u_{1,0}^{s_{\eta12} + \xi_0 s_{\eta22}} u_{2,0}^{s_{\theta2}} e_0^{s_{\mu2}} v_0^{s_{\nu2}}; ~~ 
    t_{\overline{m}2} \stackrel{?}{=} \overline{m}_2^\fc g_{1,1}^{s_{\mu2}}; ~~  t_{e2} \stackrel{?}{=} e_2^\fc h^{s_{r2}}g_{1,1}^{s_{\pwd_2}}; \\
  & t_{v2} \stackrel{?}{=} v_2^\fc (cd^{\xi_2})^{s_{r2}}; ~~
    t_{\hp12} \stackrel{?}{=} \hp_{1,2}^\fc g_{1,1}^{s_{\eta12}} g_{1,2}^{s_{\theta2}} h^{s_{\mu2}} c^{s_{\nu2}}; ~~ 
    t_{\hp22} \stackrel{?}{=} \hp_{2,2}^\fc g_{1,1}^{s_{\eta22}} d^{s_{\nu2}} .
\end{align*}
While this is mainly a standard zero-knowledge proof $t_{\overline{m}1}$ uses $\overline{m}_2$ instead of $g_{1,1}$ as base for the third factor and $k_{\pwd_2}$ as exponent ($s_{\pwd_2}$ in the verification).
This is necessary due to the fact that the exponent $-\mu_2 {\pwd_2}$ of the third factor in $\overline{m}_1$ is a product of two values that have to be proven correct.
The ZK proof uses the auxiliary message $\overline{m}_2$ to prove that $\log_{g_{1,1}}(\overline{m}_2)=-\mu_2$ such that it is sufficient to prove $\log_{\overline{m}_2}(\overline{m}_2^{{\pwd_2}})={\pwd_2}$.
In Figure \ref{fig:cs-tdsphf} we refer to the messages as $\Comm_{2}=(t_{\overline{m}1}, t_{\overline{m}2}, t_{e2}, t_{v2}, t_{\hp12}, t_{\hp22})$, $\Res_{2}=(s_{\pwd_2}, s_{\mu2}, s_{\eta12}, s_{\eta22}, s_{\theta2}, s_{\nu2}, s_{r2})$, and $\Ch_{2}=\fc$.


%==============================================================================
% 2-Server PAKE in UC
%==============================================================================
\subsection{UC-secure Two Server PAKE (\FTWOPAKE)}\label{sec:2pake}
With \TDSPHF it is straight forward to build a 2PAKE protocol.
We follow the general framework described in \cite{KieferM14a} to build 2PAKE protocols from distributed smooth projective hash functions.
However, instead of aiming for key generation, where the client establishes a key with each of the two servers, we focus on a protocol that establishes a single key with one server, w.l.o.g. the first server.
By running the protocol twice, keys can be exchanged between the client and the second sever.
Note that UC security allows concurrent execution of the protocol such that round complexity is not increased by establishing two keys.

\subsubsection{The Protocol}\label{sec:2pakeprotocol}
% \fk{add figure}
Building a 2PAKE protocol from the \TDSPHF defined in Figure \ref{fig:cs-tdsphf} is straight forward following \cite{KieferM14a}.
Client $C$, Server $S_1$ and Server $S_2$ execute a \TDSPHF protocol as described in Section \ref{sec:tdsphf}.
This provides $C$ and $S_1$ with two hash values $h_0$ and $h_x$ each (if all protocol participants are honest and all messages reach their destination unaltered).
A session key can then be derived by simply multiplying $h_0$ and $h_x$ to $\sk=h_0\cdot h_x$.
If the protocol is not terminated prematurely and a session key is computed on $C$ and $S_1$, this ensures that $C$ and $S_1$ share a unique random session key $\sk$ after finishing an honest and correct protocol run and two independent random session keys $\sk$ in case one of the parties inputs a wrong password (share) or the traffic is altered during transport.

% \begin{tikzpicture}
% \matrix (m)[matrix of nodes, column  sep=1cm,row  sep=4mm, nodes={draw=none, anchor=center,text depth=0pt} ]{
% Client & & Server 1 & & Server 2\\ %[-4mm]
% a) & & a) && a) \\
%  & $(C_0,\hp_0)$ & & $(C_1,\hp_1)$ &  \\ [-4mm]
%  & $(C_1,\hp_1)$ & & $(C_2,\hp_2)$ &  \\ [-4mm]
%  & \hfill & $(C_0,\hp_0)$ & \hfill &  \\ [-4mm]
%  & \hfill & $(C_2,\hp_2)$ & \hfill &  \\
% b) i) & & b) iii) & & b) ii) \\
%  & & & $C_{h_{x,2}}$ &  \\
%  & & & $(m_0, c_0)$ &  \\
%  & & c) & & g)\\
%  & & & $c$ &  \\
%  & & & $C_{\Hash_{0,1}}$ &  \\
%  & & h) & & d)\\
%  & & & $c$ &  \\
%  & & & $C_{s_{h_{x,2}}}$ &  \\
% };
% 
% \draw ($(m-2-1.south west)-(0.1,0.2)$) rectangle ($(m-2-1.north east)+(0,0.1)$);
% \draw ($(m-2-3.south west)-(0.1,0.2)$) rectangle ($(m-2-3.north east)+(0,0.1)$);
% \draw ($(m-2-5.south west)-(0.1,0.2)$) rectangle ($(m-2-5.north east)+(0,0.1)$);
% % \draw[shorten <=-1.5cm,shorten >=-1.5cm] (m-1-1.south east)--(m-1-1.south west);
% % \draw[shorten <=-1.5cm,shorten >=-1.5cm] (m-1-3.south east)--(m-1-3.south west);
% % \draw[shorten <=-1.5cm,shorten >=-1.5cm] (m-1-5.south east)--(m-1-5.south west);
% \draw[shorten <=-1cm,shorten >=-1cm,-latex] (m-3-2.south west)--(m-3-2.south east);
% \draw[shorten <=-1cm,shorten >=-1cm,-latex] (m-3-4.south west)--(m-3-4.south east);
% \draw[shorten <=-1cm,shorten >=-1cm,-latex] (m-4-2.south east)--(m-4-2.south west);
% \draw[shorten <=-1cm,shorten >=-1cm,-latex] (m-4-4.south east)--(m-4-4.south west);
% \draw[shorten <=-1cm,shorten >=-1cm,-latex] ($(m-5-2.south west)-(0.7,0.12)$)--($(m-5-4.south east)-(-0.7,0.12)$);
% \draw[shorten <=-1cm,shorten >=-1cm,-latex] ($(m-6-4.south east)-(-0.7,0.12)$)--($(m-6-2.south west)-(0.7,0.12)$);
% \draw[shorten <=-1cm,shorten >=-1cm,-latex] (m-8-4.south east)--(m-8-4.south west);
% \draw[shorten <=-1cm,shorten >=-1cm,-latex] (m-9-4.south west)--(m-9-4.south east);
% \draw[shorten <=-1cm,shorten >=-1cm,-latex] (m-11-4.south west)--(m-11-4.south east);
% \draw[shorten <=-1cm,shorten >=-1cm,-latex] (m-12-4.south east)--(m-12-4.south west);
% \draw[shorten <=-1cm,shorten >=-1cm,-latex] (m-14-4.south west)--(m-14-4.south east);
% \draw[shorten <=-1cm,shorten >=-1cm,-latex] (m-15-4.south east)--(m-15-4.south west);
% 
% % \draw[shorten <=-1cm,shorten >=-1cm,-latex] (m-5-2.south east)--(m-5-2.south west);
% \end{tikzpicture}

\subsubsection{UC Security Model for Two Server PAKE}\label{sec:2pakesecurity}
We describe the ideal functionality for 2PAKE in the following, which can be seen as an extension of the known ideal functionality for PAKE protocols from Canetti et al. \cite{Canetti2005}.
The ideal functionality \FTWOPAKE is given in Figure \ref{fig:2pakef}.
\FTWOPAKE is very similar to the original two-party PAKE functionality but requires some additional functionality.
We recall the PAKE functionality in Appendix \ref{app:pake} for convenience.
In contrast to other password-related ideal functionalities such as VPAKE \cite{Gentry2006} (a.k.a. augmented PAKE) and 2PASS \cite{Camenisch_Lysyanskaya_Neven_2012} (two-server password authenticated secret sharing) we consider only the key-exchange functionality without explicit client authentication.
While it is compelling to model 2PAKE (as well as PAKE) similar to \cite{Camenisch_Lysyanskaya_Neven_2012} and allow for throttling on wrong password guesses,\footnotemark\ this is only possible if the servers are able to verify validity of the client's password, i.e. explicit authentication of the client.
We want to keep the 2PAKE functionality simple and it is known that implicit authentication is sufficient for secure channels \cite{CanettiK01} and therefore stick with implicit authentication.

\footnotetext{Servers often lock accounts or require additional authentication after a certain number of failed log-in attempts. This prevents automated online dictionary attacks, which are always possible in the password authenticated key exchange setting.}

\paragraph{A Note on Corruption}
We consider static corruption, s.t. the corrupted parties (clients and servers) are chosen by the adversary in advance.
If a server $S_b$ is corrupted, the adversary only learns $S_b$'s password share. 
The password stays secret as long as the attacker does not corrupt both servers.
while there exist two-party PAKE protocols in literature that are UC-secure with adaptive corruptions \cite{AbdallaBBCP13,AbdallaBP14a,AbdallaCCP09,AbdallaCP09}, we consider only static corruptions in this work.
Static corruption in the UC model implies security in the BPR model with adaptive corruptions \cite{Canetti2005} for PAKE protocols.
However, adaptive corruptions are obviously a stronger security notion that allow an attacker not only to execute a protocol on behalf of an honest participant but interfere with the execution of an honest party while executing the protocol.
The only PAKE constructions known today that are secure against adaptive corruptions in the UC model require more complex SPHF constructions that are not translatable to the \DSPHF approach.
It therefore seems reasonable to settle with static corruptions for two-server PAKE UC security for now.
We discuss the relation between our new UC formalisation of 2PAKE and the known BPR-based security model in Appendix \ref{app:relations}.

% FIXME: \fk{currently both servers have to be corrupted to set \sk, see if we want this or if corruption of $S_1$ should be enough}

\paragraph{2PAKE Functionality}


\begin{figure}[tbp]
\begin{mdframed}[innertopmargin=10pt]
\begin{center}
{\bf Functionality $\cF_{\mathrm{2PAKE}}$}
\end{center}
The functionality $\cF_{\mathrm{2PAKE}}$ is parameterised by a security parameter $\secpar$.
It interacts with an adversary, a client $C$ and two servers $S_1$ and $S_2$ via the following interfaces.
Without loss of generality the key is exchanged between $C$ and $S_1$.

\begin{description}

  \item[KEX Init$_C$:] Upon input $(\KEXinit, \sid, \qid, \pwd)$ from client $C$, check that \sid is $(C,S_1, S_2)$ and that \qid is unique (entries $(\KEX, \sid, \qid, S_{1}, \alpha_{1})$ or $(\KEX, \sid, \qid, S_{2}, \alpha_{2})$ may exist) and send $(\KEX, \sid, \qid, C)$ to \SIM.
      If this is a valid request, create a \emph{fresh} record $(\KEX, \sid, \qid, C, \pwd)$.
  
  \item[KEX Init$_S$:] Upon input $(\KEXinit, \sid, \qid, \alpha_b)$ from server $S_b$, $b\in\{1,2\}$, check that \sid is $(C,S_1, S_2)$ and that \qid is unique (entries $(\KEX, \sid, \qid, C, \pwd)$ or $(\KEX, \sid, \qid, S_{3-b}, \alpha_{3-b})$ may exist) and send $(\KEX, \sid, \qid, S_b)$ to \SIM.
      If this is a valid request, create a fresh record $(\KEX, \sid, \qid, S_b, \alpha_b)$.
    
  \item[TestPwd:] Upon input $(\TP, \sid, \qid, \pwd')$ from \SIM check that a fresh record $(\KEX, \sid, \qid, C, \pwd)$ exists. 
      If this is the case, mark $(\KEX, \sid, \qid, S_1, \alpha_1)$ as \compromised and reply with ``correct guess'' if $\pwd=\pwd'$, and mark it as \interrupted and reply with ``wrong guess'' if $\pwd\not=\pwd'$.
    
%   \item[TestShares:] Upon input $(\TS, \sid, \qid, \alpha'_1, \alpha'_2)$ from \SIM check that a fresh records $(\KEX, \sid, \qid, S_1, \alpha_1)$, $(\KEX, \sid, \qid, S_2, \alpha_2)$ and $(\KEX, \sid, \qid, C, \pwd)$ exist. 
%       If this is the case, mark  $(\KEX, \sid, \qid, C, \pwd)$ as \compromised and reply with ``correct guess'' if $\alpha'_1=\alpha_1 ~ \wedge ~ \alpha'_2=\alpha_2$ and as \interrupted and reply with ``wrong guess'' if $\alpha'_1\not=\alpha_1 ~ \vee ~ \alpha'_2\not=\alpha_2$.
      
  \item[Failed:] Upon input $(\FA, \sid, \qid)$ from \SIM check that records $(\KEX, \sid, \qid, C, \pwd)$ and $(\KEX, \sid, \qid, S_1, \alpha_1)$ exist that are not marked \completed. 
      If this is the case, mark both as \failed.
	
	\item[NewKey:] Upon input $(\NK, \sid,\qid, P, \sk')$ from \SIM with $P\in\{C,S_1\}$, check that a respective $(\KEX, \sid, \qid, C, \pwd)$ or $(\KEX, \sid, \qid, S, \alpha_1)$ record exists, $\sid=(C,S_1,S_2)$, $|\sk'|=\secpar$, then: %and the session is not marked for $P$ yet,
	\begin{itemize}
		\item If the session is \compromised, or either $C$ or $S_1$ and $S_2$ are corrupted, then output $(\NK, \sid,\qid,\sk')$ to $P$; else
		
		\item if the session is \emph{fresh} and a key $\sk$ was sent to $P'$ with $\sid=(P, P', S_2)$ or $\sid=(P', P, S_2)$ while $(\KEX, \sid, \qid, P', \cdot)$ was fresh, then output $(\NK, \sid, \qid, \sk)$ to $P$.
		
		\item In any other case, pick a new random key $\sk$ of length $\secpar$, and send $(\NK, \sid, \qid, \sk)$ to $P$.
	\end{itemize}
	In any case, mark \qid as \completed for $P$.
	
\end{description}
\end{mdframed}
\caption{Ideal Functionality $\cF_{\mathrm{2PAKE}}$}
\label{fig:2pakef}
\end{figure}

\noindent
The ideal functionality for 2PAKE is very similar to the PAKE functionality but considers two servers from which only one generates a session key.
The main difference is therefore the explicit modelling of participants (in contrast to symmetric parties in the two-party case).
We specify two initialisation interfaces \textbf{KEX Init}, one for the client and one for the servers.
A client is initialised with a password \pwd while a server gets a password share $\alpha_b$.
The \textbf{TestPwd} interface allows the ideal world adversary to test client passwords.
A tested session is marked \interrupted if the guess is wrong, i.e. client and server in this session receive randomly chosen, independent session keys, or marked as \compromised if the password guess is correct, i.e. the attacker is now allowed to set the session key.
The attacker can only test client passwords but not password shares of the servers.
Without knowledge of the password or any password share, a share is a uniformly at random chosen element and therefore not efficiently guessable.
If the adversary corrupted server $S_2$, retrieving the second password share $\alpha_1$ from $S_1$ is equivalent to guessing the password.
Complementing the TestPwd interface is a \textbf{Failed} interface that allows the adversary to let sessions fail.
This allows the attacker to prevent protocol participants from computing any session, i.e. failed parties do not compute a session key.
Eventually the \textbf{NewKey} interface generates session keys for client $C$ and server $S_1$.
NewKey calls for $S_2$ are ignored.
If client $C$ or server $S_1$ and $S_2$ are corrupted, or the attacker guessed the correct password, the adversary chooses the session key.
If a session key was chosen for the partnered party and the session was fresh at that time, i.e. not \compromised or \interrupted, the same session key is used again.
In any other case a new random session key is drawn.

Instead of using a single session identifier \sid we use \sid and \qid.
%(as done in \cite{Camenisch_Lysyanskaya_Neven_2012})
The session identifier \sid is composed of the three participants $(C,S_1,S_2)$ (note that we use the client $C$ also as ``username'' that identifies its account on the servers) and therefore human memorable and unique.
To handle multiple, concurrent 2PAKE executions of one \sid, we use a query identifier \qid that is unique within \sid and can be established with \Finit.
In the multi-session extension \FTWOPAKEM the \sid becomes \ssid and \sid is a globally unique identifier for the used universe, i.e. server public keys (\CA) and \crs.


\subsubsection{Security Analysis}\label{sec:2pakeproof}
The following theorem formalises the security of the previously defined 2PAKE protocol.
Note that we do not rely on any security of the \TDSPHF.
Instead we reduce the security of our 2PAKE protocol directly to the underlying problem (SXDH).
Thereby we give an indirect security proof of the proposed \TDSPHF.
% For details on the security of the \TDSPHF we refer to the full version.
 
\begin{theorem}\label{theo:uc2pake}
  The 2PAKE protocol from Section \ref{sec:2pakeprotocol} securely realises \FTWOPAKEM with static corruptions in the \Fcrs-\Fca-hybrid model if the DDH assumption holds in $\GG_1$ and $\GG_2$ and $H_k$ is a universal one-way hash function, i.e. Cramer-Shoup encryption is secure in $\GG_1$ and the DDH assumption holds in $\GG_2$.
\end{theorem}

\paragraph{Sequence of Games}
We start the proof of Theorem \ref{theo:uc2pake} by giving a sequence of games with \G{1} equal to the real-world execution with honest participants following the protocol description and the real-world adversary \cA that may have control over a set of participants, and \G{17} equal to the ideal-world execution where the protocol is replaced with the ideal functionality \FDSPHF acting on behalf of all honest protocol participants and the ideal-world adversary \SIM, detailed later.
Let $\view_i$ denote the view of environment \cZ when interacting with game \G{i}.
Note that \view is implicitly parametrised with \sid and the security parameter \secpar.
Security then follows from showing that each $\view_i$ is computationally indistinguishable from the subsequent $\view_{i+1}$, such that we can eventually follow by an hybrid argument that $\view_1$ and $\view_{17}$ are computationally indistinguishable and the protocol therefore securely realises the ideal functionality \FTWOPAKE.
All participants in the games are operated by the challenger \cC (receiving the participants input from environment \cZ), which we modify from game to game.
Every session for an $\sid=(C,S_1,S_2)$ is started with a KexInit call for each participant, defining secrets, roles, and the used query identifier.
Invalid messages, i.e. messages that do not pass the usual tests such as group membership, are discarded by the challenger.
Note that we usually only give the actual payload of messages and omit additional parts such as \sid, \qid etc.

\Gh Game $1$ is the real-world experiment in which \cZ interacts with real participants that follow, if honest, the protocol description, and the real-world adversary \cA controlling the corrupted parties.
All participants are honestly simulated by challenger \cC that knows all their inputs.

\Gh This game is identical to \G{\theoldgame}, except that the \crs is generated by \cC such that it knows the trapdoor $\tau$.
Note that the second trapdoor $\tau'$ for $\zeta$ is \emph{not} controlled by \cC yet as this would destroy any security.
Knowledge of $\tau$ allows \cC to decrypt ciphertexts $C_i$ and retrieve the used message.
This does not change anything and is therefore perfectly indistinguishable from \G{\theoldgame}.

\Gh When \cC, on behalf of $S_1$, receives first messages $(C_0, \hp_0)$ and $(C_2, \hp_2)$, it decrypts $C_0$ to $\pwd'$ and checks if this is the correct password, i.e. $\pwd'=\pwd$.
If this is not the case, $\pwd'\not=\pwd$, \cC chooses a random $h'_0\rin\GG_T$ if the subsequent $\Hash_0$ computation with $S_2$ is successful, i.e. all zero-knowledge proofs can be verified, and aborts $S_1$ otherwise.
We claim that $\view_{\theoldgame}$ is computationally indistinguishable from $\view_{\thegame}$.
The probability to distinguish the two games is bounded by the negligible probability to notice that $h_0$ is now chosen uniformly at random.
Since $C=(C_0, C_1, C_2)$ is not in $L_{\pwd, \pwd_1, \pwd_2}$ the computation of $\Hash_0$ between $S_1$ and $S_2$ yields a uniformly at random distributed hash value $h_0$.
This can be either deduced from the smoothness proven for the generic (not distributed) \TSPHF in \cite{Benhamouda_Pointcheval_2013} or by the following simplified argument.
% The hash value for $S_1$ is computed as
% \begin{align*}
%   h_0 &= e\left( g_{1,1}^{-\mu_1 \pwd_1} \cdot \left( g_{1,1}^{-\mu_1 \pwd_2} \cdot g_{1,1}^{-\mu_2 \pwd_1} \cdot g_{1,1}^{-\mu_2 \pwd_2} \cdot u_{1,0}^{\eta_{1,2}+\xi_0 \eta_{2,2}} \cdot u_{2,0}^{\theta_2} \cdot e_0^{\mu_2} \cdot v_0^{\nu_2} \right) \cdot u_{1,0}^{\eta_{1,1}+\xi_0\eta_{2,1}} \cdot u_{2,0}^{\theta_1} \cdot e_0^{\mu_1} \cdot v_0^{\nu_1}, g_2 \right) \\
% %   &= e\left( g_{1,1}^{-\mu_1 \pwd_1 -\mu_1 \pwd_2 -\mu_2 \pwd_1 -\mu_2 \pwd_2} \cdot u_{1,0}^{\eta_{1,2}+\xi_0 \eta_{2,2} + \eta_{1,1}+\xi_0\eta_{2,1}} \cdot u_{2,0}^{\theta_2 + \theta_1} \cdot e_0^{\mu_1 + \mu_2} \cdot v_0^{\nu_1 + \nu_2}, g_2 \right) \\
%   &= e\left( g_{1,1}^{(\pwd - \pwd')(\mu_1 + \mu_2)} \cdot u_{1,0}^{\eta_{1,2}+\xi_0 \eta_{2,2} + \eta_{1,1}+\xi_0\eta_{2,1}} \cdot u_{2,0}^{\theta_2 + \theta_1} \cdot h^{r_0(\mu_1 + \mu_2)} \cdot v_0^{\nu_1 + \nu_2}, g_2 \right).
% \end{align*}
As long as $C\not\in L_{\pwd, \pwd_1, \pwd_2}$ the same argument as used for SPHF and \DSPHF can be used, namely that $h_0$ is linearly independent from the adversarially known values and therefore indistinguishable from a random one.
However, this is not sufficient in this case as the attacker has the possibility to distinguish real $h_0$ values from random ones with use of the third projection keys $\hp_{3,i}$.
To show that this is not possible we show how to break the DDH assumption in $\GG_2$ if there exists a distinguisher that can distinguish real $h_0$ from random ones.
To this end we build a DDH triple $(\zeta, \fa, \fb)$ with $\crs'=\zeta=g_2^{\tau'}$ as follows.
% The first triple, $(\zeta, \fa, \fb)$, is \emph{not} a DDH triple with random elements in $\GG_2$, $\fa,\fb\rin\GG_2$.
% We construct $(\zeta, \fa, \fb)$ as DDH triple as follows.
Let $\fa=\zeta^\alpha$ and $\fb=g_2^\alpha$, then $(\zeta, \fa, \fb)$ is obviously a DDH triple.
To link this to the \TDSPHF we set $\alpha=\hk_{i,j}$, then $\fa=\hp_{3,i,j}=\zeta^{\hk_{i,j}}$ such that $\fb=g_2^{\hk_{i,j}}$. 
To build a non-DDH triple $(\zeta, \fa, \fb)$ we choose random $\bm \alpha$ and set $\fa=\hp_{3,i,j}=\zeta^{\hk_{i,j}}$ and $\fb=g_2^{\alpha_{j}}$.
To guarantee correctness we have to choose $\alpha$ such that $\alpha_j=\hk_{j,i}+\beta_j$ for $\beta\in\ker\begin{pmatrix}
  g_{1,1} & 1 & g_{1,2} & h & c \\
  1 & g_{1,1} & 1 & 1 & d
\end{pmatrix}$ for $j\in[1,5]$.
Note that this is possible because we know $\tau$, which contains the secret Cramer-Shoup key.
If we can build a distinguisher on $h_0$, we can now decide whether $(\zeta, \fa, \fb)$ is a valid DDH triple or not.

% The idea here is to build a second hashing key $\widehat{\hk}_i$ that produces the same projection key $\hp_{1,i}, \hp_{2,i}$ but a different $\widehat{\hp}_{3,i}\not=\hp_{3,i}$.
% This is possible because we know $\tau$, which contains the secret Cramer-Shoup key $(x_1, x_2, y_1, y_2, z)$ for public key $(c=g_{1,1}^{x_1}g_{1,2}^{x_2}, d=g_{1,1}^{y_1}g_{1,2}^{y_2}, h=g_{1,1}^z)$ in the \crs such that we are able to compute $\widehat{\hp}_{3,i}=(g_2^{\alpha_1}, g_2^{\alpha_2}, g_2^{\alpha_3}, g_2^{\alpha_4}, g_2^{\alpha_5})$ with $\alpha_j=\hk_{j,i}+\beta_j$ for $\beta\in\ker\begin{pmatrix}
%   g_{1,1} & 1 & g_{1,2} & h & c \\
%   1 & g_{1,1} & 1 & 1 & d
% \end{pmatrix}$ for $j\in[1,5]$.

% We therefore build $\widehat{\hk}_i=(\widehat{\eta}_{1,i}, \widehat{\eta}_{2,i}, \widehat{\theta}_{i}, \widehat{\mu}_{i}, \widehat{\nu}_{i})$ such that 
% $\hp_{1,i}=g_{1,1}^{\widehat{\eta}_{1,i}} g_{1,2}^{\widehat{\theta}_{i}} h^{\widehat{\mu}_{i}} c^{\widehat{\nu}_{i}}$ and 
% $\hp_{2,i}=g_{1,1}^{\widehat{\eta}_{2,i}} d^{\widehat{\nu}_{i}}$.

% \smallskip
% In order to solve this with our attacker we have to define $\widehat{\hk}_i=()$ .
% We can build $(\zeta, \hp_{1,0}, \hp_{2,0}, \hp_{3,0}, \Gamma)$ with $\Gamma=(e(g_{1,1}, g_2^{\eta_{1,0} + \xi_0\eta_{2,0}}), e(g_{1,1}, g_2^{\theta_0}), e(g_{1,1}, g_2^{\mu_0}), e(g_{1,1}, g_2^{\nu_0}))$.

\Gh In this game we choose $\sk\rin\GG_T$ at random in case we choose $h_0$ at random (the setting described in \G{\theoldgame}) and computation of \sk on $S_1$ is successful.
% In case \theoldgame\xspace the password is not the correct one, and the session key computed on $S_1$ (if computed) is therefore supposed to be uniformly at random distributed.
Since $h_0$ on $S_1$ is uniformly at random already and $\sk=h_0h_x$, $\view_{\thegame}$ is perfectly indistinguishable from $\view_{\theoldgame}$.

\Gh Receiving an adversarially generated or modified $C_1$ or $C_2$ on behalf of client $C$, challenger \cC chooses $h_x\rin\GG_T$ uniformly at random instead of computing it with $\Hash_x$ if $C_1$ or $C_2$ do not encrypt the correct password share $\pwd_1$ or $\pwd_2$ respectively.
% Let this denote case \thegame.
We claim that $\view_{\thegame}$ is computationally indistinguishable from $\view_{\theoldgame}$.
In this case we have $(C_0,C_1,C_1)\not\in L_{\widehat{\pwd}}$ with overwhelming probability.
The claim therefore follows by a similar argument as in Game 3, i.e. from the DDH assumption in $\GG_2$.

\Gh In this game we choose $\sk\rin\GG_T$ at random in case we choose $h_x$ at random (the setting described in \G{\theoldgame}) and computation of \sk on $C$ is successful (projection keys $\hp_1$ and $\hp_2$ are correct).
% In case \theoldgame\xspace the password shares encrypted in $C_1$ and $C_2$ do not reconstruct to \pwd, and the session key computed on $C$ (if computed) is therefore supposed to be uniformly at random distributed.
Since $h_x$ on $C$ is uniformly at random already and $\sk=h_0h_x$, $\view_{\thegame}$ is perfectly indistinguishable from $\view_{\theoldgame}$.

\Gh In this game we replace computation of hash values $h_0$ and $h_x$ 
with a lookup table with index $(\hk_1, \hk_2, L_{\pwd, \pwd_2, \pwd_2}, C_0)$ for $h_0$ and $(\hk_0, L_{\pwd, \pwd_2, \pwd_2}, C_1, C_2)$ for $h_x$.
If no such value exists, it is computed with the appropriate \Hash or \PHash function and stored in the lookup table.
Due to the correctness of the used Cramer-Shoup \TDSPHF $\view_{\thegame}$ is perfectly indistinguishable from $\view_{\theoldgame}$.

\Gh Instead of computing $\Hash_0$ for $S_1$ in case $\pwd'$ decrypted from $C_0$ is the same as $\pwd$, \cC draws a random $h_0\rin\GG_T$.
% We denote this case 2.
That is, in this game $h_0$ for $S_1$ is always chosen uniformly at random instead of computing it with $\Hash_0$.
We claim that $\view_{\thegame}$ is computationally indistinguishable from $\view_{\theoldgame}$.
The claim follows from the CCA-security of the labelled Cramer-Shoup encryption and the same argument as in Game 3, i.e. from SXDH.
In particular, we define $\G{\theoldgame}'$ and $\G{\theoldgame}''$ with computationally indistinguishable views from \G{\theoldgame} as intermediate games before \G{\thegame} such that the claim follows.
Note that the following games modify the experiment only in the previously defined case.
In $\G{\theoldgame}'$ challenger \cC computes $C_1$ for $S_1$ on a random value $\pwd'_1\rin\ZZ_q$, $\pwd'_1\not=\pwd_1$.
The CCA-security of the encryption scheme ensure that $\view_{\theoldgame'}$ is computationally indistinguishable from $\view_{\theoldgame}$.
In $\G{\theoldgame}''$ we choose a random $h_0\rin\GG_T$ instead of using the distributed $\Hash_0$ computation (the protocol is still performed but the values are not used).
Using the same argument as in \G{3}, $\view_{\theoldgame''}$ is computationally indistinguishable from $\view_{\theoldgame'}$.
The only difference between $\G{\theoldgame}''$ and \G{\thegame} now is that \cC encrypts a random value instead of $\pwd_1$ in $C_1$ in $\G{\theoldgame}''$.
The claim now follows by observing again that $\view_{\theoldgame''}$ and $\view_{\thegame}$ are computationally indistinguishable considering the CCA-security of the labelled Cramer-Shoup encryption scheme.

\Gh In this game we choose $\sk\rin\GG_T$ at random in case we choose $h_0$ at random (the setting described in \G{\theoldgame}) and computation of \sk on $S_1$ is successful.
Since $h_0$ on $S_1$ is uniformly at random and $\sk=h_0h_x$, $\view_{\thegame}$ is perfectly indistinguishable from $\view_{\theoldgame}$.

\Gh Receiving correct $C_1$ or $C_2$, i.e. encrypting $\pwd_1$ and $\pwd_2$ respectively, on behalf of client $C$, challenger \cC chooses $h_x\rin\GG_T$ uniformly at random instead of computing it with $\Hash_x$.
We claim that $\view_{\thegame}$ is computationally indistinguishable from $\view_{\theoldgame}$.
Since we have $(C_0,C_1,C_1)\in L_{\widehat{\pwd}}$ in this case, the claim follows by a similar argument as in Game 8, i.e. from the SXDH assumption.

\Gh In this game we choose $\sk\rin\GG_T$ at random in case we choose $h_0$ at random (the setting described in \G{\theoldgame}) and computation of \sk on $C$ is successful (projection keys $\hp_1$ and $\hp_2$ are correct).
% In case \theoldgame\xspace the password shares encrypted in $C_1$ and $C_2$ do not reconstruct to \pwd, and the session key computed on $C$ (if computed) is therefore supposed to be uniformly at random distributed.
Since $h_x$ on $C$ is uniformly at random already and $\sk=h_0h_x$, $\view_{\thegame}$ is perfectly indistinguishable from $\view_{\theoldgame}$.

% \Gh In this game we choose $\sk\rin\GG_T$ at random if $\Dec(C_0)=\Dec(C_1)+\Dec(C_2)$, computation of \sk is successful and no session key has been chosen for this session yet.
% If a session key $\sk$ has been chosen for this session already, this key is used.
% In game 9 and 10 $h_x$ for client $C$ and $h_0$ are chosen uniformly at random such that $\view_{\thegame}$ is perfectly indistinguishable from $\view_{\theoldgame}$.

\Gh The entire \crs including $\zeta$ is chosen by challenger \cC in this experiment.
The $\view_{\thegame}$ is perfectly indistinguishable from $\view_{\theoldgame}$ since this does not change anything else.

\Gh Upon receiving $C_1$ and $C_2$, encrypting correct password shares, \cC uses $\THash_0$ to compute $h_0$ on client $C$ instead of $\PHash_0$.
This is possible because \cC now knows trapdoor $\tau'$.
Due to \TDSPHF soundness, $\view_{\thegame}$ is perfectly indistinguishable from $\view_{\theoldgame}$.

\Gh Upon receiving $C_0$, encrypting correct password, \cC uses $\THash_x$ to compute $h_x$ on server $S_1$ instead of $\PHash_x$.
This is again possible because \cC now knows trapdoor $\tau'$.
Due to \TDSPHF soundness, $\view_{\thegame}$ is perfectly indistinguishable from $\view_{\theoldgame}$.

\Gh Instead of encrypting the correct password \pwd in $C_0$ on behalf of client $C$, \cC encrypts $0$ (which is not a valid password).
We claim that $\view_{\thegame}$ is computationally indistinguishable from $\view_{\theoldgame}$ under the DDH assumption in $\GG_1$, i.e. the CCA-security of the Cramer-Shoup encryption.
Note that encryption randomness $r$ is not used in the computation of $h_0$ anymore such that the claim follows from the Cramer-Shoup CCA-security.

\Gh Instead of encrypting the correct password share $\pwd_i$ in $C_i$ on behalf of server $S_i$ with $i\in[1,2]$, \cC encrypts a random element $\pwd'_i\rin\ZZ_q$.
We claim that $\view_{\thegame}$ is computationally indistinguishable from $\view_{\theoldgame}$ under the DDH assumption in $\GG_1$, i.e. the CCA-security of the Cramer-Shoup encryption.
Note that the probability for $\pwd'_i=\pwd_i$ is negligible such that the claim follows from the Cramer-Shoup CCA-security.

\Gh Instead of the challenger \cC simulating the protocol execution the ideal functionality \FTWOPAKE is used to interact with the ideal-world adversary \SIM.
While this game is structurally different from \G{\theoldgame} its execution is indistinguishable from the latter.
This combined with the following description of the ideal world adversary \SIM concludes the proof.


\paragraph{Simulator}
We now describe the simulator \SIM that is used in the last experiment and acts as an attacker in the ideal world against the ideal functionality \FTWOPAKE, interacting with the real world adversary \cA.
It uses a real-world adversary \cA in a way that the environment \cZ cannot  distinguish whether it is interacting with \cA and honest protocol participants in the real world, or with \SIM and dummy protocol participants (simulated by \FTWOPAKE) in the ideal world.
We describe \SIM for a single session $\sid=(C,S_1,S_2)$.
The security then follows from the UC composition theorem \cite{Canetti2001a}, covering multiple sessions of the protocol, and joint-state UC composition theorem \cite{CanettiR03}, covering the fact that \Fca and \Fcrs create a joint state for all sessions and participants.
As before, we assume that $0$ is not a valid password.

First, \SIM generates $\crs=(q,g_{1,1},g_{1,2},h,c,d,\GG_1,g_{2},\zeta,\GG_2,\GG_T,e,H_k)$ with Cramer-Shoup secret key as trapdoor $\tau=(x_1,x_2,y_1,y_2,z)$ and second trapdoor $\tau'$ for $\zeta=g_2^{\tau'}$ to answer all \Fcrs queries with \crs.
Further, \SIM generates ElGamal key pairs $(g^{z_1},z_1)$ and $(g^{z_2},z_2)$, and responds to $\Retrieve(S_i)$ queries to \Fca from $S_i$ with $(\Retrieve, S_i, (g^{z_i},z_i))$ for $i\in\{1,2\}$ and with $(\Retrieve, S_i, g^{z_i})$ to all other request.
We describe different scenarios in which the simulator operates.
First we describe simulation of the initial KEXInit call before showing the way \SIM handles different input messages and the key generation.
The simulator essentially has to ensure that the functionality chooses random, correct session keys if the execution is correct and random, independent ones in case of an error during the execution.

% \hfill\\\noindent
% {\bf A) Honest Client:}
% Consider that client $C$ is honest.
% We describe the four possible cases with i) two honest servers, ii) server $S_2$ is corrupted, iii) server $S_1$ is corrupted and iv) both servers are corrupted.
% The first case describes the entire default simulation while for all other cases we give only differences to the first case.
% 
% \begin{enumerate}[i)]
%   \item In this setting all parties $C, S_1, S_2$ are honest such that the entire protocol is simulated by \SIM and the attacker \cA has control over the network in between.
        When receiving $(\KEX, \sid, \qid, P)$ with $\sid=(C,S_1,S_2)$ and $P\in\{C,S_1,S_2\}$ from \FTWOPAKE, \SIM starts simulation of the protocol for protocol participant $P$ by computing ciphertext, projection key pair $M_i=(C_i, \hp_i)$ for $i\in\{0,1,2\}$, encrypting a dummy value ($0$ for $P=C$ and a random value $\alpha'_i\rin\ZZ_q$ for $P=S_i$, $i\in\{1,2\}$).
        \SIM outputs the computed $(C_i, \hp_i)$ to \cA.
        The first round of messages is handled as follows.
        
\begin{enumerate}
  \item When any party receives an adversarially generated but well formed first message $M_i$, $i\in\{1,2\}$ from uncorrupted $S_i$, i.e. $\VerHp$ on the projection key $\hp_i$ is $1$, \SIM queries $(\FA, \sid, \qid)$, which marks the session \failed for the receiving party and thus ensures that the party receives an independent, random session key (if any) on a NewKey query.
        
  \item When any party receives an adversarially generated but well formed first message $M_2$ from a corrupted $S_2$ while $S_1$ is not corrupted, \SIM decrypts $C_2$ to $\alpha'_2$.
        If this value is not correct, $\alpha'_2\not=\alpha_2$ (the party is corrupted such that \SIM knows the correct value), \SIM queries $(\FA, \sid, \qid)$ to ensure independent session keys on NewKey queries.    
        
  \item When client $C$ receives an adversarially generated but well formed first message $M_1$ from a corrupted $S_1$ while $S_2$ is not corrupted, \SIM decrypts $C_1$ to $\alpha'_1$.
        If this value is \emph{not} correct, $\alpha'_1\not=\alpha_1$, \SIM queries $(\FA, \sid, \qid)$ to ensure independent session keys on NewKey queries.    
        
  \item When any party receives adversarially generated but well formed first messages $M_1, M_2$ from corrupted $S_1, S_2$, \SIM decrypts $C_1$ and $C_2$ to $\alpha'_1$, $\alpha'_2$ respectively, and verifies their correctness against $\alpha_1$ and $\alpha_2$.
        If they are correct, \SIM computes $h_0\gets\THash_0(\hp_1, \hp_2,  L_{\pwd, \pwd_1, \pwd_2}, C_0, \tau')$, $h_x\gets\Hash_x(\hp_0, L_{\widehat{\pwd}}$, $C_1, C_2)$, and $\sk_C=h_0\cdot h_x$.
        Otherwise choose a random $\sk_C\in\GG_T$.
         
  \item When an honest $S_1$ or $S_2$ receives an adversarially generated but well formed first message $M_0$, i.e. $\VerHp$ on $\hp_0$ is $\true$, \SIM extracts $\pwd'$ from $C_0$ and sends $(\TP, \sid, \qid, C, \pwd')$ to \FTWOPAKE.
        If the functionality replies with ``correct guess'', \SIM uses $\pwd'$, \crs and $\tau'$ to compute $h_x\gets\THash_x(\hp_0, L_{\widehat{\pwd}}, C_1, C_2, \tau')$, $h_0\gets\Hash_0(\hk_1, \hk_2, L_{\pwd, \pwd_1, \pwd_2}, C_0)$, and $\sk_S=h_0\cdot h_x$.
        
  \item If verification of any $\hp_i$ fails at a recipient, \SIM aborts the session for the receiving participant.
\end{enumerate}  

\noindent              
        If a party does not abort, it proceeds as follows.
        After $C$ received all ciphertext, projection key pair messages and the previously described checks were performed \SIM sends $(\NK, \sid, \qid, C, \sk_C)$ to \FTWOPAKE if an $\sk_C$ for this session exists, or $(\NK, \sid, \qid, C, \bot)$ otherwise.
        %, which triggers \FTWOPAKE to either choose a random session key $\sk$, or use $\sk$ if $M_1$ and $M_2$ are unchanged and $sk$ was sent to $S_1$ earlier, and output $(\NK, \sid, \qid, \sk)$ to $C$.       $(\sid, \qid, 0, S_1, C_1, \hp_1)$ and $(\sid, \qid, 0, S_2, C_2, \hp_2)$
        After $S_1$ and $S_2$ received all ciphertext, projection key pair messages and the previously described checks were performed, \SIM simulates all further messages for honest parties, i.e. $\PHash_x$ and $\Hash_0$ computation between $S_1$ and $S_2$, with random elements and simulated zero-knowledge proofs.
        If all messages received by $S_1$ are oracle generated, send $(\NK, \sid, \qid, S_1, \sk_S)$ to \FTWOPAKE if this session is \compromised and $(\NK, \sid, \qid, S_1, \bot)$ if not.
        %, which triggers \FTWOPAKE to either choose a random session key $\sk$, or uses $\sk$, sent to $C$ earlier, and output $(\NK, \sid, \qid, \sk)$ to $S_1$.
        If any $\PHash_x$ or $\Hash_0$ message received by $S_1$ can not be verified, i.e. validation of the zero-knowledge proof fails, \SIM does nothing and aborts the session for $S_1$.
        
        

\subsection{\FTWOPAKE Discussion}\label{app:relations}
In this section we discuss some additional points of the \FTWOPAKE functionality and investigate relations to other 2PAKE security models and UC models in the password setting.

\subsubsection{\FTWOPAKE and the BPR 2PAKE Model}
While other security models for 2PAKE protocols where proposed \cite{SzydloK05}, the BPR-like security model from \cite{KatzMTB05} is the most comprehensible and (in its two-party version) established model.
We therefore discuss relation between the proposed 2PAKE UC-security using \FTWOPAKE and the BPR-like security model from \cite{KatzMTB05}.
To compare security of a 2PAKE protocol $\Pi$ in a game-based and UC setting we have to ensure that it supports session ids (necessary in the UC framework).
We therefore assume that $\Pi$ already uses UC compliant session ids.
Note that it is easy to transform any 2PAKE protocol into a 2PAKE protocol with such session ids.
Before looking into relation between the full game-based model for 2PAKE and \FTWOPAKE we want to point out that $\Pi$, securely realising \FTWOPAKE, offers ``forward secrecy'', i.e. even an adversary that knows the correct password is not able to attack an execution of $\Pi$ without actively taking part in the execution.
With this in mind it is easy to see that $\Pi$, securely realising \FTWOPAKE, is secure in the BPR-like model from \cite{KatzMTB05}.
This is because the attacker is either passive, which is covered by the previous observation, or is active and is therefore able tests one password.
Those password tests (\TestPwd in \FTWOPAKE and \Send in the game based model) give the attacker a success probability of $q/|\cD|$, with $q$ the number of active sessions and $|\cD|$ the dictionary size, when considering a uniform distribution of passwords inside the dictionary \cD.
Note that while the attacker may have knowledge of a password share, this does not increase this probability.
Security on the model from \cite{KatzMTB05} follows.

\subsubsection{\FTWOPAKE and \FPAKE}
While \FPAKE and \FTWOPAKE are very similar they contain some significant difference we want to point out here.
First, the key-exchange is performed between all three participants, but only $C$ and, w.l.o.g., $S_1$ agree on a common session key.
The \role is a technical necessity in \FPAKE for correct execution.
Since we have explicit roles in \FTWOPAKE this is not necessary here.
Due to the asymmetry in \FTWOPAKE (a client negotiates with two servers) we assume that the client is always the invoking party.
While this is the case in \FPAKE as well when considering a real world scenario, the roles might be different there such that any of the two participating parties can start the protocol execution.
The asymmetric setting in \FTWOPAKE further restricts \TestPwd queries to the client since the servers hold high entropy password shares.
While it is enough for the attacker to corrupt one party in \FPAKE to control the session key, in \FTWOPAKE he has to either corrupt or compromise the client, or corrupt both servers.
As long as only one server is corrupted, the adversary has no control over the session 	keys and the parties receive uniformly at random chosen session keys
In \FTWOPAKE session ids are human memorisable, consisting of all three involved parties $(C,S_1,S_2)$, and unique query identifier is used to distinguish between different (possibly concurrent) protocol runs of one account (\sid).
This is a rather technical difference to \FPAKE that uses only session identifiers.

% This allows both servers to negotiate a session key with $C$ by running the protocol twice with swapped roles.
	
% 	\item \FPAKE does not allow for any throttling mechanisms to avoid online dictionary attacks. 
% 	  This is an inherent shortcoming of the current \FPAKE definition and should be fixed, but is out of scope of this work.
% 	  However, we design our \FTWOPAKE functionality such that servers can refuse authentication queries from client according to a policy we do not further describe.
% 	  A general policy could be for example to refuse login attempts after three failed attempts and require additional out of band authentication thereafter to reset this counter.
% 	  Note that this does not require the protocol to provide mutual authentication as the success of a protocol can be established by the servers using other means, e.g., subsequent traffic.


\subsubsection{Corruptions}
The two-server extension of the BPR 2PAKE model used in \cite{KatzMTB05} does not consider corruptions at all.
While parties can be malicious in the model (static corruption), the attacker is not allowed to query a corrupt oracle to retrieve passwords or internal state of participants.
In our model the attacker is allowed to corrupt parties before execution.
This however implies security in the model from \cite{KatzMTB05} even if the attacker is allowed to corrupt clients to retrieve their passwords.
This is because the environment can provide the BPR attacker with the password.
However, this does not increase his success probability.
Dynamic corruptions in \FTWOPAKE on the other hand are much more intricate.
While UC-secure two party PAKE protocols with dynamic corruptions exist their approaches are not translatable to the 2PAKE setting.
The challenge of dynamic corruptions is that the simulation has to be correct even if the attacker corrupts one party \emph{after} the protocol execution has started.
This is left open for future work.
