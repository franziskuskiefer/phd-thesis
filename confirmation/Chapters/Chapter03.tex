%************************************************
\chapter{Password Authenticated Key Exchange}\label{ch:pake}
%************************************************
In this chapter we will present findings in the area of \ac{PAKE} research.
It is based on work from three research papers, appended in Appendix \ref{paper:opake}, \ref{paper:corrupt} and \ref{paper:2pake}.
For in-depth description and formal definitions we refer to the respective appendices and concentrate on the high-level concepts in these papers.

%************************************************
\section{Oblivious Password Authenticated Key Exchange} \label{sec:opake}
%************************************************
This section recalls the high-level findings of Appendix \ref{paper:opake}.
Note that the work in \ref{paper:opake}, while largely rewritten and significantly extended, is based on the M.Sc. Thesis \cite{Kiefer2012}.

We introduce the notion of \acl{OPAKE} as a solution to the problem of failed login attempts and a general compiler to transform a large class of \ac{PAKE} into \ac{OPAKE} protocols.
\ac{OPAKE} allows a client that shares \emph{one} password with a server to use a \emph{set of passwords} within one \ac{PAKE} session.
It succeeds if and only if one of those input passwords matches the one stored on the server side. The term \emph{oblivious} is used to emphasize that no information about any password, input by the client, is made available to the server.
Using special processing techniques, our \ac{OPAKE} compiler reaches nearly constant runtime on the server side, independent of the size of the client's password set.
We prove security of the \ac{OPAKE} compiler under standard assumptions using the latest game-based \ac{PAKE} model by Abdalla, Fouque and Pointcheval (PKC 2005), tailored to our needs.
We identify the requirements that \ac{PAKE} protocols must satisfy in order to suit the compiler and give a concrete \ac{OPAKE} instantiation.
The compiled protocol is implemented and its performance analysis attests to the practicality of the compiler.
Furthermore, we implement a browser plugin demonstrating how to use \ac{OPAKE} in practice.

The idea of the \ac{OPAKE} compiler is to mix $n$ \ac{PAKE} messages on client side such that the server can extract the ``right'' message using the shared password and reply only to that.
This, however, is a non-trivial problem because \ac{PAKE} messages do not provide information that would allow the server to check locally whether a given password was used in their computation; as this would offer the possibility of offline dictionary attacks.

Our solution for the identification of the ``right'' \ac{PAKE} session is a careful composition of two encoding techniques that were introduced in a different context yet allow us to generically construct \ac{AKE}-secure \ac{OPAKE} protocols from (suitable) \ac{AKE}-secure \ac{PAKE} protocols, preserving constant round complexity and offering nearly constant server load.

Our first building block is \ac{IHME} \cite{Manulis2010,Manulis2011}.
An \ac{IHME} scheme assigns a different index to each given message and encodes the resulting index-message pairs into a single structure from which messages can be recovered on the receiver side using the corresponding indices.
The \ac{IHME} structure hides indices that were used for encoding and therefore all encoded messages must contain enough entropy to prevent dictionary attacks over the index space.
An \ac{IHME} scheme consists of two algorithms \texttt{encode} and \texttt{decode}.
The \texttt{encode} algorithm takes as input a set of index-message pairs $(i_1, m_1),\ldots,(i_n, m_n)$ and outputs a structure $S$ whereas the \texttt{decode} algorithm can extract $m_j$, $j\in[1,n]$ from $S$ using the corresponding index $i_j$.
The corresponding index-hiding property demands that no information about indices $i_j$ is leaked to the adversary that doesn't know the corresponding messages $m_j$ and is defined for messages that are chosen uniformly from the \ac{IHME} message space.
In order to enable encoding of \ac{PAKE} messages using \ac{IHME} with passwords as indices we apply our second building block, namely \emph{admissible encoding} \cite{BonehF01,BrierCIMRT10,pseudorandomSignatures}.
Briefly, a function $F:S\rightarrow R$ is an \emph{$\epsilon$-admissible encoding} for $(S,R)$ with $|S|>|R|$ when for all uniformly distributed $r\in R$, the distribution of the inverse transformation $\cI_F(r)$ is $\epsilon$-statistically indistinguishable from the uniform distribution over $S$.
$\cI_F$ enables us to map \ac{PAKE} messages into the \ac{IHME} message space where necessary.

The intuition behind the compiler is to let the client run $n$ \ac{PAKE} sessions, one session for each of the $n$ input passwords $\pwdv$, and apply an index-hiding message encoding on each message-password pair.
The server can apply the shared password $\pwd$ as index to \ac{IHME} to extract the ``right'' \ac{PAKE} message. 
For this message the server computes the next round message of the given \ac{PAKE} protocol and returns the message to the client.
As soon as the underlying \ac{PAKE} protocol terminates, the server generates a confirmation message, which is then used by the client to derive the final session key.

To show the practicality of the \ac{OPAKE} compiler we implement it in \verb/C++/, and demonstrate how the compiler can be applied to implementations of the \ac{AKE}-secure, random-oracle-based SPAKE protocol from \cite{Abdalla2005}.
Based on the Firefox extension and PHP server code developed in \cite{MSD13} we implement a Firefox plugin and Apache web server module that allows to use \ac{OPAKE} on a website as a login mechanism.
While the actual user interface does not significantly differ from the implementation in \cite{MSD13}, which is focused on the standard PAKE functionality, the underlying architecture of our \ac{OPAKE} plugin and user experience is new.
We extend the architecture from \cite{MSD13} with a native Firefox plugin and Apache module (implemented in \texttt{C++}) that allows us to use well established cryptographic libraries and our previously described implementation of \ac{OPAKE}.

\subsection{Future Work}
In near future the implementation will be moved towards extension-only code.
This allows seamless installation and operation of the protocols in Firefox.
This will be either done using Emscripten compiled C/C++ code and cryptographic libraries or by pure JavaScript implementation.
We discuss these issues in Chapter \ref{ch:futurework}.


%************************************************
\section{Forward Secrecy, Corruption Models and PAKE} \label{sec:corrupt}
%************************************************
This section is based on unpublished work presented in Appendix \ref{paper:corrupt}.
We recall high-level intuition of Appendix \ref{paper:corrupt} and discuss future work on this topic.

We present the first unified approach incorporating corruption models into the current game-based model for \ac{PAKE} and explore relationships amongst those models and their impact on \ac{PAKE} security.
Even though \ac{PAKE} models have been widely studied in the last 14 years forward secrecy and the role of corrupt oracles is still hardly understood.
Corruptions allow an adversary to get internal information of \ac{PAKE} protocol participants.
While the most common corrupt oracle supplies the adversary with the long-term secret, the password, this may be done statically only in the beginning or dynamically throughout the \ac{AKE} experiment.
Furthermore, corruptions may be strengthened and return not only long-term but also ephemeral secrets or other state information of protocol participants.

Our preliminary results can be summarized as follows:
We prove impossibility of constructing secure \ac{PAKE} protocols in presence of strong corruptions without further assumptions where the adversary can access internal states of \ac{PAKE} sessions.
While this may seem as a trivial result it separates the game-based model from the \ac{UC}-based \ac{PAKE} model, in which secure protocols are possible in the presence of such an attacker, as well as from \ac{AKE} protocols with high-entropy long-term secrets.
We further show that in absence of security preserving reductions any model allowing the adversary to corrupt parties is stronger than the one where these abilities are revoked, thus refuting informal beliefs that due to the low entropy of passwords the availability of the corruption oracle is irrelevant.
Our results hold also for more advanced corruption models where the adversary has the ability to modify passwords.

\subsection{Future Work}
Work on this topic has been started with the intention to prove that the game-based model \emph{without} corrupt oracle is as powerful as the model \emph{with} corrupt oracle.
In other words, every protocol secure in the game-based model without corrupt oracle is secure in the model with dynamic access to the corrupt oracle and offers therefore forward-secrecy.
This intuition stems from the observation that the adversary is not able to perform any useful operations on corrupted sessions that would help him in winning the experiment.
However, we could only prove that corruptions make a difference in the passive case (where the adversary can not actively take part in the protocol execution) so far.
We discuss further steps in Chapter \ref{ch:futurework}.


%************************************************
\section{Distributed Smooth Projective Hashing \& Two-Server PAKE} \label{sec:twopake}
%************************************************
This section is based on unpublished work presented in Appendix \ref{paper:2pake}.
We recall high-level intuition of Appendix \ref{paper:2pake} and discuss future work on this topic.

While smooth projective hashing got a lot attention in the last ten years it has been used only in two-party protocols.
Smooth projective hashing allows to compute a hash value of a word from a language $L$ in two different ways.
Either by using a secret hashing key on the element, or utilising the public projection key and some secret information proving that the particular element is part of a specific subset under consideration.
Despite this neat feature, smooth projective hash values guarantee to be uniformly distributed in their domain as long as the input element is not from the language $L$.
These features make them a quite popular building block in many protocols such as \ac{CCA}-secure public key encryption, blind signatures, password authenticated key exchange, oblivious transfer, zero-knowledge proofs, commitments and verifiable encryption.
\ac{SPHF} are due to Cramer and Shoup \cite{Cramer2001} who used them to construct \ac{CCA}-secure public key encryption schemes and analyse mechanisms proposed in \cite{Cramer1998}.

We introduce the notion of \emph{distributed smooth projective hashing} that allows distributed computation of the hash value and demonstrate its use on the popular use case of \acl{PAKE}.
In particular, we use the distributed computation to build two-server password authenticated key exchange.
Similar to previous work on smooth projective hashing, this allows us to ``explain'' an earlier protocol on two-server password authenticated key exchange due to \citeauthor{Katz2012a} \cite{Katz2012a}.
The distributed \ac{SPHF} is actually a generalisation of the concepts used in \cite{Katz2012a}.
We use the \ac{SPHF} framework from \cite{Benhamouda2013} on cyclic groups $\GG$ of prime order and focus on languages of ciphertexts to prove general statements on distributed \acp{SPHF}.
A language $L$ is indexed by a parameter \texttt{aux}, consisting of global public information and secret variable information $\mathtt{aux}'$.
In our setting of languages of ciphertext the public part of \texttt{aux} is essentially the \ac{CRS} containing the public key of the used encryption scheme.
We define that a distributed \ac{SPHF} consists of two \texttt{Hash} functions.
One uses a set of words and hashing keys instead of a single word, hash key pair while the other operates on a set of hashing keys and a single word.
We introduce an extended notion of smooth projective hashing that allows us later to distribute the computation of their functions.
\fk[inline]{finish....}