%************************************************
\chapter{Password Authenticated Key Exchange}\label{ch:pake}
%************************************************
\acl{PAKE} is the most important use-case of password-based cryptography and the main topic of this work.
In this chapter we formally introduce \ac{PAKE}, its use-cases and formal security models.
To conclude, we discuss with the role of corruption oracles in defining forward-secrecy in \ac{PAKE} protocols the most controversial part of game-based \ac{PAKE} security.
\ac{PAKE} protocols allows parties with common knowledge of a password to establish an authenticated session key.
While other scenarios like three-party or two-server \ac{PAKE} exist, the most common scenario is the two-party \ac{PAKE} where a client and server negotiate a session key, authenticated with a password.
Therefore we recall the most common security models for \ac{PAKE} for two-party protocols.

\section{Game-Based PAKE Model} \label{sec:gamebasedpake} %\cite{Bellare2000,Abdalla2005}
In this section we recall the \ac{PAKE} security model from \cite{Abdalla2005}.
This game-based security model for \ac{PAKE} protocols is in the multi-user setting and utilises the \acl{RoR} approach for \ac{AKE}-security from~\cite{Abdalla2005,Bellare2000}.
Note that the exact definition of this model varies such that we use the one we think is the most complete and easiest to understand.

A \ac{PAKE} protocol is executed between two parties $P$ and $P'$, chosen from the universe of participants $\Omega=\cS\cup\cC$, where $\cS$ denotes the universe of servers and $\cC$ the universe of clients, such that if $P\in\cC$ then $P'\in\cS$, and vice versa.
For each pair $(P,P')\in\cC\times\cS$, a password $\pwd_{P,P'}$ (shared between client $P$ and server $P'$) is drawn uniformly at random from the dictionary $\cD$ of size $|\cD|$.
We will sometimes write $\pwd$ instead of $\pwd_{P,P'}$ when the association with the participants is clear or if it applies to every participant.

\paragraph{On Uniform Randomness of Passwords}
The game-based \ac{PAKE} security models needs a pre-determined, known distribution the passwords are chosen from.
Usually a uniform distribution is used even though other distributions are possible.\footnote{In case of non-uniform distributions the adversarial success probability has to be adapted accordingly.}
However, this is the main drawback of this security model.
We describe \ac{UC}-security for \ac{PAKE} protocols in Section \ref{sec:ucpake} that avoids this problem, but introduces new ones.

\paragraph{Protocol Instances}
For $i\in\NN$, we denote by $P_i$ the $i$-th instance of $P\in\Omega$.
In order to model uniqueness of $P_i$ within the model we use $i$ as a counter. For each instance $P_i$ we consider further a list of parameters:
\begin{itemize}
    \item $\pid^i_P$ is the partner id of $P_i$, defined upon initialisation, subject to following restriction: if $P_i\in\cC$ then $\pid^i_P\in\cS$, and if $P_i\in\cS$ then $\pid^i_P\in\cC$.
    \item $\sid^i_P$ is the session id of $P_i$, modelled as ordered (partial) protocol transcript $[\mIn^1,\mOut^1,$ $\ldots, \mIn^r,\mOut^r]$ of incoming and outgoing messages of $P_i$ in rounds 1 to $r$.
    	$\sid^i_P$ is thus updated on each sent or received protocol message.
    \item $\key^i_P$ is the value of the session key of instance $P_i$, which is initialised to $\NULL$.
    \item $\state^i_P$ is the internal state of instance $P_i$.
    \item $\used^i_P$ indicates whether $P_i$ has already been used.
    \item $\role^i_P$ indicates whether $P_i$ acts as a \client or a \server.
\end{itemize}

\paragraph{Partnered Instances}
Two instances $P_i$ and $P'_j$ are \emph{partnered} if all of the following holds:
(i) $(P,P')\in\cC\times\cS$, (ii) $\pid^i_P=P'$ and $\pid^j_{P'}=P$, and (iii) $\mathtt{match}(\sid^i_P, \sid^j_{P'})=1$, where Boolean algorithm $\mathtt{match}$ is defined according to the matching conversations from \cite{Bellare1993}, \ie outputs $1$ if and only if round messages (in temporal order) in $\sid^i_P$ equal to the corresponding round messages in $\sid^j_{P'}$ except for the final round, in which the incoming message of one instance may differ from the outgoing message of another instance.

%TODO:
%\subsubsection{Correctness}
%Let $P_i$ be an instance initialised through $\init(\pwdv_P,\allowbreak \client, P',\allowbreak \para)$ and $P'_j$ be an instance initialised through $\init(\pwd_{P,P'}, \server,\allowbreak P, \para)$ where $P\in\cC$, $P'\in\cS$, and $\pwd_{P,P'}\in\pwdv_P$.
%Assume that all outgoing messages, generated by $\nextm$ are faithfully transmitted between $P_i$ and $P'_j$ so that the instances become partnered.
%An $\ac{PAKE}=(\init,\nextm)$ is said to be \emph{correct} if for all partnered $P_i$ and $P'_j$ it holds that $\key^i_P\in\cK$ and $\key^i_P=\key^j_{P'}$.

%------------------------------------------------
%   AKE Security
%------------------------------------------------

\subsection{Adversary Model}
The adversary $\cA$ is modelled as a \ac{PPT} algorithm, with access to the following oracles:
\begin{description}
    \item[$\mOut\algout\Send(P_i,P',\mIn)$:] the oracle processes the incoming message $\mIn$ for the instance $P_i$ and returns its outgoing message $\mOut$.
    	Using \Send with an empty message prompts $P$ to initiate a new protocol with $P'$.
    \item[$\trans\algout\Execute(P,P')$:] if $(P,P')\in\cC\times\cS$ the oracle creates two new instances $P_i$ and $P'_j$ and returns the transcript \trans of their honest protocol execution.
    \item[$\pwd\algout\Corrupt(P, P')$:] if $P\in\cC$ and $P'\in\cS$ then return $\pwd_{P,P'}$ and mark $(P,P')$ as a corrupted pair.
\end{description}

\noindent
Note that the original \ac{RoR} definition in \cite{Abdalla2005} omits the \Corrupt oracle.
However, we give it here for completeness.
We will see a discussion on forward-secrecy and the \Corrupt oracle in Section \ref{sec:corrupt}.

\subsection{AKE-Security}\label{ssec:pake}
The following definition of \ac{AKE}-security follows the \ac{RoR} approach from \cite{Abdalla2005}, which provides the adversary multiple access to the $\Test$ oracle for which the randomly chosen bit $b\rin\bits$ is fixed in the beginning of the experiment.
The adversary $\cA$ gets access to another oracle called \Test.
$\key_\cA\algout\Test(P_i)$, depending on the values of bit $b$ and $\key^i_P$, this oracle responds with key $\key_\cA$ defined as follows:
\begin{itemize}
	\item If a pair $(P,\pid^i_P)$ or $(\pid^i_P, P)$ was corrupted (cf. definition of $\Corrupt$ oracle) while $\key^i_P=\NULL$, then abort. Note that this prevents $\cA$ from obtaining $\pwd_{P,P'}$ and then testing new instances of $P$ and $P'$ or instances that were still in the process of establishing session keys when corruption took place.
	\item If some previous query $\Test(P'_j)$ was asked for an instance $P'_j$, which is partnered with $P_i$, and $b=0$ then return the same response as to that query. Note that this guarantees consistency of oracle responses.
	\item If $\key^i_P$ has been computed then if $b=1$, return $\key^i_P$, else if $b=0$, return a randomly chosen element from the key space and store it for later use.
	\item Else return $\key^i_P$. Note that in this case $\key^i_P$ is either $\bot$ or $\NULL$.
\end{itemize}
According to \cite{Abdalla2005} a session is an online session when $\cA$ queried the $\Send$ oracle on one of the participants.

\begin{definition}[AKE-Security]\label{def:ake}
A \ac{PAKE} protocol $\Pi$ is \emph{\ac{AKE}-secure} if for all dictionaries $\cD$ with corresponding universe of participants $\Omega$ and for all \ac{PPT} adversaries $\cA$ using at most $t$ online session there exists a negligible function $\varepsilon(\cdot)$ such that:
\[\Adv^{\AKESEC}_{\Pi,\cA}(\secpar)=\left|\Pr[\Exp_{\Pi,\cA}^{\AKESEC}(\secpar)=1]-\frac12\right|\leq \frac{\cO(t)}{|\cD|}+\varepsilon(\secpar).\]

\noindent$\Exp_{\Pi,\cA}^{\AKESEC}(\secpar):$ \\
\hspace*{2em} $b\rin\bits$\\
\hspace*{2em} $b'\gets\cA^{\Send,\Execute,\Corrupt,\Test}(\secpar)$\\
\hspace*{2em} return $b=b'$.
\end{definition}

\paragraph{RoR VS. FtG}
The \acl{RoR} approach for \ac{PAKE} security is proposed in \cite{Abdalla2005} and modifies the original \acl{FtG} \ac{AKE}-security from \cite{Bellare2000} in two ways:
(i) Instead of allowing only one \Test query, the adversary may query as many \Test queries as he desires.
(ii) Using multiple \Test queries allows to drop the \Reveal oracle that would give the adversary the possibility to retrieve the \emph{correct} password of a protocol participant.
Since the \ac{RoR} is simpler (less oracles) and provably stronger (cf. \cite[Lemma 2, Proposition 1]{Abdalla2005}) it should be used for analysing \ac{PAKE} protocols.

%************************************************
\section{Universally Composable Password Authenticated Key Exchange} \label{sec:ucpake}
%************************************************
\citeauthor{Canetti2005} proposed a new \ac{PAKE} security model in \cite{Canetti2005} in the \acl{UC} framework from \cite{Canetti2001a}.
As mentioned before the adversary, here denoted \cZ, in the \ac{UC} framework has to distinguish between a correct \ac{PAKE} protocol execution with a real world adversary \cA and the execution of an ideal functionality \cF with an ideal world adversary \cS.
Thus, the security definition of a protocol is given by an ideal functionality rather than oracles.
Note that we do not recall the complete \ac{UC} framework but assume general familiarity with it.
Figure \ref{fig:pakef} gives the ideal functionality \cFPAKE with joint states and multi-session extension.
A \ac{PAKE} protocol is secure (securely realises \cFPAKE) if for every real world adversary \cA there exists an ideal world adversary \cS such that the environment \cZ can not distinguish whether it is interacting with \cA and the real protocol, or \cS and the ideal functionality.
Note that a dummy adversary \cA that only forwards messages to the environment and follows its instructions (cf. \cite{Canetti2001a}).
Furthermore, note that \cFPAKE makes only sense with joint states and multi-session extension as it is impossible to achieve \ac{UC} security in the plain model (cf. \cite[Section 4]{Canetti2005}).
Thereby, a \ac{CRS} and thus a joint state is necessary.\footnote{Actually other assumption may also work but also need a common setup.}

\begin{figure}[h!]
\begin{mdframed}[innertopmargin=10pt]
\begin{center}
{\bf Functionality \cFPAKE}
\end{center}
The functionality \cFPAKE is parametrised by a security parameter \secpar. It interacts with an adversary \cS and a set of parties via the following queries:
\begin{description}
	\item[]NewSession: Upon input $(\NS, \sid, \ssid, P_i, P_j, \pwd, \role)$ from $P_i$, check that $P_j$ is legit and send $(\NS, \sid, \ssid, P_i, P_j, \role)$ to \cS.
	If this is the first NewSession query, or if this is the second NewSession query and there is a record $(\sid, \ssid, P_j,P_i,\pwd')$, then record $(\sid, \ssid, P_i, P_j, \pwd)$ and mark this record fresh.
	
	\item[]TestPwd: Upon input $(\TP, \sid, P_i, \pwd')$ from \cS, check that a fresh record $(\sid, \ssid, P_i, P_j, \pwd)$ exists, then do:
	If $\pwd=\pwd'$, mark the record as \emph{compromised} and reply to \cS with ``correct guess''. If $\pwd\not=\pwd'$, mark the record \emph{interrupted} and reply with ``wrong guess''.
	
	\item[]NewKey: Upon input $(\NK, \sid, \ssid, P_i, \sk)$ from \cS, check that a record $(\sid, \ssid, P_i, P_j, \pwd)$ exists, $|\sk|=\secpar$ and this is the first NewKey query for $P_i$, then:
	\begin{itemize}
		\item If the record is \emph{compromised}, or either $P_i$ or $P_j$ is corrupted, then output $(\sid,\ssid,\sk)$ to $P_i$.
		\item If the record is fresh, and there is a record $(\sid, \ssid, P_j, P_i, \pwd')$ with $\pwd'=\pwd$, and a key $\sk'$ was set to $P'_j$ and $(\sid, \ssid, P_j,P_i,\pwd)$ was fresh at the time, then output $(\sid,\ssid,\sk')$ to $P_i$.
		\item In any other case, pick a new random key $\sk'$ of length \secpar and send $(\sid,\ssid,\sk')$ to $P_i$.
	\end{itemize}
	Either way, mark the record $(\sid,\ssid,P_i,P_j,\pwd)$ as completed.
	
\end{description}
\end{mdframed}
\caption{Ideal Functionality \cFPAKE}
\label{fig:pakef}
\end{figure}

\noindent
Proving security of \ac{PAKE} protocols in the \ac{UC} framework has two main advantages.
(i) The aforementioned composability of \ac{UC} security applies such that a protocol proven secure against \cFPAKE is secure in arbitrary composition with other (possibly insecure) protocols.
(ii) We do not have to assume a particular password distribution.
Since passwords are chosen by the environment, security holds for all (efficient) password distributions including related passwords.
Especially (ii) is a big advantage over the game-based model.
Assuming unrelated, uniformly distributed passwords is clearly not appropriate given everything known about human password choice.

However, it introduces the need for setup assumptions such as \ac{CRS} and often complicates the proof.
It was an open problem until recently to construct one-round protocols in the \ac{UC} framework (solved by \citeauthor{Benhamouda2013} \cite{Benhamouda2013} in \citeyear{Benhamouda2013}).

%************************************************
\section{Forward-Secrecy, Corruption Models and PAKE} \label{sec:corrupt}
%************************************************
This section is concerned with forward-secrecy in the game-based \ac{PAKE} model from \cite{Bellare2000,Abdalla2005}, based on unpublished work presented in Appendix \ref{paper:corrupt}.
We recall high-level intuition of Appendix \ref{paper:corrupt} and discuss future work on this topic.

Thereby, we present the first unified approach incorporating corruption models into the game-based model for \ac{PAKE} and explore relationships amongst those models and their impact on \ac{PAKE} security.
Even though \ac{PAKE} models have been widely studied in the last 14 years forward secrecy and the role of corruption oracles is still hardly understood.
Corruptions allow an adversary to get internal information of \ac{PAKE} protocol participants.
While the most common corrupt oracle supplies the adversary with the long-term secret, the password, this may be done statically only in the beginning or dynamically throughout the \ac{AKE}-security experiment.
Furthermore, corruptions may be strengthened and return not only long-term but also ephemeral secrets or other state information of protocol participants.

In Definition~\ref{def:corrmodels} we summarise several corruption models that have been used in the literature.

\begin{definition}[Corruption Models]\label{def:corrmodels}
The availability of a \Corrupt oracle and its input-output behaviour in response to the queries of an adversary \cA is defined according to one of the following \emph{corruption models}:
\begin{itemize}
	\item\emph{Zero Corruption Model:} \cA has no access to the \Corrupt oracle.
	
	\item\emph{Static Corruption Model:} \cA has no access to the \Corrupt oracle but can initially define a set of client-server pairs $\cF=\{(C,S)\}_{(C,S)\in\cC\times\cS}$ and retrieve the corresponding set of passwords $\{\pwd_{C,S}\}_{(C,S)\in \cF}$.
		All pairs $(C,S)\in\cF$ are marked as corrupted.
	
	\item\emph{Adaptive Corruption Model:} \cA has access to the \Corrupt oracle to which it may ask queries containing pairs $(C, S)$.
		In response, the oracle outputs $\pwd_{C,S}$. The pair $(C,S)$ is marked as corrupted.
	
	\item\emph{Strong Corruption Model:} \cA has access to the \Corrupt oracle to which he may ask queries containing pairs $(C, S)$.
		In response, the oracle outputs the state information $\state^i_C$ of all client instances $C_i$ that have been invoked with server $S$ as an intended PAKE partner.
			Note that $\pwd_{C,S}$ is part of $\state^i_C$.
			The pair $(C,S)$ is marked as corrupted.
	
\end{itemize}

\noindent
A corruption model that provides the adversary \cA with access to the \Corrupt oracle allows \emph{password modification} if in addition to a pair $(C,S)$ \cA can submit some $\pwd^\ast\in\cD$ as an additional input that will then be used instead of $\pwd_{C,S}$ in all server instances $S_j$ that are invoked later with $C$ as intended \ac{PAKE} partner.
\end{definition}

\noindent
The \emph{zero corruption} model is equivalent to the original PAKE definition \emph{without forward secrecy} in \cite{Bellare2000,Abdalla2005}.
The \emph{static corruption} model has been mentioned without further formalisation in \cite{Abdalla2005,Gennaro2008}.
The \emph{adaptive corruption} and \emph{strong corruption} models have been called \emph{weak} respectively \emph{strong corruption} models in \cite{Bellare2000}.
The \emph{password modifying} ability of corrupt oracles is part of the original model in \cite{Bellare2000}.

Our preliminary results can be summarised as follows:
We can prove impossibility of constructing secure \ac{PAKE} protocols in presence of strong corruptions without further assumptions where the adversary can access internal states of \ac{PAKE} sessions.
While this may seem a trivial result it separates the game-based model from the \ac{UC} \ac{PAKE} model, in which secure protocols are possible in the presence of such an attacker, as well as from \ac{AKE} protocols with high-entropy long-term secrets.
We further show that in absence of security preserving reductions any model allowing the adversary to corrupt parties is stronger than the one where these abilities are revoked, thus refuting informal beliefs that due to the low entropy of passwords the availability of the corruption oracle is irrelevant.
Our results hold also for more advanced corruption models where the adversary has the ability to modify passwords.

\section{Future Work}
Work on this topic has been started with the intention to prove that the game-based model \emph{without} corrupt oracle is as powerful as the model \emph{with} corrupt oracle.
In other words, every protocol secure in the game-based model without corrupt oracle is secure in the model with dynamic access to the corrupt oracle and offers therefore forward-secrecy.
This intuition stems from the observation that the adversary is not able to perform any useful operations on corrupted sessions that would help him in winning the experiment.
\citeauthor{ChooBH05} state in \cite{ChooBH05} even ``However, we consider the original BPR2000 model without \Corrupt query because the basic notion of BPR2000 freshness restricts the adversary, \cA, from corrupting anyone in the model (i.e., effectively restricting \cA from asking any \Corrupt query)''.
However, we could only prove that corruptions make a difference in the passive case (where the adversary can not actively take part in the protocol execution) so far.
Following this line of work we will try to bring forward the understanding of \ac{PAKE} models in general, and regarding forward-secrecy in special.
